<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>通过例子学 Rust 中文版</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="通过例子学 Rust, Rust By Example 中文版，RBE 中文版，本书通过详细的可运行的 Rust 程序来讲解 Rust 语言有关的知识点，通俗易懂，是 Rust 初学者必备的学习参考书，同时也能作为 Rust 工程师日常工作中快速查找知识点的必备查询手册。">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">簡介</a></li><li class="chapter-item expanded "><a href="hello.html"><strong aria-hidden="true">1.</strong> Hello World</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hello/comment.html"><strong aria-hidden="true">1.1.</strong> 註釋</a></li><li class="chapter-item expanded "><a href="hello/print.html"><strong aria-hidden="true">1.2.</strong> 格式化輸出</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hello/print/print_debug.html"><strong aria-hidden="true">1.2.1.</strong> 調試（debug）</a></li><li class="chapter-item expanded "><a href="hello/print/print_display.html"><strong aria-hidden="true">1.2.2.</strong> 顯示（display）</a></li><li class="chapter-item expanded "><a href="hello/print/print_display/testcase_list.html"><strong aria-hidden="true">1.2.3.</strong> 測試實例：List</a></li><li class="chapter-item expanded "><a href="hello/print/fmt.html"><strong aria-hidden="true">1.2.4.</strong> 格式化</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="primitives.html"><strong aria-hidden="true">2.</strong> 原生類型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="primitives/literals.html"><strong aria-hidden="true">2.1.</strong> 字面量和運算符</a></li><li class="chapter-item expanded "><a href="primitives/tuples.html"><strong aria-hidden="true">2.2.</strong> 元組</a></li><li class="chapter-item expanded "><a href="primitives/array.html"><strong aria-hidden="true">2.3.</strong> 數組和切片</a></li></ol></li><li class="chapter-item expanded "><a href="custom_types.html"><strong aria-hidden="true">3.</strong> 自定義類型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="custom_types/structs.html"><strong aria-hidden="true">3.1.</strong> 結構體</a></li><li class="chapter-item expanded "><a href="custom_types/enum.html"><strong aria-hidden="true">3.2.</strong> 枚舉</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="custom_types/enum/enum_use.html"><strong aria-hidden="true">3.2.1.</strong> 使用 use</a></li><li class="chapter-item expanded "><a href="custom_types/enum/c_like.html"><strong aria-hidden="true">3.2.2.</strong> C 風格用法</a></li><li class="chapter-item expanded "><a href="custom_types/enum/testcase_linked_list.html"><strong aria-hidden="true">3.2.3.</strong> 測試實例：鏈表</a></li></ol></li><li class="chapter-item expanded "><a href="custom_types/constants.html"><strong aria-hidden="true">3.3.</strong> 常量</a></li></ol></li><li class="chapter-item expanded "><a href="variable_bindings.html"><strong aria-hidden="true">4.</strong> 變量綁定</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="variable_bindings/mut.html"><strong aria-hidden="true">4.1.</strong> 可變變量</a></li><li class="chapter-item expanded "><a href="variable_bindings/scope.html"><strong aria-hidden="true">4.2.</strong> 作用域和遮蔽</a></li><li class="chapter-item expanded "><a href="variable_bindings/declare.html"><strong aria-hidden="true">4.3.</strong> 變量先聲明</a></li><li class="chapter-item expanded "><a href="variable_bindings/freeze.html"><strong aria-hidden="true">4.4.</strong> 凍結</a></li></ol></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">5.</strong> 類型系統</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types/cast.html"><strong aria-hidden="true">5.1.</strong> 類型轉換</a></li><li class="chapter-item expanded "><a href="types/literals.html"><strong aria-hidden="true">5.2.</strong> 字面量</a></li><li class="chapter-item expanded "><a href="types/inference.html"><strong aria-hidden="true">5.3.</strong> 類型推斷</a></li><li class="chapter-item expanded "><a href="types/alias.html"><strong aria-hidden="true">5.4.</strong> 別名</a></li></ol></li><li class="chapter-item expanded "><a href="conversion.html"><strong aria-hidden="true">6.</strong> 類型轉換</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="conversion/from_into.html"><strong aria-hidden="true">6.1.</strong> From 和 Into</a></li><li class="chapter-item expanded "><a href="conversion/try_from_try_into.html"><strong aria-hidden="true">6.2.</strong> TryFrom 和 TryInto</a></li><li class="chapter-item expanded "><a href="conversion/string.html"><strong aria-hidden="true">6.3.</strong> ToString 和 FromStr</a></li></ol></li><li class="chapter-item expanded "><a href="expression.html"><strong aria-hidden="true">7.</strong> 表達式</a></li><li class="chapter-item expanded "><a href="flow_control.html"><strong aria-hidden="true">8.</strong> 流程控制</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="flow_control/if_else.html"><strong aria-hidden="true">8.1.</strong> if/else</a></li><li class="chapter-item expanded "><a href="flow_control/loop.html"><strong aria-hidden="true">8.2.</strong> loop 循環</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="flow_control/loop/nested.html"><strong aria-hidden="true">8.2.1.</strong> 嵌套循環和標籤</a></li><li class="chapter-item expanded "><a href="flow_control/loop/return.html"><strong aria-hidden="true">8.2.2.</strong> 從 loop 循環返回</a></li></ol></li><li class="chapter-item expanded "><a href="flow_control/while.html"><strong aria-hidden="true">8.3.</strong> while 循環</a></li><li class="chapter-item expanded "><a href="flow_control/for.html"><strong aria-hidden="true">8.4.</strong> for 循環和區間</a></li><li class="chapter-item expanded "><a href="flow_control/match.html"><strong aria-hidden="true">8.5.</strong> match 匹配</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="flow_control/match/destructuring.html"><strong aria-hidden="true">8.5.1.</strong> 解構</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="flow_control/match/destructuring/destructure_tuple.html"><strong aria-hidden="true">8.5.1.1.</strong> 元組</a></li><li class="chapter-item expanded "><a href="flow_control/match/destructuring/destructure_enum.html"><strong aria-hidden="true">8.5.1.2.</strong> 枚舉</a></li><li class="chapter-item expanded "><a href="flow_control/match/destructuring/destructure_pointers.html"><strong aria-hidden="true">8.5.1.3.</strong> 指針和引用</a></li><li class="chapter-item expanded "><a href="flow_control/match/destructuring/destructure_structures.html"><strong aria-hidden="true">8.5.1.4.</strong> 結構體</a></li></ol></li><li class="chapter-item expanded "><a href="flow_control/match/guard.html"><strong aria-hidden="true">8.5.2.</strong> 衛語句</a></li><li class="chapter-item expanded "><a href="flow_control/match/binding.html"><strong aria-hidden="true">8.5.3.</strong> 綁定</a></li></ol></li><li class="chapter-item expanded "><a href="flow_control/if_let.html"><strong aria-hidden="true">8.6.</strong> if let</a></li><li class="chapter-item expanded "><a href="flow_control/while_let.html"><strong aria-hidden="true">8.7.</strong> while let</a></li></ol></li><li class="chapter-item expanded "><a href="fn.html"><strong aria-hidden="true">9.</strong> 函數</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fn/methods.html"><strong aria-hidden="true">9.1.</strong> 方法</a></li><li class="chapter-item expanded "><a href="fn/closures.html"><strong aria-hidden="true">9.2.</strong> 閉包</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fn/closures/capture.html"><strong aria-hidden="true">9.2.1.</strong> 捕獲</a></li><li class="chapter-item expanded "><a href="fn/closures/input_parameters.html"><strong aria-hidden="true">9.2.2.</strong> 作為輸入參數</a></li><li class="chapter-item expanded "><a href="fn/closures/anonymity.html"><strong aria-hidden="true">9.2.3.</strong> 類型匿名</a></li><li class="chapter-item expanded "><a href="fn/closures/input_functions.html"><strong aria-hidden="true">9.2.4.</strong> 輸入函數</a></li><li class="chapter-item expanded "><a href="fn/closures/output_parameters.html"><strong aria-hidden="true">9.2.5.</strong> 作為輸出參數</a></li><li class="chapter-item expanded "><a href="fn/closures/closure_examples.html"><strong aria-hidden="true">9.2.6.</strong> std 中的例子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fn/closures/closure_examples/iter_any.html"><strong aria-hidden="true">9.2.6.1.</strong> Iterator::any</a></li><li class="chapter-item expanded "><a href="fn/closures/closure_examples/iter_find.html"><strong aria-hidden="true">9.2.6.2.</strong> Iterator::find</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="fn/hof.html"><strong aria-hidden="true">9.3.</strong> 高階函數</a></li><li class="chapter-item expanded "><a href="fn/diverging.html"><strong aria-hidden="true">9.4.</strong> 發散函數</a></li></ol></li><li class="chapter-item expanded "><a href="mod.html"><strong aria-hidden="true">10.</strong> 模塊</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="mod/visibility.html"><strong aria-hidden="true">10.1.</strong> 可見性</a></li><li class="chapter-item expanded "><a href="mod/struct_visibility.html"><strong aria-hidden="true">10.2.</strong> 結構體的可見性</a></li><li class="chapter-item expanded "><a href="mod/use.html"><strong aria-hidden="true">10.3.</strong> use 聲明</a></li><li class="chapter-item expanded "><a href="mod/super.html"><strong aria-hidden="true">10.4.</strong> super 和 self</a></li><li class="chapter-item expanded "><a href="mod/split.html"><strong aria-hidden="true">10.5.</strong> 文件分層</a></li></ol></li><li class="chapter-item expanded "><a href="crates.html"><strong aria-hidden="true">11.</strong> crate</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="crates/lib.html"><strong aria-hidden="true">11.1.</strong> 庫</a></li><li class="chapter-item expanded "><a href="crates/using_lib.html"><strong aria-hidden="true">11.2.</strong> 使用庫</a></li></ol></li><li class="chapter-item expanded "><a href="cargo.html"><strong aria-hidden="true">12.</strong> cargo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cargo/deps.html"><strong aria-hidden="true">12.1.</strong> 依賴</a></li><li class="chapter-item expanded "><a href="cargo/conventions.html"><strong aria-hidden="true">12.2.</strong> 約定規範</a></li><li class="chapter-item expanded "><a href="cargo/test.html"><strong aria-hidden="true">12.3.</strong> 測試</a></li><li class="chapter-item expanded "><a href="cargo/build_scripts.html"><strong aria-hidden="true">12.4.</strong> 構建腳本</a></li></ol></li><li class="chapter-item expanded "><a href="attribute.html"><strong aria-hidden="true">13.</strong> 屬性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="attribute/unused.html"><strong aria-hidden="true">13.1.</strong> 死代碼 dead_code</a></li><li class="chapter-item expanded "><a href="attribute/crate.html"><strong aria-hidden="true">13.2.</strong> crate</a></li><li class="chapter-item expanded "><a href="attribute/cfg.html"><strong aria-hidden="true">13.3.</strong> cfg</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="attribute/cfg/custom.html"><strong aria-hidden="true">13.3.1.</strong> 自定義條件</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">14.</strong> 泛型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="generics/gen_fn.html"><strong aria-hidden="true">14.1.</strong> 函數</a></li><li class="chapter-item expanded "><a href="generics/impl.html"><strong aria-hidden="true">14.2.</strong> 實現</a></li><li class="chapter-item expanded "><a href="generics/gen_trait.html"><strong aria-hidden="true">14.3.</strong> trait</a></li><li class="chapter-item expanded "><a href="generics/bounds.html"><strong aria-hidden="true">14.4.</strong> 約束</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="generics/bounds/testcase_empty.html"><strong aria-hidden="true">14.4.1.</strong> 測試實例：空約束</a></li></ol></li><li class="chapter-item expanded "><a href="generics/multi_bounds.html"><strong aria-hidden="true">14.5.</strong> 多重約束</a></li><li class="chapter-item expanded "><a href="generics/where.html"><strong aria-hidden="true">14.6.</strong> where 子句</a></li><li class="chapter-item expanded "><a href="generics/new_types.html"><strong aria-hidden="true">14.7.</strong> newtype 慣用法</a></li><li class="chapter-item expanded "><a href="generics/assoc_items.html"><strong aria-hidden="true">14.8.</strong> 關聯項</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="generics/assoc_items/the_problem.html"><strong aria-hidden="true">14.8.1.</strong> 存在問題</a></li><li class="chapter-item expanded "><a href="generics/assoc_items/types.html"><strong aria-hidden="true">14.8.2.</strong> 關聯類型</a></li></ol></li><li class="chapter-item expanded "><a href="generics/phantom.html"><strong aria-hidden="true">14.9.</strong> 虛類型參數</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="generics/phantom/testcase_units.html"><strong aria-hidden="true">14.9.1.</strong> 測試實例：單位檢查</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="scope.html"><strong aria-hidden="true">15.</strong> 作用域規則</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="scope/raii.html"><strong aria-hidden="true">15.1.</strong> RAII</a></li><li class="chapter-item expanded "><a href="scope/move.html"><strong aria-hidden="true">15.2.</strong> 所有權和移動</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="scope/move/mut.html"><strong aria-hidden="true">15.2.1.</strong> 可變性</a></li><li class="chapter-item expanded "><a href="scope/move/partial_move.html"><strong aria-hidden="true">15.2.2.</strong> 部分移動</a></li></ol></li><li class="chapter-item expanded "><a href="scope/borrow.html"><strong aria-hidden="true">15.3.</strong> 借用</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="scope/borrow/mut.html"><strong aria-hidden="true">15.3.1.</strong> 可變性</a></li><li class="chapter-item expanded "><a href="scope/borrow/alias.html"><strong aria-hidden="true">15.3.2.</strong> 別名使用</a></li><li class="chapter-item expanded "><a href="scope/borrow/ref.html"><strong aria-hidden="true">15.3.3.</strong> ref 模式</a></li></ol></li><li class="chapter-item expanded "><a href="scope/lifetime.html"><strong aria-hidden="true">15.4.</strong> 生命週期</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="scope/lifetime/explicit.html"><strong aria-hidden="true">15.4.1.</strong> 顯式標註</a></li><li class="chapter-item expanded "><a href="scope/lifetime/fn.html"><strong aria-hidden="true">15.4.2.</strong> 函數</a></li><li class="chapter-item expanded "><a href="scope/lifetime/methods.html"><strong aria-hidden="true">15.4.3.</strong> 方法</a></li><li class="chapter-item expanded "><a href="scope/lifetime/struct.html"><strong aria-hidden="true">15.4.4.</strong> 結構體</a></li><li class="chapter-item expanded "><a href="scope/lifetime/trait.html"><strong aria-hidden="true">15.4.5.</strong> trait</a></li><li class="chapter-item expanded "><a href="scope/lifetime/lifetime_bounds.html"><strong aria-hidden="true">15.4.6.</strong> 約束</a></li><li class="chapter-item expanded "><a href="scope/lifetime/lifetime_coercion.html"><strong aria-hidden="true">15.4.7.</strong> 強制轉換</a></li><li class="chapter-item expanded "><a href="scope/lifetime/static_lifetime.html"><strong aria-hidden="true">15.4.8.</strong> static</a></li><li class="chapter-item expanded "><a href="scope/lifetime/elision.html"><strong aria-hidden="true">15.4.9.</strong> 省略</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="trait.html"><strong aria-hidden="true">16.</strong> 特質 trait</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="trait/derive.html"><strong aria-hidden="true">16.1.</strong> 派生</a></li><li class="chapter-item expanded "><a href="trait/dyn.html"><strong aria-hidden="true">16.2.</strong> 使用 dyn 返回 trait</a></li><li class="chapter-item expanded "><a href="trait/ops.html"><strong aria-hidden="true">16.3.</strong> 運算符重載</a></li><li class="chapter-item expanded "><a href="trait/drop.html"><strong aria-hidden="true">16.4.</strong> Drop</a></li><li class="chapter-item expanded "><a href="trait/iter.html"><strong aria-hidden="true">16.5.</strong> Iterator</a></li><li class="chapter-item expanded "><a href="trait/impl_trait.html"><strong aria-hidden="true">16.6.</strong> impl Trait</a></li><li class="chapter-item expanded "><a href="trait/clone.html"><strong aria-hidden="true">16.7.</strong> Clone</a></li><li class="chapter-item expanded "><a href="trait/supertraits.html"><strong aria-hidden="true">16.8.</strong> 父 trait</a></li><li class="chapter-item expanded "><a href="trait/disambiguating.html"><strong aria-hidden="true">16.9.</strong> 消除重疊 trait</a></li></ol></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">17.</strong> 使用 macro_rules! 來創建宏</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="macros/syntax.html"><strong aria-hidden="true">17.1.</strong> 語法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="macros/designators.html"><strong aria-hidden="true">17.1.1.</strong> 指示符</a></li><li class="chapter-item expanded "><a href="macros/overload.html"><strong aria-hidden="true">17.1.2.</strong> 重載</a></li><li class="chapter-item expanded "><a href="macros/repeat.html"><strong aria-hidden="true">17.1.3.</strong> 重複</a></li></ol></li><li class="chapter-item expanded "><a href="macros/dry.html"><strong aria-hidden="true">17.2.</strong> DRY (不寫重複代碼)</a></li><li class="chapter-item expanded "><a href="macros/dsl.html"><strong aria-hidden="true">17.3.</strong> DSL (領域專用語言)</a></li><li class="chapter-item expanded "><a href="macros/variadics.html"><strong aria-hidden="true">17.4.</strong> 可變參數接口</a></li></ol></li><li class="chapter-item expanded "><a href="error.html"><strong aria-hidden="true">18.</strong> 錯誤處理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="error/panic.html"><strong aria-hidden="true">18.1.</strong> panic</a></li><li class="chapter-item expanded "><a href="error/option_unwrap.html"><strong aria-hidden="true">18.2.</strong> Option 和 unwrap</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="error/option_unwrap/question_mark.html"><strong aria-hidden="true">18.2.1.</strong> 使用 ? 解開 Option</a></li><li class="chapter-item expanded "><a href="error/option_unwrap/map.html"><strong aria-hidden="true">18.2.2.</strong> 組合算子：map</a></li><li class="chapter-item expanded "><a href="error/option_unwrap/and_then.html"><strong aria-hidden="true">18.2.3.</strong> 組合算子：and_then</a></li></ol></li><li class="chapter-item expanded "><a href="error/result.html"><strong aria-hidden="true">18.3.</strong> 結果 Result</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="error/result/result_map.html"><strong aria-hidden="true">18.3.1.</strong> Result 的 map</a></li><li class="chapter-item expanded "><a href="error/result/result_alias.html"><strong aria-hidden="true">18.3.2.</strong> 給 Result 取別名</a></li><li class="chapter-item expanded "><a href="error/result/early_returns.html"><strong aria-hidden="true">18.3.3.</strong> 提前返回</a></li><li class="chapter-item expanded "><a href="error/result/enter_question_mark.html"><strong aria-hidden="true">18.3.4.</strong> 引入 ?</a></li></ol></li><li class="chapter-item expanded "><a href="error/multiple_error_types.html"><strong aria-hidden="true">18.4.</strong> 處理多種錯誤類型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="error/multiple_error_types/option_result.html"><strong aria-hidden="true">18.4.1.</strong> 從 Option 中取出 Result</a></li><li class="chapter-item expanded "><a href="error/multiple_error_types/define_error_type.html"><strong aria-hidden="true">18.4.2.</strong> 定義一種錯誤類型</a></li><li class="chapter-item expanded "><a href="error/multiple_error_types/boxing_errors.html"><strong aria-hidden="true">18.4.3.</strong> 把錯誤 “裝箱”</a></li><li class="chapter-item expanded "><a href="error/multiple_error_types/reenter_question_mark.html"><strong aria-hidden="true">18.4.4.</strong> ? 的其他用法</a></li><li class="chapter-item expanded "><a href="error/multiple_error_types/wrap_error.html"><strong aria-hidden="true">18.4.5.</strong> 包裹錯誤</a></li></ol></li><li class="chapter-item expanded "><a href="error/iter_result.html"><strong aria-hidden="true">18.5.</strong> 遍歷 Result</a></li></ol></li><li class="chapter-item expanded "><a href="std.html"><strong aria-hidden="true">19.</strong> 標準庫類型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="std/box.html"><strong aria-hidden="true">19.1.</strong> 箱子、棧和堆</a></li><li class="chapter-item expanded "><a href="std/vec.html"><strong aria-hidden="true">19.2.</strong> 動態數組 vector</a></li><li class="chapter-item expanded "><a href="std/str.html"><strong aria-hidden="true">19.3.</strong> 字符串 String</a></li><li class="chapter-item expanded "><a href="std/option.html"><strong aria-hidden="true">19.4.</strong> 選項 Option</a></li><li class="chapter-item expanded "><a href="std/result.html"><strong aria-hidden="true">19.5.</strong> 結果 Result</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="std/result/question_mark.html"><strong aria-hidden="true">19.5.1.</strong> ? 用法</a></li></ol></li><li class="chapter-item expanded "><a href="std/panic.html"><strong aria-hidden="true">19.6.</strong> panic!</a></li><li class="chapter-item expanded "><a href="std/hash.html"><strong aria-hidden="true">19.7.</strong> 散列表 HashMap</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="std/hash/alt_key_types.html"><strong aria-hidden="true">19.7.1.</strong> 更改或自定義關鍵字類型</a></li><li class="chapter-item expanded "><a href="std/hash/hashset.html"><strong aria-hidden="true">19.7.2.</strong> 散列集 HashSet</a></li></ol></li><li class="chapter-item expanded "><a href="std/rc.html"><strong aria-hidden="true">19.8.</strong> 引用計數 Rc</a></li><li class="chapter-item expanded "><a href="std/arc.html"><strong aria-hidden="true">19.9.</strong> 共享引用計數 Arc</a></li></ol></li><li class="chapter-item expanded "><a href="std_misc.html"><strong aria-hidden="true">20.</strong> 標準庫更多介紹</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="std_misc/threads.html"><strong aria-hidden="true">20.1.</strong> 線程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="std_misc/threads/testcase_mapreduce.html"><strong aria-hidden="true">20.1.1.</strong> 測試實例：map-reduce</a></li></ol></li><li class="chapter-item expanded "><a href="std_misc/channels.html"><strong aria-hidden="true">20.2.</strong> 通道</a></li><li class="chapter-item expanded "><a href="std_misc/path.html"><strong aria-hidden="true">20.3.</strong> 路徑</a></li><li class="chapter-item expanded "><a href="std_misc/file.html"><strong aria-hidden="true">20.4.</strong> 文件輸入輸出（I/O）</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="std_misc/file/open.html"><strong aria-hidden="true">20.4.1.</strong> 打開文件 open</a></li><li class="chapter-item expanded "><a href="std_misc/file/create.html"><strong aria-hidden="true">20.4.2.</strong> 創建文件 create</a></li><li class="chapter-item expanded "><a href="std_misc/file/read_lines.html"><strong aria-hidden="true">20.4.3.</strong> 讀取行 read lines</a></li></ol></li><li class="chapter-item expanded "><a href="std_misc/process.html"><strong aria-hidden="true">20.5.</strong> 子進程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="std_misc/process/pipe.html"><strong aria-hidden="true">20.5.1.</strong> 管道</a></li><li class="chapter-item expanded "><a href="std_misc/process/wait.html"><strong aria-hidden="true">20.5.2.</strong> 等待</a></li></ol></li><li class="chapter-item expanded "><a href="std_misc/fs.html"><strong aria-hidden="true">20.6.</strong> 文件系統操作</a></li><li class="chapter-item expanded "><a href="std_misc/arg.html"><strong aria-hidden="true">20.7.</strong> 程序參數</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="std_misc/arg/matching.html"><strong aria-hidden="true">20.7.1.</strong> 參數解析</a></li></ol></li><li class="chapter-item expanded "><a href="std_misc/ffi.html"><strong aria-hidden="true">20.8.</strong> 外部語言函數接口</a></li></ol></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">21.</strong> 測試</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="testing/unit_testing.html"><strong aria-hidden="true">21.1.</strong> 單元測試</a></li><li class="chapter-item expanded "><a href="testing/doc_testing.html"><strong aria-hidden="true">21.2.</strong> 文檔測試</a></li><li class="chapter-item expanded "><a href="testing/integration_testing.html"><strong aria-hidden="true">21.3.</strong> 集成測試</a></li><li class="chapter-item expanded "><a href="testing/dev_dependencies.html"><strong aria-hidden="true">21.4.</strong> 開發依賴</a></li></ol></li><li class="chapter-item expanded "><a href="unsafe.html"><strong aria-hidden="true">22.</strong> 不安全操作</a></li><li class="chapter-item expanded "><a href="compatibility.html"><strong aria-hidden="true">23.</strong> 兼容性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="compatibility/raw_identifiers.html"><strong aria-hidden="true">23.1.</strong> 原始標誌符</a></li></ol></li><li class="chapter-item expanded "><a href="meta.html"><strong aria-hidden="true">24.</strong> 補充</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="meta/doc.html"><strong aria-hidden="true">24.1.</strong> 文檔</a></li><li class="chapter-item expanded "><a href="meta/playpen.html"><strong aria-hidden="true">24.2.</strong> Playpen</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">通过例子学 Rust 中文版</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-cn/rust-by-example-cn" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="通過例子學-rust"><a class="header" href="#通過例子學-rust">通過例子學 Rust</a></h1>
<blockquote>
<p>中文翻譯註（Chinese translation of the <a href="https://doc.rust-lang.org/rust-by-example/">Rust By Example</a>）：</p>
<ul>
<li>👉 查看更多 <a href="https://rustwiki.org/" style="color:#97ca00;font-weight:bold;">Rust 官方文檔中英文雙語教程</a>，包括雙語版<a href="https://rustwiki.org/zh-CN/book/">《Rust 程序設計語言》</a>（出版書名為《Rust 權威指南》），本站還提供了 <a href="https://rustwiki.org/zh-CN/std/">Rust 標準庫中文版</a>。</li>
<li>《通過例子學 Rust》(Rust By Example 中文版)翻譯自 <a href="https://doc.rust-lang.org/rust-by-example/">Rust By Example</a>，中文版最後更新時間：2022-1-26。查看此書的 <a href="https://github.com/rust-lang-cn/rust-by-example-cn">Github 翻譯項目和源碼</a>。</li>
<li><a href="https://rustwiki.org/en/rust-by-example" style="color:red;">本站支持文檔中英文切換</a>，點擊頁面右上角語言圖標可切換到相同章節的英文頁面，<strong>英文版每天都會自動同步一次官方的最新版本</strong>。</li>
<li>若發現本頁表達錯誤或幫助我們改進翻譯，可點擊右上角的編輯按鈕打開本頁對應源碼文件進行編輯和修改，Rust 中文資源的開源組織發展離不開大家，感謝您的支持和幫助！</li>
</ul>
</blockquote>
<p><a href="https://www.rust-lang.org/">Rust</a> 是一門注重安全（safety）、速度（speed）和併發（concurrency）的現代系統編程語言。Rust 通過內存安全來實現以上目標，但不使用垃圾回收機制（garbage collection, GC）。</p>
<p>《通過例子學 Rust》（Rust By Example, RBE）內容由一系列可運行的實例組成，通過這些例子闡明瞭各種 Rust 的概念和基本庫。想獲取這些例子外的更多內容，不要忘了<a href="https://www.rust-lang.org/tools/install">安裝 Rust 到本地</a>並查閱<a href="https://rustwiki.org/zh-CN/std/">官方標準庫文檔</a>。另外為了滿足您的好奇心，您還可以<a href="https://github.com/rust-lang-cn/rust-by-example-cn">查閱本網站的源代碼</a>。</p>
<p>現在讓我們開始學習吧！</p>
<ul>
<li>
<p><a href="hello.html">Hello World</a> - 從經典的 “Hello World” 程序開始學習。</p>
</li>
<li>
<p><a href="primitives.html">原生類型</a> - 學習有符號整型，無符號整型和其他原生類型。</p>
</li>
<li>
<p><a href="custom_types.html">自定義類型</a> - 結構體 <code>struct</code> 和 枚舉 <code>enum</code>。</p>
</li>
<li>
<p><a href="variable_bindings.html">變量綁定</a> - 變量綁定，作用域，變量遮蔽。</p>
</li>
<li>
<p><a href="types.html">類型系統</a> - 學習改變和定義類型。</p>
</li>
<li>
<p><a href="conversion.html">類型轉換</a></p>
</li>
<li>
<p><a href="expression.html">表達式</a></p>
</li>
<li>
<p><a href="flow_control.html">流程控制</a> - <code>if</code>/<code>else</code>，<code>for</code>，以及其他流程控制有關內容。</p>
</li>
<li>
<p><a href="fn.html">函數</a> - 學習方法、閉包和高階函數。</p>
</li>
<li>
<p><a href="mod.html">模塊</a> - 使用模塊來組織代碼。</p>
</li>
<li>
<p><a href="crates.html">Crate</a> - crate 是 Rust 中的編譯單元。學習創建一個庫。</p>
</li>
<li>
<p><a href="cargo.html">Cargo</a> - 學習官方的 Rust 包管理工具的一些基本功能。</p>
</li>
<li>
<p><a href="attribute.html">屬性</a> - 屬性是應用於某些模塊、crate 或項的元數據（metadata）。</p>
</li>
<li>
<p><a href="generics.html">泛型</a> - 學習編寫能夠適用於多種類型參數的函數或數據類型。</p>
</li>
<li>
<p><a href="scope.html">作用域規則</a> - 作用域在所有權（ownership）、借用（borrowing）和生命週期（lifetime）中起著重要作用。</p>
</li>
<li>
<p><a href="trait.html">特性 trait</a> - trait 是對未知類型（<code>Self</code>）定義的方法集。</p>
</li>
<li>
<p><a href="macros.html">宏</a></p>
</li>
<li>
<p><a href="error.html">錯誤處理</a> - 學習 Rust 語言處理失敗的方式。</p>
</li>
<li>
<p><a href="std.html">標準庫類型</a> - 學習 <code>std</code> 標準庫提供的一些自定義類型。</p>
</li>
<li>
<p><a href="std_misc.html">標準庫更多介紹</a> - 更多關於文件處理、線程的自定義類型。</p>
</li>
<li>
<p><a href="testing.html">測試</a> - Rust 語言的各種測試手段。</p>
</li>
<li>
<p><a href="unsafe.html">不安全操作</a></p>
</li>
<li>
<p><a href="compatibility.html">兼容性</a></p>
</li>
<li>
<p><a href="meta.html">補充</a> - 文檔和基準測試</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>這是傳統的 Hello World 程序的源碼。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 這是註釋內容，將會被編譯器忽略掉
// 可以單擊那邊的按鈕 &quot;Run&quot; 來測試這段代碼 -&gt;
// 若想用鍵盤操作，可以使用快捷鍵 &quot;Ctrl + Enter&quot; 來運行

// 這段代碼支持編輯，你可以自由地修改代碼！
// 通過單擊 &quot;Reset&quot; 按鈕可以使代碼恢復到初始狀態 -&gt;

// 這是主函數
fn main() {
    // 調用編譯生成的可執行文件時，這裡的語句將被運行。

    // 將文本打印到控制檯
    println!(&quot;Hello World!&quot;);
}
</code></pre></pre>
<p><code>println!</code> 是一個<a href="macros.html"><strong>宏</strong></a>（macros），可以將文本輸出到控制檯（console）。</p>
<p>使用 Rust 的編譯器 <code>rustc</code> 可以從源程序生成可執行文件：</p>
<pre><code class="language-bash">$ rustc hello.rs
</code></pre>
<p>使用 <code>rustc</code> 編譯後將得到可執行文件 <code>hello</code>。</p>
<pre><code class="language-bash">$ ./hello
Hello World!
</code></pre>
<h3 id="動手試一試"><a class="header" href="#動手試一試">動手試一試</a></h3>
<p>單擊上面的 &quot;Run&quot; 按鈕並觀察輸出結果。然後增加一行代碼，再一次使用宏 <code>println!</code>，得到下面結果：</p>
<pre><code class="language-text">Hello World!
I'm a Rustacean!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="註釋"><a class="header" href="#註釋">註釋</a></h1>
<p>註釋對任何程序都不可缺少，同樣 Rust 支持幾種不同的註釋方式。</p>
<ul>
<li><strong>普通註釋</strong>，其內容將被編譯器忽略掉：
<ul>
<li><code>// 單行註釋，註釋內容直到行尾。</code></li>
<li><code>/* 塊註釋，註釋內容一直到結束分隔符。 */</code></li>
</ul>
</li>
<li><strong>文檔註釋</strong>，其內容將被解析成 HTML 幫助<a href="hello/../meta/doc.html">文檔</a>：
<ul>
<li><code>/// 為接下來的項生成幫助文檔。</code></li>
<li><code>//! 為註釋所屬於的項（譯註：如 crate、模塊或函數）生成幫助文檔。</code></li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // 這是行註釋的例子
    // 注意有兩個斜線在本行的開頭
    // 在這裡面的所有內容都不會被編譯器讀取

    // println!(&quot;Hello, world!&quot;);

    // 請運行一下，你看到結果了嗎？現在請將上述語句的兩條斜線刪掉，並重新運行。

    /*
     * 這是另外一種註釋——塊註釋。一般而言，行註釋是推薦的註釋格式，
     * 不過塊註釋在臨時註釋大塊代碼特別有用。/* 塊註釋可以 /* 嵌套, */ */
     * 所以只需很少按鍵就可註釋掉這些 main() 函數中的行。/*/*/* 自己試試！*/*/*/
     */

    /*
    注意，上面的例子中縱向都有 `*`，這只是一種風格，實際上這並不是必須的。
    */

    // 觀察塊註釋是如何簡單地對錶達式進行修改的，行註釋則不能這樣。
    // 刪除註釋分隔符將會改變結果。
    let x = 5 + /* 90 + */ 5;
    println!(&quot;Is `x` 10 or 100? x = {}&quot;, x);
}
</code></pre></pre>
<h3 id="參見"><a class="header" href="#參見">參見:</a></h3>
<p><a href="hello/../meta/doc.html">文檔註釋</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="格式化輸出"><a class="header" href="#格式化輸出">格式化輸出</a></h1>
<p>打印操作由 <a href="https://rustwiki.org/zh-CN/std/fmt/"><code>std::fmt</code></a> 裡面所定義的一系列<a href="hello/../macros.html">宏</a>來處理，包括：</p>
<ul>
<li><code>format!</code>：將格式化文本寫到<a href="hello/../std/str.html">字符串</a>。</li>
<li><code>print!</code>：與 <code>format!</code> 類似，但將文本輸出到控制檯（io::stdout）。</li>
<li><code>println!</code>: 與 <code>print!</code> 類似，但輸出結果追加一個換行符。</li>
<li><code>eprint!</code>：與 <code>print!</code> 類似，但將文本輸出到標準錯誤（io::stderr）。</li>
<li><code>eprintln!</code>：與 <code>eprint!</code> 類似，但輸出結果追加一個換行符。</li>
</ul>
<p>這些宏都以相同的做法解析文本。有個額外優點是格式化的正確性會在編譯時檢查。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">fn main() {
    // 通常情況下，`{}` 會被任意變量內容所替換。
    // 變量內容會轉化成字符串。
    println!(&quot;{} days&quot;, 31);

    // 不加後綴的話，31 就自動成為 i32 類型。
    // 你可以添加後綴來改變 31 的類型（例如使用 31i64 聲明 31 為 i64 類型）。

    // 用變量替換字符串有多種寫法。
    // 比如可以使用位置參數。
    println!(&quot;{0}, this is {1}. {1}, this is {0}&quot;, &quot;Alice&quot;, &quot;Bob&quot;);

    // 可以使用命名參數。
    println!(&quot;{subject} {verb} {object}&quot;,
             object=&quot;the lazy dog&quot;,
             subject=&quot;the quick brown fox&quot;,
             verb=&quot;jumps over&quot;);

    // 可以在 `:` 後面指定特殊的格式。
    println!(&quot;{} of {:b} people know binary, the other half don't&quot;, 1, 2);

    // 你可以按指定寬度來右對齊文本。
    // 下面語句輸出 &quot;     1&quot;，5 個空格後面連著 1。
    println!(&quot;{number:&gt;width$}&quot;, number=1, width=6);

    // 你可以在數字左邊補 0。下面語句輸出 &quot;000001&quot;。
    println!(&quot;{number:&gt;0width$}&quot;, number=1, width=6);

    // println! 會檢查使用到的參數數量是否正確。
    println!(&quot;My name is {0}, {1} {0}&quot;, &quot;Bond&quot;);
    // 改正 ^ 補上漏掉的參數：&quot;James&quot;

    // 創建一個包含單個 `i32` 的結構體（structure）。命名為 `Structure`。
    #[allow(dead_code)]
    struct Structure(i32);

    // 但是像結構體這樣的自定義類型需要更復雜的方式來處理。
    // 下面語句無法運行。
    println!(&quot;This struct `{}` won't print...&quot;, Structure(3));
    // 改正 ^ 註釋掉此行。
}
</code></pre></pre>
<p><a href="https://rustwiki.org/zh-CN/std/fmt/"><code>std::fmt</code></a> 包含多種 <a href="hello/../trait.html"><code>trait</code></a>（特質）來控制文字顯示，其中重要的兩種 trait 的基本形式如下：</p>
<ul>
<li><code>fmt::Debug</code>：使用 <code>{:?}</code> 標記。格式化文本以供調試使用。</li>
<li><code>fmt::Display</code>：使用 <code>{}</code> 標記。以更優雅和友好的風格來格式化文本。</li>
</ul>
<p>上例使用了 <code>fmt::Display</code>，因為標準庫提供了那些類型的實現。若要打印自定義類型的文本，需要更多的步驟。</p>
<h3 id="動手試一試-1"><a class="header" href="#動手試一試-1">動手試一試</a></h3>
<ul>
<li>改正上面代碼中的兩個錯誤（見 “改正”），使它可以沒有錯誤地運行。</li>
<li>再用一個 <code>println!</code> 宏，通過控制顯示的小數位數來打印：<code>Pi is roughly 3.142</code>（Pi 約等於 3.142）。為了達到練習目的，使用 <code>let pi = 3.141592</code> 作為 Pi 的近似值（提示：設置小數位的顯示格式可以參考文檔 <a href="https://rustwiki.org/zh-CN/std/fmt/"><code>std::fmt</code></a>）。</li>
</ul>
<h3 id="參見-1"><a class="header" href="#參見-1">參見：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/fmt/"><code>std::fmt</code></a>, <a href="hello/../macros.html"><code>macros</code></a>, <a href="hello/../custom_types/structs.html"><code>struct</code></a> 和 <a href="hello/../trait.html"><code>trait</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="調試debug"><a class="header" href="#調試debug">調試（Debug）</a></h1>
<p>所有的類型，若想用 <code>std::fmt</code> 的格式化打印，都要求實現至少一個可打印的 <code>traits</code>。
自動的實現只為一些類型提供，比如 <code>std</code> 庫中的類型。所有其他類型
都<strong>必須</strong>手動實現。</p>
<p><code>fmt::Debug</code> 這個 <code>trait</code> 使這項工作變得相當簡單。所有類型都能推導（<code>derive</code>，即自
動創建）<code>fmt::Debug</code> 的實現。但是 <code>fmt::Display</code> 需要手動實現。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 這個結構體不能使用 `fmt::Display` 或 `fmt::Debug` 來進行打印。
struct UnPrintable(i32);

// `derive` 屬性會自動創建所需的實現，使這個 `struct` 能使用 `fmt::Debug` 打印。
#[derive(Debug)]
struct DebugPrintable(i32);
<span class="boring">}
</span></code></pre></pre>
<p>所有 <code>std</code> 庫類型都天生可以使用 <code>{:?}</code> 來打印：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 推導 `Structure` 的 `fmt::Debug` 實現。
// `Structure` 是一個包含單個 `i32` 的結構體。
#[derive(Debug)]
struct Structure(i32);

// 將 `Structure` 放到結構體 `Deep` 中。然後使 `Deep` 也能夠打印。
#[derive(Debug)]
struct Deep(Structure);

fn main() {
    // 使用 `{:?}` 打印和使用 `{}` 類似。
    println!(&quot;{:?} months in a year.&quot;, 12);
    println!(&quot;{1:?} {0:?} is the {actor:?} name.&quot;,
             &quot;Slater&quot;,
             &quot;Christian&quot;,
             actor=&quot;actor's&quot;);

    // `Structure` 也可以打印！
    println!(&quot;Now {:?} will print!&quot;, Structure(3));
    
    // 使用 `derive` 的一個問題是不能控制輸出的形式。
    // 假如我只想展示一個 `7` 怎麼辦？
    println!(&quot;Now {:?} will print!&quot;, Deep(Structure(7)));
}
</code></pre></pre>
<p>所以 <code>fmt::Debug</code> 確實使這些內容可以打印，但是犧牲了一些美感。Rust 也通過
<code>{:#?}</code> 提供了 “美化打印” 的功能：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Person&lt;'a&gt; {
    name: &amp;'a str,
    age: u8
}

fn main() {
    let name = &quot;Peter&quot;;
    let age = 27;
    let peter = Person { name, age };

    // 美化打印
    println!(&quot;{:#?}&quot;, peter);
}
</code></pre></pre>
<p>你可以通過手動實現 <code>fmt::Display</code> 來控制顯示效果。</p>
<h3 id="參見-2"><a class="header" href="#參見-2">參見：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/reference/attributes.html">attributes</a>, <a href="hello/print/../../trait/derive.html"><code>derive</code></a>, <a href="https://rustwiki.org/zh-CN/std/fmt/"><code>std::fmt</code></a> 和 <a href="hello/print/../../custom_types/structs.html"><code>struct</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="顯示display"><a class="header" href="#顯示display">顯示（Display）</a></h1>
<p><code>fmt::Debug</code> 通常看起來不太簡潔，因此自定義輸出的外觀經常是更可取的。這需要通過
手動實現 <a href="https://rustwiki.org/zh-CN/std/fmt/"><code>fmt::Display</code></a> 來做到。<code>fmt::Display</code> 採用 <code>{}</code> 標記。實現方式看
起來像這樣：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// （使用 `use`）導入 `fmt` 模塊使 `fmt::Display` 可用
use std::fmt;

// 定義一個結構體，咱們會為它實現 `fmt::Display`。以下是個簡單的元組結構體
// `Structure`，包含一個 `i32` 元素。
struct Structure(i32);

// 為了使用 `{}` 標記，必須手動為類型實現 `fmt::Display` trait。
impl fmt::Display for Structure {
    // 這個 trait 要求 `fmt` 使用與下面的函數完全一致的函數簽名
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // 僅將 self 的第一個元素寫入到給定的輸出流 `f`。返回 `fmt:Result`，此
        // 結果表明操作成功或失敗。注意 `write!` 的用法和 `println!` 很相似。
        write!(f, &quot;{}&quot;, self.0)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>fmt::Display</code> 的效果可能比 <code>fmt::Debug</code> 簡潔，但對於 <code>std</code> 庫來說，這就有一個問
題。模稜兩可的類型該如何顯示呢？舉個例子，假設標準庫對所有的 <code>Vec&lt;T&gt;</code> 都實現了同
一種輸出樣式，那麼它應該是哪種樣式？下面兩種中的一種嗎？</p>
<ul>
<li><code>Vec&lt;path&gt;</code>：<code>/:/etc:/home/username:/bin</code>（使用 <code>:</code> 分割）</li>
<li><code>Vec&lt;number&gt;</code>：<code>1,2,3</code>（使用 <code>,</code> 分割）</li>
</ul>
<p>我們沒有這樣做，因為沒有一種合適的樣式適用於所有類型，標準庫也並不擅自規定一種樣
式。對於 <code>Vec&lt;T&gt;</code> 或其他任意泛型容器（generic container），<code>fmt::Display</code> 都沒有
實現。因此在這些泛型的情況下要用 <code>fmt::Debug</code>。</p>
<p>這並不是一個問題，因為對於任何<strong>非</strong>泛型的<strong>容器</strong>類型， <code>fmt::Display</code> 都能夠實
現。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt; // 導入 `fmt`

// 帶有兩個數字的結構體。推導出 `Debug`，以便與 `Display` 的輸出進行比較。
#[derive(Debug)]
struct MinMax(i64, i64);

// 實現 `MinMax` 的 `Display`。
impl fmt::Display for MinMax {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // 使用 `self.number` 來表示各個數據。
        write!(f, &quot;({}, {})&quot;, self.0, self.1)
    }
}

// 為了比較，定義一個含有具名字段的結構體。
#[derive(Debug)]
struct Point2D {
    x: f64,
    y: f64,
}

// 類似地對 `Point2D` 實現 `Display`
impl fmt::Display for Point2D {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // 自定義格式，使得僅顯示 `x` 和 `y` 的值。
        write!(f, &quot;x: {}, y: {}&quot;, self.x, self.y)
    }
}

fn main() {
    let minmax = MinMax(0, 14);

    println!(&quot;Compare structures:&quot;);
    println!(&quot;Display: {}&quot;, minmax);
    println!(&quot;Debug: {:?}&quot;, minmax);

    let big_range =   MinMax(-300, 300);
    let small_range = MinMax(-3, 3);

    println!(&quot;The big range is {big} and the small is {small}&quot;,
             small = small_range,
             big = big_range);

    let point = Point2D { x: 3.3, y: 7.2 };

    println!(&quot;Compare points:&quot;);
    println!(&quot;Display: {}&quot;, point);
    println!(&quot;Debug: {:?}&quot;, point);

    // 報錯。`Debug` 和 `Display` 都被實現了，但 `{:b}` 需要 `fmt::Binary`
    // 得到實現。這語句不能運行。
    // println!(&quot;What does Point2D look like in binary: {:b}?&quot;, point);
}
</code></pre></pre>
<p><code>fmt::Display</code> 被實現了，而 <code>fmt::Binary</code> 沒有，因此 <code>fmt::Binary</code> 不能使用。
<code>std::fmt</code> 有很多這樣的 <a href="hello/print/../../trait.html"><code>trait</code></a>，它們都要求有各自的實現。這些內容將在
後面的 <a href="https://rustwiki.org/zh-CN/std/fmt/"><code>std::fmt</code></a> 章節中詳細介紹。</p>
<h3 id="動手試一試-2"><a class="header" href="#動手試一試-2">動手試一試</a></h3>
<p>檢驗上面例子的輸出，然後在示例程序中，仿照 <code>Point2D</code> 結構體增加一個複數結構體。
使用一樣的方式打印，輸出結果要求是這個樣子：</p>
<pre><code class="language-txt">Display: 3.3 + 7.2i
Debug: Complex { real: 3.3, imag: 7.2 }
</code></pre>
<h3 id="參見-3"><a class="header" href="#參見-3">參見：</a></h3>
<p><a href="hello/print/../../trait/derive.html"><code>derive</code></a>, <a href="https://rustwiki.org/zh-CN/std/fmt/"><code>std::fmt</code></a>, <a href="hello/print/../../macros.html">macros</a>, <a href="hello/print/../../custom_types/structs.html"><code>struct</code></a>,
<a href="hello/print/../../trait.html"><code>trait</code></a>, 和 <a href="hello/print/../../mod/use.html">use</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="測試實例list"><a class="header" href="#測試實例list">測試實例：List</a></h1>
<p>對一個結構體實現 <code>fmt::Display</code>，其中的元素需要一個接一個地處理到，這可能會很麻
煩。問題在於每個 <code>write!</code> 都要生成一個 <code>fmt::Result</code>。正確的實現需要
處理<strong>所有</strong>的 Result。Rust 專門為解決這個問題提供了 <code>?</code> 操作符。</p>
<p>在 <code>write!</code> 上使用 <code>?</code> 會像是這樣：</p>
<pre><code class="language-rust ignore">// 對 `write!` 進行嘗試（try），觀察是否出錯。若發生錯誤，返回相應的錯誤。
// 否則（沒有出錯）繼續執行後面的語句。
write!(f, &quot;{}&quot;, value)?;
</code></pre>
<p>另外，你也可以使用 <code>try!</code> 宏，它和 <code>?</code> 是一樣的。這種寫法比較羅嗦，故不再推薦，
但在老一些的 Rust 代碼中仍會看到。使用 <code>try!</code> 看起來像這樣：</p>
<pre><code class="language-rust ignore">try!(write!(f, &quot;{}&quot;, value));
</code></pre>
<p>有了 <code>?</code>，對一個 <code>Vec</code> 實現 <code>fmt::Display</code> 就很簡單了：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt; // 導入 `fmt` 模塊。

// 定義一個包含單個 `Vec` 的結構體 `List`。
struct List(Vec&lt;i32&gt;);

impl fmt::Display for List {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // 使用元組的下標獲取值，並創建一個 `vec` 的引用。
        let vec = &amp;self.0;

        write!(f, &quot;[&quot;)?;

        // 使用 `v` 對 `vec` 進行迭代，並用 `count` 記錄迭代次數。
        for (count, v) in vec.iter().enumerate() {
            // 對每個元素（第一個元素除外）加上逗號。
            // 使用 `?` 或 `try!` 來返回錯誤。
            if count != 0 { write!(f, &quot;, &quot;)?; }
            write!(f, &quot;{}&quot;, v)?;
        }

        // 加上配對中括號，並返回一個 fmt::Result 值。
        write!(f, &quot;]&quot;)
    }
}

fn main() {
    let v = List(vec![1, 2, 3]);
    println!(&quot;{}&quot;, v);
}
</code></pre></pre>
<h3 id="動手試一試-3"><a class="header" href="#動手試一試-3">動手試一試：</a></h3>
<p>更改程序使 vector 裡面每個元素的下標也能夠打印出來。新的結果如下：</p>
<pre><code class="language-rust ignore">[0: 1, 1: 2, 2: 3]
</code></pre>
<h3 id="參見-4"><a class="header" href="#參見-4">參見：</a></h3>
<p><a href="hello/print/print_display/../../../flow_control/for.html"><code>for</code></a>, <a href="hello/print/print_display/../../../scope/borrow/ref.html"><code>ref</code></a>, <a href="hello/print/print_display/../../../std/result.html"><code>Result</code></a>, <a href="hello/print/print_display/../../../custom_types/structs.html"><code>struct</code></a>,
<a href="hello/print/print_display/../../../std/result/question_mark.html"><code>?</code></a>, 和 <a href="hello/print/print_display/../../../std/vec.html"><code>vec!</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="格式化"><a class="header" href="#格式化">格式化</a></h1>
<p>我們已經看到，格式化的方式是通過<strong>格式字符串</strong>來指定的：</p>
<ul>
<li><code>format!(&quot;{}&quot;, foo)</code> -&gt; <code>&quot;3735928559&quot;</code></li>
<li><code>format!(&quot;0x{:X}&quot;, foo)</code> -&gt;
<a href="https://en.wikipedia.org/wiki/Deadbeef#Magic_debug_values"><code>&quot;0xDEADBEEF&quot;</code></a></li>
<li><code>format!(&quot;0o{:o}&quot;, foo)</code> -&gt; <code>&quot;0o33653337357&quot;</code></li>
</ul>
<p>根據使用的<strong>參數類型</strong>是 <code>X</code>、<code>o</code> 還是<strong>未指定</strong>，同樣的變量（<code>foo</code>）能夠格式化
成不同的形式。</p>
<p>這個格式化的功能是通過 trait 實現的，每種參數類型都對應一種 trait。最常見的格式
化 trait 就是 <code>Display</code>，它可以處理參數類型為未指定的情況，比如 <code>{}</code>。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt::{self, Formatter, Display};

struct City {
    name: &amp;'static str,
    // 緯度
    lat: f32,
    // 經度
    lon: f32,
}

impl Display for City {
    // `f` 是一個緩衝區（buffer），此方法必須將格式化後的字符串寫入其中
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        let lat_c = if self.lat &gt;= 0.0 { 'N' } else { 'S' };
        let lon_c = if self.lon &gt;= 0.0 { 'E' } else { 'W' };

        // `write!` 和 `format!` 類似，但它會將格式化後的字符串寫入
        // 一個緩衝區（即第一個參數f）中。
        write!(f, &quot;{}: {:.3}°{} {:.3}°{}&quot;,
               self.name, self.lat.abs(), lat_c, self.lon.abs(), lon_c)
    }
}

#[derive(Debug)]
struct Color {
    red: u8,
    green: u8,
    blue: u8,
}

fn main() {
    for city in [
        City { name: &quot;Dublin&quot;, lat: 53.347778, lon: -6.259722 },
        City { name: &quot;Oslo&quot;, lat: 59.95, lon: 10.75 },
        City { name: &quot;Vancouver&quot;, lat: 49.25, lon: -123.1 },
    ].iter() {
        println!(&quot;{}&quot;, *city);
    }
    for color in [
        Color { red: 128, green: 255, blue: 90 },
        Color { red: 0, green: 3, blue: 254 },
        Color { red: 0, green: 0, blue: 0 },
    ].iter() {
        // 在添加了針對 fmt::Display 的實現後，請改用 {} 檢驗效果。
        println!(&quot;{:?}&quot;, *color)
    }
}
</code></pre></pre>
<p>在 <a href="https://rustwiki.org/zh-CN/std/fmt/"><code>fmt::fmt</code></a> 文檔中可以查看<a href="https://rustwiki.org/zh-CN/std/fmt/#formatting-traits">格式化 traits 一覽表</a>和它們的參
數類型。</p>
<h3 id="動手試一試-4"><a class="header" href="#動手試一試-4">動手試一試</a></h3>
<p>為上面的 <code>Color</code> 結構體實現 <code>fmt::Display</code>，應得到如下的輸出結果：</p>
<pre><code class="language-text">RGB (128, 255, 90) 0x80FF5A
RGB (0, 3, 254) 0x0003FE
RGB (0, 0, 0) 0x000000
</code></pre>
<p>如果感到疑惑，可看下面兩條提示：</p>
<ul>
<li>你<a href="https://rustwiki.org/zh-CN/std/fmt/#argument-types">可能需要多次列出每個顏色</a>，</li>
<li>你可以使用 <code>:02</code> <a href="https://rustwiki.org/zh-CN/std/fmt/#width">補零使位數為 2 位</a>。</li>
</ul>
<h3 id="參見-5"><a class="header" href="#參見-5">參見：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/fmt/"><code>std::fmt</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="原生類型"><a class="header" href="#原生類型">原生類型</a></h1>
<p>Rust 提供了多種原生類型（<code>primitives</code>），包括：</p>
<h2 id="標量類型scalar-type"><a class="header" href="#標量類型scalar-type">標量類型（scalar type）</a></h2>
<ul>
<li>有符號整數（signed integers）：<code>i8</code>、<code>i16</code>、<code>i32</code>、<code>i64</code>、<code>i128</code> 和 <code>isize</code>（指針寬度）</li>
<li>無符號整數（unsigned integers）： <code>u8</code>、<code>u16</code>、<code>u32</code>、<code>u64</code>、<code>u128</code> 和 <code>usize</code>（指針寬度）</li>
<li>浮點數（floating point）： <code>f32</code>、<code>f64</code></li>
<li><code>char</code>（字符）：單個 Unicode 字符，如 <code>'a'</code>，<code>'α'</code> 和 <code>'∞'</code>（每個都是 4 字節）</li>
<li><code>bool</code>（布爾型）：只能是 <code>true</code> 或 <code>false</code></li>
<li>單元類型（unit type）：<code>()</code>。其唯一可能的值就是 <code>()</code> 這個空元組</li>
</ul>
<p>儘管單元類型的值是個元組，它卻並不被認為是複合類型，因為並不包含多個值。</p>
<h2 id="複合類型compound-type"><a class="header" href="#複合類型compound-type">複合類型（compound type）</a></h2>
<ul>
<li>數組（array）：如 <code>[1, 2, 3]</code></li>
<li>元組（tuple）：如 <code>(1, true)</code></li>
</ul>
<p>變量都能夠顯式地給出<strong>類型說明</strong>（type annotation）。數字還可以通過<strong>後綴</strong>（suffix）或<strong>默認方式</strong>來聲明類型。整型默認為 <code>i32</code> 類型，浮點型默認為 <code>f64</code>類型。注意 Rust 還可以根據上下文來推斷（infer）類型（譯註：比如一個未聲明類型整數和 <code>i64</code> 的整數相加，則該整數會自動推斷為 <code>i64</code> 類型。僅當根據環境無法推斷時，才按默認方式取整型數值為 <code>i32</code>，浮點數值為 <code>f64</code>）。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">fn main() {
    // 變量可以給出類型說明。
    let logical: bool = true;

    let a_float: f64 = 1.0;  // 常規說明
    let an_integer   = 5i32; // 後綴說明

    // 否則會按默認方式決定類型。
    let default_float   = 3.0; // `f64`
    let default_integer = 7;   // `i32`

    // 類型也可根據上下文自動推斷。
    let mut inferred_type = 12; // 根據下一行的賦值推斷為 i64 類型
    inferred_type = 4294967296i64;

    // 可變的（mutable）變量，其值可以改變。
    let mut mutable = 12; // Mutable `i32`
    mutable = 21;

    // 報錯！變量的類型並不能改變。
    mutable = true;

    // 但可以用遮蔽（shadow）來覆蓋前面的變量。
    let mutable = true;
}
</code></pre></pre>
<h3 id="參見-6"><a class="header" href="#參見-6">參見：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/"><code>std</code> 庫</a>、<a href="variable_bindings/mut.html"><code>mut</code></a>、<a href="types/inference.html">類型推斷</a> 和 <a href="variable_bindings/scope.html">變量遮蔽</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字面量和運算符"><a class="header" href="#字面量和運算符">字面量和運算符</a></h1>
<p>整數 <code>1</code>、浮點數 <code>1.2</code>、字符 <code>'a'</code>、字符串 <code>&quot;abc&quot;</code>、布爾值 <code>true</code> 和單元類型 <code>()</code> 可以用數字、文字或符號之類的 “字面量”（literal）來表示。</p>
<p>另外，通過加前綴 <code>0x</code>、<code>0o</code>、<code>0b</code>，數字可以用十六進制、八進制或二進制記法表示。</p>
<p>為了改善可讀性，可以在數值字面量中插入下劃線，比如：<code>1_000</code> 等同於 <code>1000</code>，<code>0.000_001</code> 等同於 <code>0.000001</code>。</p>
<p>我們需要把字面量的類型告訴編譯器。如前面學過的，我們使用 <code>u32</code> 後綴來表明字面量是一個 32 位無符號整數，<code>i32</code> 後綴表明字面量是一個 32 位有符號整數。</p>
<p><a href="https://rustwiki.org/zh-CN/reference/expressions.html#%E8%A1%A8%E9%81%94%E5%BC%8F%E7%9A%84%E5%84%AA%E5%85%88%E7%B4%9A">Rust</a> 提供了一系列的運算符（operator），它們的優先級和<a href="https://en.wikipedia.org/wiki/Operator_precedence#Programming_languages">類 C 語言</a>類似。（譯註：類 C 語言包括 C/C++、Java、PHP 等語言）</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // 整數相加
    println!(&quot;1 + 2 = {}&quot;, 1u32 + 2);

    // 整數相減
    println!(&quot;1 - 2 = {}&quot;, 1i32 - 2);
    // 試一試 ^ 嘗試將 `1i32` 改為 `1u32`，體會為什麼類型聲明這麼重要

    // 短路求值的布爾邏輯
    println!(&quot;true AND false is {}&quot;, true &amp;&amp; false);
    println!(&quot;true OR false is {}&quot;, true || false);
    println!(&quot;NOT true is {}&quot;, !true);

    // 位運算
    println!(&quot;0011 AND 0101 is {:04b}&quot;, 0b0011u32 &amp; 0b0101);
    println!(&quot;0011 OR 0101 is {:04b}&quot;, 0b0011u32 | 0b0101);
    println!(&quot;0011 XOR 0101 is {:04b}&quot;, 0b0011u32 ^ 0b0101);
    println!(&quot;1 &lt;&lt; 5 is {}&quot;, 1u32 &lt;&lt; 5);
    println!(&quot;0x80 &gt;&gt; 2 is 0x{:x}&quot;, 0x80u32 &gt;&gt; 2);

    // 使用下劃線改善數字的可讀性！
    println!(&quot;One million is written as {}&quot;, 1_000_000u32);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="元組"><a class="header" href="#元組">元組</a></h1>
<p>元組是一個可以包含各種類型值的組合。元組使用括號 <code>()</code> 來構造（construct），而每個元組自身又是一個類型標記為 <code>(T1, T2, ...)</code> 的值，其中 <code>T1</code>、<code>T2</code> 是每個元素的類型。函數可以使用元組來返回多個值，因為元組可以擁有任意多個值。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 元組可以充當函數的參數和返回值
fn reverse(pair: (i32, bool)) -&gt; (bool, i32) {
    // 可以使用 `let` 把一個元組的成員綁定到一些變量
    let (integer, boolean) = pair;

    (boolean, integer)
}

// 在 “動手試一試” 的練習中要用到下面這個結構體。
#[derive(Debug)]
struct Matrix(f32, f32, f32, f32);

fn main() {
    // 包含各種不同類型的元組
    let long_tuple = (1u8, 2u16, 3u32, 4u64,
                      -1i8, -2i16, -3i32, -4i64,
                      0.1f32, 0.2f64,
                      'a', true);

    // 通過元組的下標來訪問具體的值
    println!(&quot;long tuple first value: {}&quot;, long_tuple.0);
    println!(&quot;long tuple second value: {}&quot;, long_tuple.1);

    // 元組也可以充當元組的元素
    let tuple_of_tuples = ((1u8, 2u16, 2u32), (4u64, -1i8), -2i16);

    // 元組可以打印
    println!(&quot;tuple of tuples: {:?}&quot;, tuple_of_tuples);

    // 但很長的元組無法打印
    // let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);
    // println!(&quot;too long tuple: {:?}&quot;, too_long_tuple);
    // 試一試 ^ 取消上面兩行的註釋，閱讀編譯器給出的錯誤信息。

    let pair = (1, true);
    println!(&quot;pair is {:?}&quot;, pair);

    println!(&quot;the reversed pair is {:?}&quot;, reverse(pair));

    // 創建單元素元組需要一個額外的逗號，這是為了和被括號包含的字面量作區分。
    println!(&quot;one element tuple: {:?}&quot;, (5u32,));
    println!(&quot;just an integer: {:?}&quot;, (5u32));

    // 元組可以被解構（deconstruct），從而將值綁定給變量
    let tuple = (1, &quot;hello&quot;, 4.5, true);

    let (a, b, c, d) = tuple;
    println!(&quot;{:?}, {:?}, {:?}, {:?}&quot;, a, b, c, d);

    let matrix = Matrix(1.1, 1.2, 2.1, 2.2);
    println!(&quot;{:?}&quot;, matrix)

}
</code></pre></pre>
<h3 id="動手試一試-5"><a class="header" href="#動手試一試-5">動手試一試</a></h3>
<ol>
<li>
<p><strong>複習</strong>：在上面的例子中給 Matrix <code>結構體</code> 加上 <code>fmt::Display</code> trait，這樣當你從 Debug 格式化 <code>{:?}</code> 切換到 Display 格式化 <code>{}</code> 時，會得到如下的輸出：</p>
<pre><code class="language-text">( 1.1 1.2 )
( 2.1 2.2 )
</code></pre>
<p>可以回顧之前學過的<a href="primitives/../hello/print/print_display.html">顯示（display）</a>的例子。</p>
</li>
<li>
<p>以 <code>reverse</code> 函數作為樣板，寫一個 <code>transpose</code> 函數，它可以接受一個 Matrix 作為參數，並返回一個右上 - 左下對角線上的兩元素交換後的 Matrix。舉個例子：</p>
<pre><code class="language-rust ignore">println!(&quot;Matrix:\n{}&quot;, matrix);
println!(&quot;Transpose:\n{}&quot;, transpose(matrix));
</code></pre>
<p>輸出結果：</p>
<pre><code class="language-text">Matrix:
( 1.1 1.2 )
( 2.1 2.2 )
Transpose:
( 1.1 2.1 )
( 1.2 2.2 )
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="數組和切片"><a class="header" href="#數組和切片">數組和切片</a></h1>
<p>數組（array）是一組擁有相同類型 <code>T</code> 的對象的集合，在內存中是連續存儲的。數組使用中括號 <code>[]</code> 來創建，且它們的大小在編譯時會被確定。數組的類型標記為 <code>[T; length]</code>（譯註：<code>T</code> 為元素類型，<code>length</code> 表示數組大小）。</p>
<p>切片（slice）類型和數組類似，但其大小在編譯時是不確定的。相反，切片是一個雙字對象（two-word object），第一個字是一個指向數據的指針，第二個字是切片的長度。這個 “字” 的寬度和 usize 相同，由處理器架構決定，比如在 x86-64 平臺上就是 64 位。slice 可以用來借用數組的一部分。slice 的類型標記為 <code>&amp;[T]</code>。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">use std::mem;

// 此函數借用一個 slice
fn analyze_slice(slice: &amp;[i32]) {
    println!(&quot;first element of the slice: {}&quot;, slice[0]);
    println!(&quot;the slice has {} elements&quot;, slice.len());
}

fn main() {
    // 定長數組（類型標記是多餘的）
    let xs: [i32; 5] = [1, 2, 3, 4, 5];

    // 所有元素可以初始化成相同的值
    let ys: [i32; 500] = [0; 500];

    // 下標從 0 開始
    println!(&quot;first element of the array: {}&quot;, xs[0]);
    println!(&quot;second element of the array: {}&quot;, xs[1]);

    // `len` 返回數組的大小
    println!(&quot;array size: {}&quot;, xs.len());

    // 數組是在棧中分配的
    println!(&quot;array occupies {} bytes&quot;, mem::size_of_val(&amp;xs));

    // 數組可以自動被借用成為 slice
    println!(&quot;borrow the whole array as a slice&quot;);
    analyze_slice(&amp;xs);

    // slice 可以指向數組的一部分
    println!(&quot;borrow a section of the array as a slice&quot;);
    analyze_slice(&amp;ys[1 .. 4]);

    // 越界的下標會引發致命錯誤（panic）
    println!(&quot;{}&quot;, xs[5]);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自定義類型"><a class="header" href="#自定義類型">自定義類型</a></h1>
<p>Rust 自定義數據類型主要是通過下面這兩個關鍵字來創建：</p>
<ul>
<li><code>struct</code>： 定義一個結構體（structure）</li>
<li><code>enum</code>： 定義一個枚舉類型（enumeration）</li>
</ul>
<p>而常量（constant）可以通過 <code>const</code> 和 <code>static</code> 關鍵字來創建。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="結構體"><a class="header" href="#結構體">結構體</a></h1>
<p>結構體（structure，縮寫成 struct）有 3 種類型，使用 <code>struct</code> 關鍵字來創建：</p>
<ul>
<li>元組結構體（tuple struct），事實上就是具名元組而已。</li>
<li>經典的 <a href="https://en.wikipedia.org/wiki/Struct_(C_programming_language)">C 語言風格結構體</a>（C struct）。</li>
<li>單元結構體（unit struct），不帶字段，在泛型中很有用。</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

// 單元結構體
struct Unit;

// 元組結構體
struct Pair(i32, f32);

// 帶有兩個字段的結構體
struct Point {
    x: f32,
    y: f32,
}

// 結構體可以作為另一個結構體的字段
#[allow(dead_code)]
struct Rectangle {
    // 可以在空間中給定左上角和右下角在空間中的位置來指定矩形。
    top_left: Point,
    bottom_right: Point,
}

fn main() {
    // 使用簡單的寫法初始化字段，並創建結構體
    let name = String::from(&quot;Peter&quot;);
    let age = 27;
    let peter = Person { name, age };

    // 以 Debug 方式打印結構體
    println!(&quot;{:?}&quot;, peter);

    // 實例化結構體 `Point`
    let point: Point = Point { x: 10.3, y: 0.4 };

    // 訪問 point 的字段
    println!(&quot;point coordinates: ({}, {})&quot;, point.x, point.y);

    // 使用結構體更新語法創建新的 point，
    // 這樣可以用到之前的 point 的字段
    let bottom_right = Point { x: 5.2, ..point };

    // `new_point.y` 與 `point.y` 一樣，因為這個字段就是從 `point` 中來的
    println!(&quot;second point: ({}, {})&quot;, bottom_right.x, bottom_right.y);

    // 使用 `let` 綁定來解構 point
    let Point { x: left_edge, y: top_edge } = point;

    let _rectangle = Rectangle {
        // 結構體的實例化也是一個表達式
        top_left: Point { x: left_edge, y: top_edge },
        bottom_right: bottom_right,
    };

    // 實例化一個單元結構體
    let _unit = Unit;

    // 實例化一個元組結構體
    let pair = Pair(1, 0.1);

    // 訪問元組結構體的字段
    println!(&quot;pair contains {:?} and {:?}&quot;, pair.0, pair.1);

    // 解構一個元組結構體
    let Pair(integer, decimal) = pair;

    println!(&quot;pair contains {:?} and {:?}&quot;, integer, decimal);
}
</code></pre></pre>
<h3 id="動手試一試-6"><a class="header" href="#動手試一試-6">動手試一試:</a></h3>
<ol>
<li>增加一個計算 <code>Rectangle</code> （長方形）面積的函數 <code>rect_area</code>（嘗試使用嵌套的解構方式）。</li>
<li>增加一個函數 <code>square</code>，接受的參數是一個 <code>Point</code> 和一個 <code>f32</code>，並返回一個 <code>Rectangle</code>（長方形），其左上角位於該點上，長和寬都對應於 <code>f32</code>。</li>
</ol>
<h3 id="參見-7"><a class="header" href="#參見-7">參見:</a></h3>
<p><a href="custom_types/../attribute.html">屬性</a> 和 <a href="custom_types/../flow_control/match/destructuring.html">解構</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚舉"><a class="header" href="#枚舉">枚舉</a></h1>
<p><code>enum</code> 關鍵字允許創建一個從數個不同取值中選其一的枚舉類型（enumeration）。任何一個在 <code>struct</code> 中合法的取值在 <code>enum</code> 中也合法。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 該屬性用於隱藏對未使用代碼的警告。
#![allow(dead_code)]

// 創建一個 `enum`（枚舉）來對 web 事件分類。注意變量名和類型共同指定了 `enum`
// 取值的種類：`PageLoad` 不等於 `PageUnload`，`KeyPress(char)` 不等於
// `Paste(String)`。各個取值不同，互相獨立。
enum WebEvent {
    // 一個 `enum` 可以是單元結構體（稱為 `unit-like` 或 `unit`），
    PageLoad,
    PageUnload,
    // 或者一個元組結構體，
    KeyPress(char),
    Paste(String),
    // 或者一個普通的結構體。
    Click { x: i64, y: i64 }
}

// 此函數將一個 `WebEvent` enum 作為參數，無返回值。
fn inspect(event: WebEvent) {
    match event {
        WebEvent::PageLoad =&gt; println!(&quot;page loaded&quot;),
        WebEvent::PageUnload =&gt; println!(&quot;page unloaded&quot;),
        // 從 `enum` 裡解構出 `c`。
        WebEvent::KeyPress(c) =&gt; println!(&quot;pressed '{}'.&quot;, c),
        WebEvent::Paste(s) =&gt; println!(&quot;pasted \&quot;{}\&quot;.&quot;, s),
        // 把 `Click` 解構給 `x` and `y`。
        WebEvent::Click { x, y } =&gt; {
            println!(&quot;clicked at x={}, y={}.&quot;, x, y);
        },
    }
}

fn main() {
    let pressed = WebEvent::KeyPress('x');
    // `to_owned()` 從一個字符串切片中創建一個具有所有權的 `String`。
    let pasted  = WebEvent::Paste(&quot;my text&quot;.to_owned());
    let click   = WebEvent::Click { x: 20, y: 80 };
    let load    = WebEvent::PageLoad;
    let unload  = WebEvent::PageUnload;

    inspect(pressed);
    inspect(pasted);
    inspect(click);
    inspect(load);
    inspect(unload);
}
</code></pre></pre>
<h2 id="類型別名"><a class="header" href="#類型別名">類型別名</a></h2>
<p>若使用類型別名，則可以通過其別名引用每個枚舉變量。當枚舉的名稱太長或者太一般化，且你想要對其重命名，那麼這對你會有所幫助。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum VeryVerboseEnumOfThingsToDoWithNumbers {
    Add,
    Subtract,
}

// Creates a type alias
type Operations = VeryVerboseEnumOfThingsToDoWithNumbers;

fn main() {
    // We can refer to each variant via its alias, not its long and inconvenient
    // name.
    let x = Operations::Add;
}
</code></pre></pre>
<p>最常見的情況就是在 <code>impl</code> 塊中使用 <code>Self</code> 別名。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum VeryVerboseEnumOfThingsToDoWithNumbers {
    Add,
    Subtract,
}

impl VeryVerboseEnumOfThingsToDoWithNumbers {
    fn run(&amp;self, x: i32, y: i32) -&gt; i32 {
        match self {
            Self::Add =&gt; x + y,
            Self::Subtract =&gt; x - y,
        }
    }
}
</code></pre></pre>
<p>該功能已在 Rust 中穩定下來， 可以閱讀 <a href="https://github.com/rust-lang/rust/pull/61682/#issuecomment-502472847">stabilization report</a> 來了解更多有關枚舉和類型別名的知識。</p>
<h3 id="參見-8"><a class="header" href="#參見-8">參見：</a></h3>
<p><a href="custom_types/../flow_control/match.html"><code>match</code></a>, <a href="custom_types/../fn.html"><code>fn</code></a>, 和 <a href="custom_types/../std/str.html"><code>String</code></a>, <a href="https://rust-lang.github.io/rfcs/2338-type-alias-enum-variants.html">“類型別名枚舉變量” 的 RFC</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用-use"><a class="header" href="#使用-use">使用 use</a></h1>
<p>使用 <code>use</code> 聲明的話，就可以不寫出名稱的完整路徑了：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 該屬性用於隱藏對未使用代碼的警告。
#![allow(dead_code)]

enum Status {
    Rich,
    Poor,
}

enum Work {
    Civilian,
    Soldier,
}

fn main() {
    // 顯式地 `use` 各個名稱使他們直接可用，而不需要指定它們來自 `Status`。
    use Status::{Poor, Rich};
    // 自動地 `use` `Work` 內部的各個名稱。
    use Work::*;

    // `Poor` 等價於 `Status::Poor`。
    let status = Poor;
    // `Civilian` 等價於 `Work::Civilian`。
    let work = Civilian;

    match status {
        // 注意這裡沒有用完整路徑，因為上面顯式地使用了 `use`。
        Rich =&gt; println!(&quot;The rich have lots of money!&quot;),
        Poor =&gt; println!(&quot;The poor have no money...&quot;),
    }

    match work {
        // 再次注意到沒有用完整路徑。
        Civilian =&gt; println!(&quot;Civilians work!&quot;),
        Soldier  =&gt; println!(&quot;Soldiers fight!&quot;),
    }
}
</code></pre></pre>
<h3 id="參見-9"><a class="header" href="#參見-9">參見：</a></h3>
<p><a href="custom_types/enum/../../flow_control/match.html"><code>match</code></a> 和 <a href="custom_types/enum/../../mod/use.html"><code>use</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-風格用法"><a class="header" href="#c-風格用法">C 風格用法</a></h1>
<p><code>enum</code> 也可以像 C 語言風格的枚舉類型那樣使用。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 該屬性用於隱藏對未使用代碼的警告。
#![allow(dead_code)]

// 擁有隱式辨別值（implicit discriminator，從 0 開始）的 enum
enum Number {
    Zero,
    One,
    Two,
}

// 擁有顯式辨別值（explicit discriminator）的 enum
enum Color {
    Red = 0xff0000,
    Green = 0x00ff00,
    Blue = 0x0000ff,
}

fn main() {
    // `enum` 可以轉成整型。
    println!(&quot;zero is {}&quot;, Number::Zero as i32);
    println!(&quot;one is {}&quot;, Number::One as i32);

    println!(&quot;roses are #{:06x}&quot;, Color::Red as i32);
    println!(&quot;violets are #{:06x}&quot;, Color::Blue as i32);
}
</code></pre></pre>
<h3 id="參考"><a class="header" href="#參考">參考：</a></h3>
<p><a href="custom_types/enum/../../types/cast.html">類型轉換</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="測試實例鏈表"><a class="header" href="#測試實例鏈表">測試實例：鏈表</a></h1>
<p><code>enum</code> 的一個常見用法就是創建鏈表（linked-list）：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use List::*;

enum List {
    // Cons：元組結構體，包含鏈表的一個元素和一個指向下一節點的指針
    Cons(u32, Box&lt;List&gt;),
    // Nil：末結點，表明鏈表結束
    Nil,
}

// 可以為 enum 定義方法
impl List {
    // 創建一個空的 List 實例
    fn new() -&gt; List {
        // `Nil` 為 `List` 類型（譯註：因 `Nil` 的完整名稱是 `List::Nil`）
        Nil
    }

    // 處理一個 List，在其頭部插入新元素，並返回該 List
    fn prepend(self, elem: u32) -&gt; List {
        // `Cons` 同樣為 List 類型
        Cons(elem, Box::new(self))
    }

    // 返回 List 的長度
    fn len(&amp;self) -&gt; u32 {
        // 必須對 `self` 進行匹配（match），因為這個方法的行為取決於 `self` 的
        // 取值種類。
        // `self` 為 `&amp;List` 類型，`*self` 為 `List` 類型，匹配一個具體的 `T`
        // 類型要好過匹配引用 `&amp;T`。
        match *self {
            // 不能得到 tail 的所有權，因為 `self` 是借用的；
            // 因此使用一個對 tail 的引用
            Cons(_, ref tail) =&gt; 1 + tail.len(),
            // （遞歸的）基準情形（base case）：一個長度為 0 的空列表
            Nil =&gt; 0
        }
    }

    // 返回列表的字符串表示（該字符串是堆分配的）
    fn stringify(&amp;self) -&gt; String {
        match *self {
            Cons(head, ref tail) =&gt; {
                // `format!` 和 `print!` 類似，但返回的是一個堆分配的字符串，
                // 而不是打印結果到控制檯上
                format!(&quot;{}, {}&quot;, head, tail.stringify())
            },
            Nil =&gt; {
                format!(&quot;Nil&quot;)
            },
        }
    }
}

fn main() {
    // 創建一個空鏈表
    let mut list = List::new();

    // 追加一些元素
    list = list.prepend(1);
    list = list.prepend(2);
    list = list.prepend(3);

    // 顯示鏈表的最後狀態
    println!(&quot;linked list has length: {}&quot;, list.len());
    println!(&quot;{}&quot;, list.stringify());
}
</code></pre></pre>
<h3 id="參見-10"><a class="header" href="#參見-10">參見：</a></h3>
<p><a href="custom_types/enum/../../std/box.html"><code>Box</code></a> 和 <a href="custom_types/enum/../../fn/methods.html">方法</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常量"><a class="header" href="#常量">常量</a></h1>
<p>Rust 有兩種常量，可以在任意作用域聲明，包括全局作用域。它們都需要顯式的類型聲明：</p>
<ul>
<li><code>const</code>：不可改變的值（通常使用這種）。</li>
<li><code>static</code>：具有 <a href="custom_types/../scope/lifetime/static_lifetime.html"><code>'static</code></a> 生命週期的，可以是可變的變量（譯註：須使用
<code>static mut</code> 關鍵字）。</li>
</ul>
<p>有個特例就是 <code>&quot;string&quot;</code> 字面量。它可以不經改動就被賦給一個 <code>static</code> 變量，因為它
的類型標記：<code>&amp;'static str</code> 就包含了所要求的生命週期 <code>'static</code>。其他的引用類型都
必須特地聲明，使之擁有<code>'static</code> 生命週期。這兩種引用類型的差異似乎也無關緊要，因
為無論如何，<code>static</code> 變量都得顯式地聲明。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">// 全局變量是在在所有其他作用域之外聲明的。
static LANGUAGE: &amp;'static str = &quot;Rust&quot;;
const  THRESHOLD: i32 = 10;

fn is_big(n: i32) -&gt; bool {
    // 在一般函數中訪問常量
    n &gt; THRESHOLD
}

fn main() {
    let n = 16;

    // 在 main 函數（主函數）中訪問常量
    println!(&quot;This is {}&quot;, LANGUAGE);
    println!(&quot;The threshold is {}&quot;, THRESHOLD);
    println!(&quot;{} is {}&quot;, n, if is_big(n) { &quot;big&quot; } else { &quot;small&quot; });

    // 報錯！不能修改一個 `const` 常量。
    THRESHOLD = 5;
    // 改正 ^ 註釋掉此行
}
</code></pre></pre>
<h3 id="參見-11"><a class="header" href="#參見-11">參見：</a></h3>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0246-const-vs-static.md"><code>const</code>/<code>static</code> RFC</a>,
<a href="custom_types/../scope/lifetime/static_lifetime.html"><code>'static</code> 生命週期</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="變量綁定"><a class="header" href="#變量綁定">變量綁定</a></h1>
<p>Rust 通過靜態類型確保類型安全。變量綁定可以在聲明時說明類型，不過在多數情況下，
編譯器能夠從上下文推導出變量的類型，從而大大減少了類型說明的工作。</p>
<p>使用 <code>let</code> 綁定操作可以將值（比如字面量）綁定（bind）到變量。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let an_integer = 1u32;
    let a_boolean = true;
    let unit = ();

    // 將 `an_integer` 複製到 `copied_integer`
    let copied_integer = an_integer;

    println!(&quot;An integer: {:?}&quot;, copied_integer);
    println!(&quot;A boolean: {:?}&quot;, a_boolean);
    println!(&quot;Meet the unit value: {:?}&quot;, unit);

    // 編譯器會對未使用的變量綁定產生警告；可以給變量名加上下劃線前綴來消除警告。
    let _unused_variable = 3u32;

    let noisy_unused_variable = 2u32;
    // 改正 ^ 在變量名前加上下劃線以消除警告
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="可變變量"><a class="header" href="#可變變量">可變變量</a></h1>
<p>變量綁定默認是不可變的（immutable），但加上 <code>mut</code> 修飾語後變量就可以改變。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">fn main() {
    let _immutable_binding = 1;
    let mut mutable_binding = 1;

    println!(&quot;Before mutation: {}&quot;, mutable_binding);

    // 正確代碼
    mutable_binding += 1;

    println!(&quot;After mutation: {}&quot;, mutable_binding);

    // 錯誤！
    _immutable_binding += 1;
    // 改正 ^ 將此行註釋掉
}
</code></pre></pre>
<p>編譯器會給出關於變量可變性的詳細診斷信息。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="作用域和遮蔽"><a class="header" href="#作用域和遮蔽">作用域和遮蔽</a></h1>
<p>變量綁定有一個作用域（scope），它被限定只在一個<strong>代碼塊</strong>（block）中生存（live）。
代碼塊是一個被 <code>{}</code> 包圍的語句集合。另外也允許<a href="https://en.wikipedia.org/wiki/Variable_shadowing">變量遮蔽</a>（variable
shadowing）。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">fn main() {
    // 此綁定生存於 main 函數中
    let long_lived_binding = 1;

    // 這是一個代碼塊，比 main 函數擁有更小的作用域
    {
        // 此綁定只存在於本代碼塊
        let short_lived_binding = 2;

        println!(&quot;inner short: {}&quot;, short_lived_binding);

        // 此綁定*遮蔽*了外面的綁定
        let long_lived_binding = 5_f32;

        println!(&quot;inner long: {}&quot;, long_lived_binding);
    }
    // 代碼塊結束

    // 報錯！`short_lived_binding` 在此作用域上不存在
    println!(&quot;outer short: {}&quot;, short_lived_binding);
    // 改正 ^ 註釋掉這行

    println!(&quot;outer long: {}&quot;, long_lived_binding);

    // 此綁定同樣*遮蔽*了前面的綁定
    let long_lived_binding = 'a';

    println!(&quot;outer long: {}&quot;, long_lived_binding);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="變量先聲明"><a class="header" href="#變量先聲明">變量先聲明</a></h1>
<p>可以先聲明（declare）變量綁定，後面才將它們初始化（initialize）。但是這種做法很
少用，因為這樣可能導致使用未初始化的變量。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">fn main() {
    // 聲明一個變量綁定
    let a_binding;

    {
        let x = 2;

        // 初始化一個綁定
        a_binding = x * x;
    }

    println!(&quot;a binding: {}&quot;, a_binding);

    let another_binding;

    // 報錯！使用了未初始化的綁定
    println!(&quot;another binding: {}&quot;, another_binding);
    // 改正 ^ 註釋掉此行

    another_binding = 1;

    println!(&quot;another binding: {}&quot;, another_binding);
}
</code></pre></pre>
<p>編譯器禁止使用未經初始化的變量，因為這會產生未定義行為（undefined behavior）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="凍結"><a class="header" href="#凍結">凍結</a></h1>
<p>當數據被相同的名稱不變地綁定時，它還會<strong>凍結</strong>（freeze）。在不可變綁定超出作用域之前，無法修改已凍結的數據：</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">fn main() {
    let mut _mutable_integer = 7i32;

    {
        // 被不可變的 `_mutable_integer` 遮蔽
        let _mutable_integer = _mutable_integer;

        // 報錯！`_mutable_integer` 在本作用域被凍結
        _mutable_integer = 50;
        // 改正 ^ 註釋掉上面這行

        // `_mutable_integer` 離開作用域
    }

    // 正常運行！ `_mutable_integer` 在這個作用域沒有凍結
    _mutable_integer = 3;
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="類型系統"><a class="header" href="#類型系統">類型系統</a></h1>
<p>Rust 提供了多種機制，用於改變或定義原生類型和用戶定義類型。接下來會講到：</p>
<ul>
<li>原生類型的<a href="types/cast.html">類型轉換</a>（cast）。</li>
<li>指定<a href="types/literals.html">字面量</a>的類型。</li>
<li>使用<a href="types/inference.html">類型推斷</a>（type inference）。</li>
<li>給類型<a href="types/alias.html">取別名</a>（alias）。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="類型轉換"><a class="header" href="#類型轉換">類型轉換</a></h1>
<p>Rust 不提供原生類型之間的隱式類型轉換（coercion），但可以使用 <code>as</code> 關鍵字進行顯
式類型轉換（casting）。</p>
<p>整型之間的轉換大體遵循 C 語言的慣例，除了 C 會產生未定義行為的情形。在 Rust 中所
有整型轉換都是定義良好的。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">// 不顯示類型轉換產生的溢出警告。
#![allow(overflowing_literals)]

fn main() {
    let decimal = 65.4321_f32;

    // 錯誤！不提供隱式轉換
    let integer: u8 = decimal;
    // 改正 ^ 註釋掉這一行

    // 可以顯式轉換
    let integer = decimal as u8;
    let character = integer as char;

    println!(&quot;Casting: {} -&gt; {} -&gt; {}&quot;, decimal, integer, character);

    // 當把任何類型轉換為無符號類型 T 時，會不斷加上或減去 (std::T::MAX + 1)
    // 直到值位於新類型 T 的範圍內。

    // 1000 已經在 u16 的範圍內
    println!(&quot;1000 as a u16 is: {}&quot;, 1000 as u16);

    // 1000 - 256 - 256 - 256 = 232
    // 事實上的處理方式是：從最低有效位（LSB，least significant bits）開始保留
    // 8 位，然後剩餘位置，直到最高有效位（MSB，most significant bit）都被拋棄。
    // 譯註：MSB 就是二進制的最高位，LSB 就是二進制的最低位，按日常書寫習慣就是
    // 最左邊一位和最右邊一位。
    println!(&quot;1000 as a u8 is : {}&quot;, 1000 as u8);
    // -1 + 256 = 255
    println!(&quot;  -1 as a u8 is : {}&quot;, (-1i8) as u8);

    // 對正數，這就和取模一樣。
    println!(&quot;1000 mod 256 is : {}&quot;, 1000 % 256);

    // 當轉換到有符號類型時，（位操作的）結果就和 “先轉換到對應的無符號類型，
    // 如果 MSB 是 1，則該值為負” 是一樣的。

    // 當然如果數值已經在目標類型的範圍內，就直接把它放進去。
    println!(&quot; 128 as a i16 is: {}&quot;, 128 as i16);
    // 128 轉成 u8 還是 128，但轉到 i8 相當於給 128 取八位的二進制補碼，其值是：
    println!(&quot; 128 as a i8 is : {}&quot;, 128 as i8);

    // 重複之前的例子
    // 1000 as u8 -&gt; 232
    println!(&quot;1000 as a u8 is : {}&quot;, 1000 as u8);
    // 232 的二進制補碼是 -24
    println!(&quot; 232 as a i8 is : {}&quot;, 232 as i8);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字面量"><a class="header" href="#字面量">字面量</a></h1>
<p>對數值字面量，只要把類型作為後綴加上去，就完成了類型說明。比如指定字面量 <code>42</code> 的
類型是 <code>i32</code>，只需要寫 <code>42i32</code>。</p>
<p>無後綴的數值字面量，其類型取決於怎樣使用它們。如果沒有限制，編譯器會對整數使用
<code>i32</code>，對浮點數使用 <code>f64</code>。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // 帶後綴的字面量，其類型在初始化時已經知道了。
    let x = 1u8;
    let y = 2u32;
    let z = 3f32;

    // 無後綴的字面量，其類型取決於如何使用它們。
    let i = 1;
    let f = 1.0;

    // `size_of_val` 返回一個變量所佔的字節數
    println!(&quot;size of `x` in bytes: {}&quot;, std::mem::size_of_val(&amp;x));
    println!(&quot;size of `y` in bytes: {}&quot;, std::mem::size_of_val(&amp;y));
    println!(&quot;size of `z` in bytes: {}&quot;, std::mem::size_of_val(&amp;z));
    println!(&quot;size of `i` in bytes: {}&quot;, std::mem::size_of_val(&amp;i));
    println!(&quot;size of `f` in bytes: {}&quot;, std::mem::size_of_val(&amp;f));
}
</code></pre></pre>
<p>上面的代碼使用了一些還沒有討論過的概念。心急的讀者可以看看下面的簡短解釋：</p>
<ul>
<li><code>fun(&amp;foo)</code> 用<strong>傳引用</strong>（pass by reference）的方式把變量傳給函數，而非
傳值（pass by value，寫法是 <code>fun(foo)</code>）。更多細節請看<a href="types/../scope/borrow.html">借用</a>。</li>
<li><code>std::mem::size_of_val</code> 是一個函數，這裡使用其<strong>完整路徑</strong>（full path）調用。代
碼可以分成一些叫做<strong>模塊</strong>（module）的邏輯單元。在本例中，<code>size_of_val</code> 函數是
在 <code>mem</code> 模塊中定義的，而 <code>mem</code> 模塊又是在 <code>std</code> <strong>crate</strong> 中定義的。更多細節
請看<a href="types/../mod.html">模塊</a>和<a href="types/../crates.html">crate</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="類型推斷"><a class="header" href="#類型推斷">類型推斷</a></h1>
<p>Rust 的類型推斷引擎是很聰明的，它不只是在初始化時看看<a href="https://en.wikipedia.org/wiki/Value_%28computer_science%29#lrvalue">右值</a>（r-value）的
類型而已，它還會考察變量之後會怎樣使用，藉此推斷類型。這是一個類型推導的進階例子：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // 因為有類型說明，編譯器知道 `elem` 的類型是 u8。
    let elem = 5u8;

    // 創建一個空向量（vector，即不定長的，可以增長的數組）。
    let mut vec = Vec::new();
    // 現在編譯器還不知道 `vec` 的具體類型，只知道它是某種東西構成的向量（`Vec&lt;_&gt;`）
    
    // 在向量中插入 `elem`。
    vec.push(elem);
    // 啊哈！現在編譯器知道 `vec` 是 u8 的向量了（`Vec&lt;u8&gt;`）。
    // 試一試 ^ 註釋掉 `vec.push(elem)` 這一行。

    println!(&quot;{:?}&quot;, vec);
}
</code></pre></pre>
<p>沒有必要寫類型說明，編譯器和程序員皆大歡喜！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="別名"><a class="header" href="#別名">別名</a></h1>
<p>可以用 <code>type</code> 語句給已有的類型取個新的名字。類型的名字必須遵循駝峰命名法（像是
<code>CamelCase</code> 這樣），否則編譯器將給出警告。原生類型是例外，比如：
<code>usize</code>、<code>f32</code>，等等。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// `NanoSecond` 是 `u64` 的新名字。
type NanoSecond = u64;
type Inch = u64;

// 通過這個屬性屏蔽警告。
#[allow(non_camel_case_types)]
type u64_t = u64;
// 試一試 ^ 移除上面那個屬性

fn main() {
    // `NanoSecond` = `Inch` = `u64_t` = `u64`.
    let nanoseconds: NanoSecond = 5 as u64_t;
    let inches: Inch = 2 as u64_t;

    // 注意類型別名*並不能*提供額外的類型安全，因為別名*並不是*新的類型。
    println!(&quot;{} nanoseconds + {} inches = {} unit?&quot;,
             nanoseconds,
             inches,
             nanoseconds + inches);
}
</code></pre></pre>
<p>別名的主要用途是避免寫出冗長的模板化代碼（boilerplate code）。如 <code>IoResult&lt;T&gt;</code>
是 <code>Result&lt;T, IoError&gt;</code> 類型的別名。</p>
<h3 id="參見-12"><a class="header" href="#參見-12">參見:</a></h3>
<p><a href="types/../attribute.html">屬性</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="類型轉換-1"><a class="header" href="#類型轉換-1">類型轉換</a></h1>
<p>Rust 使用 <a href="trait.html">trait</a> 解決類型之間的轉換問題。最一般的轉換會用到 <a href="https://rustwiki.org/zh-CN/std/convert/trait.From.html"><code>From</code></a> 
和 <a href="https://rustwiki.org/zh-CN/std/convert/trait.Into.html"><code>into</code></a> 兩個 trait。不過，即便常見的情況也可能會用到特別的 trait，尤其是
從 <code>String</code> 轉換到別的類型，以及把別的類型轉換到 <code>String</code> 時。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-和-into"><a class="header" href="#from-和-into"><code>From</code> 和 <code>Into</code></a></h1>
<p><a href="https://rustwiki.org/zh-CN/std/convert/trait.From.html"><code>From</code></a> 和 <a href="https://rustwiki.org/zh-CN/std/convert/trait.Into.html"><code>Into</code></a> 兩個 trait 是內部相關聯的，實際上這是它們實現的一部分。如果我們能夠從類型 B 得到類型 A，那麼很容易相信我們也能把類型 B 轉換為類型 A。</p>
<h2 id="from"><a class="header" href="#from"><code>From</code></a></h2>
<p><a href="https://rustwiki.org/zh-CN/std/convert/trait.From.html"><code>From</code></a> trait 允許一種類型定義 “怎麼根據另一種類型生成自己”，因此它提供了一種類型轉換的簡單機制。在標準庫中有無數 <code>From</code> 的實現，規定原生類型及其他常見類型的轉換功能。</p>
<p>比如，可以很容易地把 <code>str</code> 轉換成 <code>String</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_str = &quot;hello&quot;;
let my_string = String::from(my_str);
<span class="boring">}
</span></code></pre></pre>
<p>也可以為我們自己的類型定義轉換機制：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From&lt;i32&gt; for Number {
    fn from(item: i32) -&gt; Self {
        Number { value: item }
    }
}

fn main() {
    let num = Number::from(30);
    println!(&quot;My number is {:?}&quot;, num);
}
</code></pre></pre>
<h2 id="into"><a class="header" href="#into"><code>Into</code></a></h2>
<p><a href="https://rustwiki.org/zh-CN/std/convert/trait.Into.html"><code>Into</code></a> trait 就是把 <code>From</code> trait 倒過來而已。也就是說，如果你為你的類型實現了 <code>From</code>，那麼同時你也就免費獲得了 <code>Into</code>。</p>
<p>使用 <code>Into</code> trait 通常要求指明要轉換到的類型，因為編譯器大多數時候不能推斷它。不過考慮到我們免費獲得了 <code>Into</code>，這點代價不值一提。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From&lt;i32&gt; for Number {
    fn from(item: i32) -&gt; Self {
        Number { value: item }
    }
}

fn main() {
    let int = 5;
    // 試試刪除類型說明
    let num: Number = int.into();
    println!(&quot;My number is {:?}&quot;, num);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tryfrom-and-tryinto"><a class="header" href="#tryfrom-and-tryinto"><code>TryFrom</code> and <code>TryInto</code></a></h1>
<p>類似於 <a href="conversion/from_into.html"><code>From</code> 和 <code>Into</code></a>，<a href="https://rustwiki.org/zh-CN/std/convert/trait.TryFrom.html"><code>TryFrom</code></a> 和 <a href="https://rustwiki.org/zh-CN/std/convert/trait.TryInto.html"><code>TryInto</code></a> 是
類型轉換的通用 trait。不同於 <code>From</code>/<code>Into</code> 的是，<code>TryFrom</code> 和 <code>TryInto</code> trait 用於易出錯的轉換，也正因如此，其返回值是 <a href="https://rustwiki.org/zh-CN/std/result/enum.Result.html"><code>Result</code></a> 型。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::convert::TryFrom;
use std::convert::TryInto;

#[derive(Debug, PartialEq)]
struct EvenNumber(i32);

impl TryFrom&lt;i32&gt; for EvenNumber {
    type Error = ();

    fn try_from(value: i32) -&gt; Result&lt;Self, Self::Error&gt; {
        if value % 2 == 0 {
            Ok(EvenNumber(value))
        } else {
            Err(())
        }
    }
}

fn main() {
    // TryFrom

    assert_eq!(EvenNumber::try_from(8), Ok(EvenNumber(8)));
    assert_eq!(EvenNumber::try_from(5), Err(()));

    // TryInto

    let result: Result&lt;EvenNumber, ()&gt; = 8i32.try_into();
    assert_eq!(result, Ok(EvenNumber(8)));
    let result: Result&lt;EvenNumber, ()&gt; = 5i32.try_into();
    assert_eq!(result, Err(()));
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tostring-和-fromstr"><a class="header" href="#tostring-和-fromstr"><code>ToString</code> 和 <code>FromStr</code></a></h1>
<h2 id="tostring"><a class="header" href="#tostring"><code>ToString</code></a></h2>
<p>要把任何類型轉換成 <code>String</code>，只需要實現那個類型的 <a href="https://rustwiki.org/zh-CN/std/string/trait.ToString.html"><code>ToString</code></a> trait。然而不要直接這麼做，您應該實現<a href="https://rustwiki.org/zh-CN/std/fmt/trait.Display.html"><code>fmt::Display</code></a> trait，它會自動提供 <a href="https://rustwiki.org/zh-CN/std/string/trait.ToString.html"><code>ToString</code></a>，並且還可以用來打印類型，就像 <a href="conversion/../hello/print.html"><code>print!</code></a> 一節中討論的那樣。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::string::ToString;

struct Circle {
    radius: i32
}

impl ToString for Circle {
    fn to_string(&amp;self) -&gt; String {
        format!(&quot;Circle of radius {:?}&quot;, self.radius)
    }
}

fn main() {
    let circle = Circle { radius: 6 };
    println!(&quot;{}&quot;, circle.to_string());
}
</code></pre></pre>
<h2 id="解析字符串"><a class="header" href="#解析字符串">解析字符串</a></h2>
<p>我們經常需要把字符串轉成數字。完成這項工作的標準手段是用 <a href="https://rustwiki.org/zh-CN/std/primitive.str.html#method.parse"><code>parse</code></a> 函數。我們得
提供要轉換到的類型，這可以通過不使用類型推斷，或者用 “渦輪魚” 語法（turbo
fish，<code>&lt;&gt;</code>）實現。</p>
<p>只要對目標類型實現了 <a href="https://rustwiki.org/zh-CN/std/str/trait.FromStr.html"><code>FromStr</code></a> trait，就可以用 <code>parse</code> 把字符串轉換成目標類型。
標準庫中已經給無數種類型實現了 <code>FromStr</code>。如果要轉換到用戶定義類型，只要手動實現
<code>FromStr</code> 就行。</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let parsed: i32 = &quot;5&quot;.parse().unwrap();
    let turbo_parsed = &quot;10&quot;.parse::&lt;i32&gt;().unwrap();

    let sum = parsed + turbo_parsed;
    println!{&quot;Sum: {:?}&quot;, sum};
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="表達式"><a class="header" href="#表達式">表達式</a></h1>
<p>Rust 程序（大部分）由一系列語句構成：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    // 語句
    // 語句
    // 語句
}
</code></pre></pre>
<p>Rust 有多種語句。最普遍的語句類型有兩種：一種是聲明綁定變量，另一種是表達式帶上英文分號(;)：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    // 變量綁定
    let x = 5;

    // 表達式;
    x;
    x + 1;
    15;
}
</code></pre></pre>
<p>代碼塊也是表達式，所以它們可以用作賦值中的值。代碼塊中的最後一個表達式將賦給適當的表達式，例如局部變量。但是，如果代碼塊的最後一個表達式結尾處有分號，則返回值為 <code>()</code>（譯註：代碼塊中的最後一個語句是代碼塊中<strong>實際執行</strong>的最後一個語句，而不一定是代碼塊中最後一行的語句）。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x = 5u32;

    let y = {
        let x_squared = x * x;
        let x_cube = x_squared * x;

        // 將此表達式賦給 `y`
        x_cube + x_squared + x
    };

    let z = {
        // 分號結束了這個表達式，於是將 `()` 賦給 `z`
        2 * x;
    };

    println!(&quot;x is {:?}&quot;, x);
    println!(&quot;y is {:?}&quot;, y);
    println!(&quot;z is {:?}&quot;, z);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="流程控制"><a class="header" href="#流程控制">流程控制</a></h1>
<p>任何編程語言都包含的一個必要部分就是改變控制流程：<code>if</code>/<code>else</code>，<code>for</code> 等。讓我們
談談 Rust 語言中的這部分內容。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ifelse"><a class="header" href="#ifelse"><code>if/else</code></a></h1>
<p><code>if</code>-<code>else</code> 分支判斷和其他語言類似。不同的是，Rust 語言中的布爾判斷條件不必使用小括號包裹，且每個條件後面都跟著一個代碼塊。<code>if</code>-<code>else</code> 條件選擇是一個表達式，並且所有分支都必須返回相同的類型。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let n = 5;

    if n &lt; 0 {
        print!(&quot;{} is negative&quot;, n);
    } else if n &gt; 0 {
        print!(&quot;{} is positive&quot;, n);
    } else {
        print!(&quot;{} is zero&quot;, n);
    }

    let big_n =
        if n &lt; 10 &amp;&amp; n &gt; -10 {
            println!(&quot;, and is a small number, increase ten-fold&quot;);

            // 這個表達式返回一個 `i32` 類型。
            10 * n
        } else {
            println!(&quot;, and is a big number, half the number&quot;);

            // 這個表達式也必須返回一個 `i32` 類型。
            n / 2
            // 試一試 ^ 試著加上一個分號來結束這條表達式。
        };
    //   ^ 不要忘記在這裡加上一個分號！所有的 `let` 綁定都需要它。

    println!(&quot;{} -&gt; {}&quot;, n, big_n);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loop-循環"><a class="header" href="#loop-循環">loop 循環</a></h1>
<p>Rust 提供了 <code>loop</code> 關鍵字來表示一個無限循環。</p>
<p>可以使用 <code>break</code> 語句在任何時候退出一個循環，還可以使用 <code>continue</code> 跳過循環體的剩餘部分並開始下一輪循環。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut count = 0u32;

    println!(&quot;Let's count until infinity!&quot;);

    // 無限循環
    loop {
        count += 1;

        if count == 3 {
            println!(&quot;three&quot;);

            // 跳過這次迭代的剩下內容
            continue;
        }

        println!(&quot;{}&quot;, count);

        if count == 5 {
            println!(&quot;OK, that's enough&quot;);

            // 退出循環
            break;
        }
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="嵌套循環和標籤"><a class="header" href="#嵌套循環和標籤">嵌套循環和標籤</a></h1>
<p>在處理嵌套循環的時候可以 <code>break</code> 或 <code>continue</code> 外層循環。在這類情形中，循環必須用一些 <code>'label</code>（標籤）來註明，並且標籤必須傳遞給 <code>break</code>/<code>continue</code> 語句。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#![allow(unreachable_code)]

fn main() {
    'outer: loop {
        println!(&quot;Entered the outer loop&quot;);

        'inner: loop {
            println!(&quot;Entered the inner loop&quot;);

            // 這只是中斷內部的循環
            //break;

            // 這會中斷外層循環
            break 'outer;
        }

        println!(&quot;This point will never be reached&quot;);
    }

    println!(&quot;Exited the outer loop&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="從-loop-循環中返回"><a class="header" href="#從-loop-循環中返回">從 loop 循環中返回</a></h1>
<p><code>loop</code> 有個用途是嘗試一個操作直到成功為止。若操作返回一個值，則可能需要將其傳遞給代碼的其餘部分：將該值放在 <code>break</code> 之後，它就會被 <code>loop</code> 表達式返回。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    assert_eq!(result, 20);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="while-循環"><a class="header" href="#while-循環">while 循環</a></h1>
<p><code>while</code> 關鍵字可以用作當型循環（當條件滿足時循環）。</p>
<p>讓我們用 <code>while</code> 循環寫一下臭名昭著的 <a href="https://en.wikipedia.org/wiki/Fizz_buzz">FizzBuzz</a>（譯者補充：<a href="https://leetcode-cn.com/problems/fizz-buzz/">LeetCode 上的 FizzBuzz 問題描述</a>） 程序。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // 計數器變量
    let mut n = 1;

    // 當 `n` 小於 101 時循環
    while n &lt; 101 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }

        // 計數器值加 1
        n += 1;
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="for-循環"><a class="header" href="#for-循環">for 循環</a></h1>
<h2 id="for-與區間"><a class="header" href="#for-與區間">for 與區間</a></h2>
<p><code>for in</code> 結構可以遍歷一個 <code>Iterator</code>（迭代器）。創建迭代器的一個最簡單的方法是使用區間標記 <code>a..b</code>。這會生成從 <code>a</code>（包含此值） 到 <code>b</code>（不含此值）的，步長為 1 的一系列值。</p>
<p>讓我們使用 <code>for</code> 代替 <code>while</code> 來寫 FizzBuzz 程序。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // `n` 將在每次迭代中分別取 1, 2, ..., 100
    for n in 1..101 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }
    }
}
</code></pre></pre>
<p>或者，可以使用<code>a..=b</code>表示兩端都包含在內的範圍。上面的代碼可以寫成：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // `n` 將在每次迭代中分別取 1, 2, ..., 100
    for n in 1..=100 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }
    }
}
</code></pre></pre>
<h2 id="for-與迭代器"><a class="header" href="#for-與迭代器">for 與迭代器</a></h2>
<p><code>for in</code> 結構能以幾種方式與 <code>Iterator</code> 互動。在 <a href="flow_control/../trait/iter.html">迭代器</a> trait 一節將會談到，如果沒有特別指定，<code>for</code> 循環會對給出的集合應用 <code>into_iter</code> 函數，把它轉換成一個迭代器。這並不是把集合變成迭代器的唯一方法，其他的方法有 <code>iter</code> 和<code>iter_mut</code> 函數。</p>
<p>這三個函數會以不同的方式返回集合中的數據。</p>
<ul>
<li><code>iter</code> - 在每次迭代中借用集合中的一個元素。這樣集合本身不會被改變，循環之後仍可以使用。</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    for name in names.iter() {
        match name {
            &amp;&quot;Ferris&quot; =&gt; println!(&quot;There is a rustacean among us!&quot;),
            _ =&gt; println!(&quot;Hello {}&quot;, name),
        }
    }
}
</code></pre></pre>
<p>譯註：Ferris 是 Rust 的<a href="https://www.rustacean.net/">非官方吉祥物</a>。</p>
<ul>
<li><code>into_iter</code> - 會消耗集合。在每次迭代中，集合中的數據本身會被提供。一旦集合被消耗了，之後就無法再使用了，因為它已經在循環中被 “移除”（move）了。</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    for name in names.into_iter() {
        match name {
            &quot;Ferris&quot; =&gt; println!(&quot;There is a rustacean among us!&quot;),
            _ =&gt; println!(&quot;Hello {}&quot;, name),
        }
    }
}
</code></pre></pre>
<ul>
<li><code>iter_mut</code> - 可變地（mutably）借用集合中的每個元素，從而允許集合被就地修改。</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    for name in names.iter_mut() {
        *name = match name {
            &amp;mut &quot;Ferris&quot; =&gt; &quot;There is a rustacean among us!&quot;,
            _ =&gt; &quot;Hello&quot;,
        }
    }
    println!(&quot;names: {:?}&quot;, names);
}
</code></pre></pre>
<p>在上面這些代碼中，注意 <code>match</code> 的分支中所寫的類型不同，這是不同迭代方式的關鍵區別。因為類型不同，能夠執行的操作當然也不同。</p>
<h3 id="參見-13"><a class="header" href="#參見-13">參見：</a></h3>
<p><a href="flow_control/../trait/iter.html">Iterator</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match-匹配"><a class="header" href="#match-匹配">match 匹配</a></h1>
<p>Rust 通過 <code>match</code> 關鍵字來提供模式匹配，和 C 語言的 <code>switch</code> 用法類似。第一個匹配分支會被比對，並且所有可能的值都必須被覆蓋。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let number = 13;
    // 試一試 ^ 將不同的值賦給 `number`

    println!(&quot;Tell me about {}&quot;, number);
    match number {
        // 匹配單個值
        1 =&gt; println!(&quot;One!&quot;),
        // 匹配多個值
        2 | 3 | 5 | 7 | 11 =&gt; println!(&quot;This is a prime&quot;),
        // 試一試 ^ 將 13 添加到質數列表中
        // 匹配一個閉區間範圍
        13..=19 =&gt; println!(&quot;A teen&quot;),
        // 處理其他情況
        _ =&gt; println!(&quot;Ain't special&quot;),
        // 試一試 ^ 註釋掉這個總括性的分支
    }

    let boolean = true;
    // match 也是一個表達式
    let binary = match boolean {
        // match 分支必須覆蓋所有可能的值
        false =&gt; 0,
        true =&gt; 1,
        // 試一試 ^ 將其中一條分支註釋掉
    };

    println!(&quot;{} -&gt; {}&quot;, boolean, binary);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="解構"><a class="header" href="#解構">解構</a></h1>
<p><code>match</code> 代碼塊能以多種方式解構物件。</p>
<ul>
<li><a href="flow_control/match/destructuring/destructure_tuple.html">解構元組</a></li>
<li><a href="flow_control/match/destructuring/destructure_enum.html">解構枚舉</a></li>
<li><a href="flow_control/match/destructuring/destructure_pointers.html">解構指針</a></li>
<li><a href="flow_control/match/destructuring/destructure_structures.html">解構結構體</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="元組-1"><a class="header" href="#元組-1">元組</a></h1>
<p>元組可以在 <code>match</code> 中解構，如下所示：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let triple = (0, -2, 3);
    // 試一試 ^ 將不同的值賦給 `triple`

    println!(&quot;Tell me about {:?}&quot;, triple);
    // match 可以解構一個元組
    match triple {
        // 解構出第二個和第三個元素
        (0, y, z) =&gt; println!(&quot;First is `0`, `y` is {:?}, and `z` is {:?}&quot;, y, z),
        (1, ..)  =&gt; println!(&quot;First is `1` and the rest doesn't matter&quot;),
        // `..` 可用來忽略元組的其餘部分
        _      =&gt; println!(&quot;It doesn't matter what they are&quot;),
        // `_` 表示不將值綁定到變量
    }
}
</code></pre></pre>
<h3 id="參見-14"><a class="header" href="#參見-14">參見：</a></h3>
<p><a href="flow_control/match/destructuring/../../../primitives/tuples.html">元組</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚舉-1"><a class="header" href="#枚舉-1">枚舉</a></h1>
<p>和前面相似，解構 <code>enum</code> 的方式如下：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 需要 `allow` 來消除警告，因為只使用了枚舉類型的一種取值。
#[allow(dead_code)]
enum Color {
    // 這三個取值僅由它們的名字（而非類型）來指定。
    Red,
    Blue,
    Green,
    // 這些則把 `u32` 元組賦予不同的名字，以色彩模型命名。
    RGB(u32, u32, u32),
    HSV(u32, u32, u32),
    HSL(u32, u32, u32),
    CMY(u32, u32, u32),
    CMYK(u32, u32, u32, u32),
}

fn main() {
    let color = Color::RGB(122, 17, 40);
    // 試一試 ^ 將不同的值賦給 `color`

    println!(&quot;What color is it?&quot;);
    // 可以使用 `match` 來解構 `enum`。
    match color {
        Color::Red   =&gt; println!(&quot;The color is Red!&quot;),
        Color::Blue  =&gt; println!(&quot;The color is Blue!&quot;),
        Color::Green =&gt; println!(&quot;The color is Green!&quot;),
        Color::RGB(r, g, b) =&gt;
            println!(&quot;Red: {}, green: {}, and blue: {}!&quot;, r, g, b),
        Color::HSV(h, s, v) =&gt;
            println!(&quot;Hue: {}, saturation: {}, value: {}!&quot;, h, s, v),
        Color::HSL(h, s, l) =&gt;
            println!(&quot;Hue: {}, saturation: {}, lightness: {}!&quot;, h, s, l),
        Color::CMY(c, m, y) =&gt;
            println!(&quot;Cyan: {}, magenta: {}, yellow: {}!&quot;, c, m, y),
        Color::CMYK(c, m, y, k) =&gt;
            println!(&quot;Cyan: {}, magenta: {}, yellow: {}, key (black): {}!&quot;,
                c, m, y, k),
        // 不需要其它分支，因為所有的情形都已覆蓋
    }
}
</code></pre></pre>
<h3 id="參見-15"><a class="header" href="#參見-15">參見：</a></h3>
<p><a href="flow_control/match/destructuring/../../../attribute/unused.html"><code>#[allow(...)]</code></a>, <a href="https://en.wikipedia.org/wiki/Color_model">色彩模型</a> 和 <a href="flow_control/match/destructuring/../../../custom_types/enum.html"><code>enum</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="指針和引用"><a class="header" href="#指針和引用">指針和引用</a></h1>
<p>對指針來說，解構（destructure）和解引用（dereference）要區分開，因為這兩者的概念是不同的，和 <code>C</code> 那樣的語言用法不一樣。</p>
<ul>
<li>解引用使用 <code>*</code></li>
<li>解構使用 <code>&amp;</code>、<code>ref</code>、和 <code>ref mut</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // 獲得一個 `i32` 類型的引用。`&amp;` 表示取引用。
    let reference = &amp;4;

    match reference {
        // 如果用 `&amp;val` 這個模式去匹配 `reference`，就相當於做這樣的比較：
        // `&amp;i32`（譯註：即 `reference` 的類型）
        // `&amp;val`（譯註：即用於匹配的模式）
        // ^ 我們看到，如果去掉匹配的 `&amp;`，`i32` 應當賦給 `val`。
        // 譯註：因此可用 `val` 表示被 `reference` 引用的值 4。
        &amp;val =&gt; println!(&quot;Got a value via destructuring: {:?}&quot;, val),
    }

    // 如果不想用 `&amp;`，需要在匹配前解引用。
    match *reference {
        val =&gt; println!(&quot;Got a value via dereferencing: {:?}&quot;, val),
    }

    // 如果一開始就不用引用，會怎樣？ `reference` 是一個 `&amp;` 類型，因為賦值語句
    // 的右邊已經是一個引用。但下面這個不是引用，因為右邊不是。
    let _not_a_reference = 3;

    // Rust 對這種情況提供了 `ref`。它更改了賦值行為，從而可以對具體值創建引用。
    // 下面這行將得到一個引用。
    let ref _is_a_reference = 3;

    // 相應地，定義兩個非引用的變量，通過 `ref` 和 `ref mut` 仍可取得其引用。
    let value = 5;
    let mut mut_value = 6;

    // 使用 `ref` 關鍵字來創建引用。
    // 譯註：下面的 r 是 `&amp;i32` 類型，它像 `i32` 一樣可以直接打印，因此用法上
    // 似乎看不出什麼區別。但讀者可以把 `println!` 中的 `r` 改成 `*r`，仍然能
    // 正常運行。前面例子中的 `println!` 裡就不能是 `*val`，因為不能對整數解
    // 引用。
    match value {
        ref r =&gt; println!(&quot;Got a reference to a value: {:?}&quot;, r),
    }

    // 類似地使用 `ref mut`。
    match mut_value {
        ref mut m =&gt; {
            // 已經獲得了 `mut_value` 的引用，先要解引用，才能改變它的值。
            *m += 10;
            println!(&quot;We added 10. `mut_value`: {:?}&quot;, m);
        },
    }
}
</code></pre></pre>
<h3 id="參見-16"><a class="header" href="#參見-16">參見：</a></h3>
<p><a href="flow_control/match/destructuring/../../../scope/borrow/ref.html">ref 模式</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="結構體-1"><a class="header" href="#結構體-1">結構體</a></h1>
<p>類似地，解構 <code>struct</code> 如下所示：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    struct Foo { x: (u32, u32), y: u32 }

    // 解構結構體的成員
    let foo = Foo { x: (1, 2), y: 3 };
    let Foo { x: (a, b), y } = foo;

    println!(&quot;a = {}, b = {},  y = {} &quot;, a, b, y);

    // 可以解構結構體並重命名變量，成員順序並不重要

    let Foo { y: i, x: j } = foo;
    println!(&quot;i = {:?}, j = {:?}&quot;, i, j);

    // 也可以忽略某些變量
    let Foo { y, .. } = foo;
    println!(&quot;y = {}&quot;, y);

    // 這將得到一個錯誤：模式中沒有提及 `x` 字段
    // let Foo { y } = foo;
}
</code></pre></pre>
<h3 id="參見-17"><a class="header" href="#參見-17">參見：</a></h3>
<p><a href="flow_control/match/destructuring/../../../custom_types/structs.html">結構體</a>, <a href="flow_control/match/destructuring/../../../scope/borrow/ref.html">ref 模式</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="衛語句"><a class="header" href="#衛語句">衛語句</a></h1>
<p>可以加上 <code>match</code> <strong>衛語句</strong>（guard） 來過濾分支。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let pair = (2, -2);
    // 試一試 ^ 將不同的值賦給 `pair`

    println!(&quot;Tell me about {:?}&quot;, pair);
    match pair {
        (x, y) if x == y =&gt; println!(&quot;These are twins&quot;),
        // ^ `if` 條件部分是一個衛語句
        (x, y) if x + y == 0 =&gt; println!(&quot;Antimatter, kaboom!&quot;),
        (x, _) if x % 2 == 1 =&gt; println!(&quot;The first one is odd&quot;),
        _ =&gt; println!(&quot;No correlation...&quot;),
    }
}
</code></pre></pre>
<h3 id="參見-18"><a class="header" href="#參見-18">參見：</a></h3>
<p><a href="flow_control/match/../../primitives/tuples.html">元組</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="綁定"><a class="header" href="#綁定">綁定</a></h1>
<p>在 <code>match</code> 中，若間接地訪問一個變量，則不經過重新綁定就無法在分支中再使用它。<code>match</code> 提供了 <code>@</code> 符號來綁定變量到名稱：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// `age` 函數，返回一個 `u32` 值。
fn age() -&gt; u32 {
    15
}

fn main() {
    println!(&quot;Tell me what type of person you are&quot;);

    match age() {
        0             =&gt; println!(&quot;I haven't celebrated my first birthday yet&quot;),
        // 可以直接匹配（`match`） 1 ..= 12，但那樣的話孩子會是幾歲？
        // 相反，在 1 ..= 12 分支中綁定匹配值到 `n` 。現在年齡就可以讀取了。
        n @ 1  ..= 12 =&gt; println!(&quot;I'm a child of age {:?}&quot;, n),
        n @ 13 ..= 19 =&gt; println!(&quot;I'm a teen of age {:?}&quot;, n),
        // 不符合上面的範圍。返回結果。
        n             =&gt; println!(&quot;I'm an old person of age {:?}&quot;, n),
    }
}
</code></pre></pre>
<p>你也可以使用綁定來“解構” <code>enum</code> 變體，例如 <code>Option</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn some_number() -&gt; Option&lt;u32&gt; {
    Some(42)
}

fn main() {
    match some_number() {
        // 得到 `Some` 可變類型，如果它的值（綁定到 `n` 上）等於 42，則匹配。
        Some(n @ 42) =&gt; println!(&quot;The Answer: {}!&quot;, n),
        // 匹配任意其他數字。
        Some(n)      =&gt; println!(&quot;Not interesting... {}&quot;, n),
        // 匹配任意其他值（`None` 可變類型）。
        _            =&gt; (),
    }
}
</code></pre></pre>
<h3 id="參見-19"><a class="header" href="#參見-19">參見：</a></h3>
<p><a href="flow_control/match/../../fn.html"><code>函數</code></a>，<a href="flow_control/match/../../custom_types/enum.html"><code>枚舉</code></a> 和 <a href="flow_control/match/../../std/option.html"><code>Option</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-let"><a class="header" href="#if-let">if let</a></h1>
<p>在一些場合下，用 <code>match</code> 匹配枚舉類型並不優雅。比如：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 將 `optional` 定為 `Option&lt;i32&gt;` 類型
let optional = Some(7);

match optional {
    Some(i) =&gt; {
        println!(&quot;This is a really long string and `{:?}`&quot;, i);
        // ^ 行首需要 2 層縮進。這裡從 optional 中解構出 `i`。
        // 譯註：正確的縮進是好的，但並不是 “不縮進就不能運行” 這個意思。
    },
    _ =&gt; {},
    // ^ 必須有，因為 `match` 需要覆蓋全部情況。不覺得這行很多餘嗎？
};

<span class="boring">}
</span></code></pre></pre>
<p><code>if let</code> 在這樣的場合要簡潔得多，並且允許指明數種失敗情形下的選項：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // 全部都是 `Option&lt;i32&gt;` 類型
    let number = Some(7);
    let letter: Option&lt;i32&gt; = None;
    let emoticon: Option&lt;i32&gt; = None;

    // `if let` 結構讀作：若 `let` 將 `number` 解構成 `Some(i)`，則執行
    // 語句塊（`{}`）
    if let Some(i) = number {
        println!(&quot;Matched {:?}!&quot;, i);
    }

    // 如果要指明失敗情形，就使用 else：
    if let Some(i) = letter {
        println!(&quot;Matched {:?}!&quot;, i);
    } else {
        // 解構失敗。切換到失敗情形。
        println!(&quot;Didn't match a number. Let's go with a letter!&quot;);
    };

    // 提供另一種失敗情況下的條件。
    let i_like_letters = false;

    if let Some(i) = emoticon {
        println!(&quot;Matched {:?}!&quot;, i);
    // 解構失敗。使用 `else if` 來判斷是否滿足上面提供的條件。
    } else if i_like_letters {
        println!(&quot;Didn't match a number. Let's go with a letter!&quot;);
    } else {
        // 條件的值為 false。於是以下是默認的分支：
        println!(&quot;I don't like letters. Let's go with an emoticon :)!&quot;);
    };
}
</code></pre></pre>
<p>同樣，可以用 <code>if let</code> 匹配任何枚舉值：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 以這個 enum 類型為例
enum Foo {
    Bar,
    Baz,
    Qux(u32)
}

fn main() {
    // 創建變量
    let a = Foo::Bar;
    let b = Foo::Baz;
    let c = Foo::Qux(100);

    // 變量 a 匹配到了 Foo::Bar
    if let Foo::Bar = a {
        println!(&quot;a is foobar&quot;);
    }

    // 變量 b 沒有匹配到 Foo::Bar，因此什麼也不會打印。
    if let Foo::Bar = b {
        println!(&quot;b is foobar&quot;);
    }

    // 變量 c 匹配到了 Foo::Qux，它帶有一個值，就和上面例子中的 Some() 類似。
    if let Foo::Qux(value) = c {
        println!(&quot;c is {}&quot;, value);
    }
}
</code></pre></pre>
<p>另一個好處是：<code>if let</code> 允許匹配枚舉非參數化的變量，即枚舉未註明 <code>#[derive(PartialEq)]</code>，我們也沒有為其實現 <code>PartialEq</code>。在這種情況下，通常 <code>if Foo::Bar==a</code> 會出錯，因為此類枚舉的實例不具有可比性。但是，<code>if let</code> 是可行的。</p>
<p>你想挑戰一下嗎？使用 <code>if let</code>修復以下示例：</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">// 該枚舉故意未註明 `#[derive(PartialEq)]`，
// 並且也沒為其實現 `PartialEq`。這就是為什麼下面比較 `Foo::Bar==a` 會失敗的原因。
enum Foo {Bar}

fn main() {
    let a = Foo::Bar;

    // 變量匹配 Foo::Bar
    if Foo::Bar == a {
    // ^-- 這就是編譯時發現的錯誤。使用 `if let` 來替換它。
        println!(&quot;a is foobar&quot;);
    }
}
</code></pre></pre>
<h3 id="參見-20"><a class="header" href="#參見-20">參見：</a></h3>
<p><a href="flow_control/../custom_types/enum.html"><code>枚舉</code></a>，<a href="flow_control/../std/option.html"><code>Option</code></a>，和相關的 <a href="https://github.com/rust-lang/rfcs/pull/160">RFC</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="while-let"><a class="header" href="#while-let">while let</a></h1>
<p>和 <code>if let</code> 類似，<code>while let</code> 也可以把彆扭的 <code>match</code> 改寫得好看一些。考慮下面這段使 <code>i</code> 不斷增加的代碼：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 將 `optional` 設為 `Option&lt;i32&gt;` 類型
let mut optional = Some(0);

// 重複運行這個測試。
loop {
    match optional {
        // 如果 `optional` 解構成功，就執行下面語句塊。
        Some(i) =&gt; {
            if i &gt; 9 {
                println!(&quot;Greater than 9, quit!&quot;);
                optional = None;
            } else {
                println!(&quot;`i` is `{:?}`. Try again.&quot;, i);
                optional = Some(i + 1);
            }
            // ^ 需要三層縮進！
        },
        // 當解構失敗時退出循環：
        _ =&gt; { break; }
        // ^ 為什麼必須寫這樣的語句呢？肯定有更優雅的處理方式！
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>使用 <code>while let</code> 可以使這段代碼變得更加優雅：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // 將 `optional` 設為 `Option&lt;i32&gt;` 類型
    let mut optional = Some(0);

    // 這讀作：當 `let` 將 `optional` 解構成 `Some(i)` 時，就
    // 執行語句塊（`{}`）。否則就 `break`。
    while let Some(i) = optional {
        if i &gt; 9 {
            println!(&quot;Greater than 9, quit!&quot;);
            optional = None;
        } else {
            println!(&quot;`i` is `{:?}`. Try again.&quot;, i);
            optional = Some(i + 1);
        }
        // ^ 使用的縮進更少，並且不用顯式地處理失敗情況。
    }
    // ^ `if let` 有可選的 `else`/`else if` 分句，
    // 而 `while let` 沒有。
}
</code></pre></pre>
<h3 id="參見-21"><a class="header" href="#參見-21">參見：</a></h3>
<p><a href="flow_control/../custom_types/enum.html"><code>枚舉</code></a>，<a href="flow_control/../std/option.html"><code>Option</code></a>，和相關的 <a href="https://github.com/rust-lang/rfcs/pull/214">RFC</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函數"><a class="header" href="#函數">函數</a></h1>
<p>函數（function）使用 <code>fn</code> 關鍵字來聲明。函數的參數需要標註類型，就和變量一樣，如果函數返回一個值，返回類型必須在箭頭 <code>-&gt;</code> 之後指定。</p>
<p>函數最後的表達式將作為返回值。也可以在函數內使用 <code>return</code> 語句來提前返一個值，甚至可以在循環或 <code>if</code> 內部使用。</p>
<p>讓我們使用函數來重寫 FizzBuzz 程序吧！</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 和 C/C++ 不一樣，Rust 的函數定義位置是沒有限制的
fn main() {
    // 我們可以在這裡使用函數，後面再定義它
    fizzbuzz_to(100);
}

// 一個返回布爾值的函數
fn is_divisible_by(lhs: u32, rhs: u32) -&gt; bool {
    // 邊界情況，提前返回
    if rhs == 0 {
        return false;
    }

    // 這是一個表達式，可以不用 `return` 關鍵字
    lhs % rhs == 0
}

// 一個 “不” 返回值的函數。實際上會返回一個單元類型 `()`。
fn fizzbuzz(n: u32) -&gt; () {
    if is_divisible_by(n, 15) {
        println!(&quot;fizzbuzz&quot;);
    } else if is_divisible_by(n, 3) {
        println!(&quot;fizz&quot;);
    } else if is_divisible_by(n, 5) {
        println!(&quot;buzz&quot;);
    } else {
        println!(&quot;{}&quot;, n);
    }
}

// 當函數返回 `()` 時，函數簽名可以省略返回類型
fn fizzbuzz_to(n: u32) {
    for n in 1..=n {
        fizzbuzz(n);
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="方法"><a class="header" href="#方法">方法</a></h1>
<p>方法（method）是依附於對象的函數。這些方法通過關鍵字 <code>self</code> 來訪問對象中的數據和其他。方法在 <code>impl</code> 代碼塊中定義。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Point {
    x: f64,
    y: f64,
}

// 實現的代碼塊，`Point` 的所有方法都在這裡給出
impl Point {
    // 這是一個靜態方法（static method）
    // 靜態方法不需要被實例調用
    // 這類方法一般用作構造器（constructor）
    fn origin() -&gt; Point {
        Point { x: 0.0, y: 0.0 }
    }

    // 另外一個靜態方法，需要兩個參數：
    fn new(x: f64, y: f64) -&gt; Point {
        Point { x: x, y: y }
    }
}

struct Rectangle {
    p1: Point,
    p2: Point,
}

impl Rectangle {
    // 這是一個實例方法（instance method）
    // `&amp;self` 是 `self: &amp;Self` 的語法糖（sugar），其中 `Self` 是方法調用者的
    // 類型。在這個例子中 `Self` = `Rectangle`
    fn area(&amp;self) -&gt; f64 {
        // `self` 通過點運算符來訪問結構體字段
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        // `abs` 是一個 `f64` 類型的方法，返回調用者的絕對值
        ((x1 - x2) * (y1 - y2)).abs()
    }

    fn perimeter(&amp;self) -&gt; f64 {
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        2.0 * ((x1 - x2).abs() + (y1 - y2).abs())
    }

    // 這個方法要求調用者是可變的
    // `&amp;mut self` 為 `self: &amp;mut Self` 的語法糖
    fn translate(&amp;mut self, x: f64, y: f64) {
        self.p1.x += x;
        self.p2.x += x;

        self.p1.y += y;
        self.p2.y += y;
    }
}

// `Pair` 擁有資源：兩個堆分配的整型
struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);

impl Pair {
    // 這個方法會 “消耗” 調用者的資源
    // `self` 為 `self: Self` 的語法糖
    fn destroy(self) {
        // 解構 `self`
        let Pair(first, second) = self;

        println!(&quot;Destroying Pair({}, {})&quot;, first, second);

        // `first` 和 `second` 離開作用域後釋放
    }
}

fn main() {
    let rectangle = Rectangle {
        // 靜態方法使用雙冒號調用
        p1: Point::origin(),
        p2: Point::new(3.0, 4.0),
    };

    // 實例方法通過點運算符來調用
    // 注意第一個參數 `&amp;self` 是隱式傳遞的，亦即：
    // `rectangle.perimeter()` === `Rectangle::perimeter(&amp;rectangle)`
    println!(&quot;Rectangle perimeter: {}&quot;, rectangle.perimeter());
    println!(&quot;Rectangle area: {}&quot;, rectangle.area());

    let mut square = Rectangle {
        p1: Point::origin(),
        p2: Point::new(1.0, 1.0),
    };

    // 報錯！ `rectangle` 是不可變的，但這方法需要一個可變對象
    //rectangle.translate(1.0, 0.0);
    // 試一試 ^ 去掉此行的註釋

    // 正常運行！可變對象可以調用可變方法
    square.translate(1.0, 1.0);

    let pair = Pair(Box::new(1), Box::new(2));

    pair.destroy();

    // 報錯！前面的 `destroy` 調用 “消耗了” `pair`
    //pair.destroy();
    // 試一試 ^ 將此行註釋去掉
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="閉包"><a class="header" href="#閉包">閉包</a></h1>
<p>Rust 中的閉包（closure），也叫做 lambda 表達式或者 lambda，是一類能夠捕獲周圍作用域中變量的函數。例如，一個可以捕獲 x 變量的閉包如下：</p>
<pre><code class="language-Rust">|val| val + x
</code></pre>
<p>它們的語法和能力使它們在臨時（on the fly）使用時相當方便。調用一個閉包和調用一個函數完全相同，不過調用閉包時，輸入和返回類型兩者都<strong>可以</strong>自動推導，而輸入變量名<strong>必須</strong>指明。</p>
<p>其他的特點包括：</p>
<ul>
<li>聲明時使用 <code>||</code> 替代 <code>()</code> 將輸入參數括起來。</li>
<li>函數體定界符（<code>{}</code>）對於單個表達式是可選的，其他情況必須加上。</li>
<li>有能力捕獲外部環境的變量。</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // 通過閉包和函數分別實現自增。
    // 譯註：下面這行是使用函數的實現
    fn  function            (i: i32) -&gt; i32 { i + 1 }

    // 閉包是匿名的，這裡我們將它們綁定到引用。
    // 類型標註和函數的一樣，不過類型標註和使用 `{}` 來圍住函數體都是可選的。
    // 這些匿名函數（nameless function）被賦值給合適地命名的變量。
    let closure_annotated = |i: i32| -&gt; i32 { i + 1 };
    let closure_inferred  = |i     |          i + 1  ;

    // 譯註：將閉包綁定到引用的說法可能不準。
    // 據[語言參考](https://doc.rust-lang.org/beta/reference/types.html#closure-types)
    // 閉包表達式產生的類型就是 “閉包類型”，不屬於引用類型，而且確實無法對上面兩個
    // `closure_xxx` 變量解引用。

    let i = 1;
    // 調用函數和閉包。
    println!(&quot;function: {}&quot;, function(i));
    println!(&quot;closure_annotated: {}&quot;, closure_annotated(i));
    println!(&quot;closure_inferred: {}&quot;, closure_inferred(i));

    // 沒有參數的閉包，返回一個 `i32` 類型。
    // 返回類型是自動推導的。
    let one = || 1;
    println!(&quot;closure returning one: {}&quot;, one());
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="捕獲"><a class="header" href="#捕獲">捕獲</a></h1>
<p>閉包本質上很靈活，能做功能要求的事情，使閉包在沒有類型標註的情況下運行。這使得捕獲（capture）能夠靈活地適應用例，既可移動（move），又可借用（borrow）。閉包可以通過以下方式捕獲變量：</p>
<ul>
<li>通過引用：<code>&amp;T</code></li>
<li>通過可變引用：<code>&amp;mut T</code></li>
<li>通過值：<code>T</code></li>
</ul>
<p>閉包優先通過引用來捕獲變量，並且僅在需要時使用其他方式。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    use std::mem;

    let color = String::from(&quot;green&quot;);

    // 這個閉包打印 `color`。它會立即借用（通過引用，`&amp;`）`color` 並將該借用和
    // 閉包本身存儲到 `print` 變量中。`color` 會一直保持被借用狀態直到
    // `print` 離開作用域。
    //
    // `println!` 只需傳引用就能使用，而這個閉包捕獲的也是變量的引用，因此無需
    // 進一步處理就可以使用 `println!`。
    let print = || println!(&quot;`color`: {}&quot;, color);

    // 使用借用來調用閉包 `color`。
    print();

    // `color` 可再次被不可變借用，因為閉包只持有一個指向 `color` 的不可變引用。
    let _reborrow = &amp;color;
    print();

    // 在最後使用 `print` 之後，移動或重新借用都是允許的。
    let _color_moved = color;

    let mut count = 0;
    // 這個閉包使 `count` 值增加。要做到這點，它需要得到 `&amp;mut count` 或者
    // `count` 本身，但 `&amp;mut count` 的要求沒那麼嚴格，所以我們採取這種方式。
    // 該閉包立即借用 `count`。
    //
    // `inc` 前面需要加上 `mut`，因為閉包裡存儲著一個 `&amp;mut` 變量。調用閉包時，
    // 該變量的變化就意味著閉包內部發生了變化。因此閉包需要是可變的。
    let mut inc = || {
        count += 1;
        println!(&quot;`count`: {}&quot;, count);
    };

    // 使用可變借用調用閉包
    inc();

    // 因為之後調用閉包，所以仍然可變借用 `count`
    // 試圖重新借用將導致錯誤
    // let _reborrow = &amp;count;
    // ^ 試一試：將此行註釋去掉。
    inc();

    // 閉包不再借用 `&amp;mut count`，因此可以正確地重新借用
    let _count_reborrowed = &amp;mut count;

    // 不可複製類型（non-copy type）。
    let movable = Box::new(3);

    // `mem::drop` 要求 `T` 類型本身，所以閉包將會捕獲變量的值。這種情況下，
    // 可複製類型將會複製給閉包，從而原始值不受影響。不可複製類型必須移動
    // （move）到閉包中，因而 `movable` 變量在這裡立即移動到了閉包中。
    let consume = || {
        println!(&quot;`movable`: {:?}&quot;, movable);
        mem::drop(movable);
    };

    // `consume` 消耗了該變量，所以該閉包只能調用一次。
    consume();
    //consume();
    // ^ 試一試：將此行註釋去掉。
}
</code></pre></pre>
<p>在豎線 <code>|</code> 之前使用 <code>move</code> 會強制閉包取得被捕獲變量的所有權：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // `Vec` 在語義上是不可複製的。
    let haystack = vec![1, 2, 3];

    let contains = move |needle| haystack.contains(needle);

    println!(&quot;{}&quot;, contains(&amp;1));
    println!(&quot;{}&quot;, contains(&amp;4));

    //println!(&quot;There're {} elements in vec&quot;, haystack.len());
    // ^ 取消上面一行的註釋將導致編譯時錯誤，因為借用檢查不允許在變量被移動走
    // 之後繼續使用它。

    // 在閉包的簽名中刪除 `move` 會導致閉包以不可變方式借用 `haystack`，因此之後
    // `haystack` 仍然可用，取消上面的註釋也不會導致錯誤。
}
</code></pre></pre>
<h3 id="參見-22"><a class="header" href="#參見-22">參見：</a></h3>
<p><a href="fn/closures/../../std/box.html"><code>Box</code></a> 和 <a href="https://rustwiki.org/zh-CN/std/mem/fn.drop.html"><code>std::mem::drop</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="作為輸入參數"><a class="header" href="#作為輸入參數">作為輸入參數</a></h1>
<p>雖然 Rust 無需類型說明就能在大多數時候完成變量捕獲，但在編寫函數時，這種模糊寫法是不允許的。當以閉包作為輸入參數時，必須指出閉包的完整類型，它是通過使用以下 <code>trait</code> 中的一種來指定的。其受限制程度按以下順序遞減：</p>
<ul>
<li><code>Fn</code>：表示捕獲方式為通過引用（<code>&amp;T</code>）的閉包</li>
<li><code>FnMut</code>：表示捕獲方式為通過可變引用（<code>&amp;mut T</code>）的閉包</li>
<li><code>FnOnce</code>：表示捕獲方式為通過值（<code>T</code>）的閉包</li>
</ul>
<blockquote>
<p>譯註：順序之所以是這樣，是因為 <code>&amp;T</code> 只是獲取了不可變的引用，<code>&amp;mut T</code> 則可以改變變量，<code>T</code> 則是拿到了變量的所有權而非借用。</p>
</blockquote>
<p>對閉包所要捕獲的每個變量，編譯器都將以限制最少的方式來捕獲。</p>
<blockquote>
<p>譯註：這句可能說得不對，事實上是在滿足使用需求的前提下儘量以限制最多的方式捕獲。</p>
</blockquote>
<p>例如用一個類型說明為 <code>FnOnce</code> 的閉包作為參數。這說明閉包可能採取 <code>&amp;T</code>，<code>&amp;mut T</code> 或 <code>T</code> 中的一種捕獲方式，但編譯器最終是根據所捕獲變量在閉包裡的使用情況決定捕獲方式。</p>
<p>這是因為如果能以移動的方式捕獲變量，則閉包也有能力使用其他方式借用變量。注意反過來就不再成立：如果參數的類型說明是 <code>Fn</code>，那麼不允許該閉包通過 <code>&amp;mut T</code> 或 <code>T</code> 捕獲變量。</p>
<p>在下面的例子中，試著分別用一用 <code>Fn</code>、<code>FnMut</code> 和 <code>FnOnce</code>，看看會發生什麼：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 該函數將閉包作為參數並調用它。
fn apply&lt;F&gt;(f: F) where
    // 閉包沒有輸入值和返回值。
    F: FnOnce() {
    // ^ 試一試：將 `FnOnce` 換成 `Fn` 或 `FnMut`。

    f();
}

// 輸入閉包，返回一個 `i32` 整型的函數。
fn apply_to_3&lt;F&gt;(f: F) -&gt; i32 where
    // 閉包處理一個 `i32` 整型並返回一個 `i32` 整型。
    F: Fn(i32) -&gt; i32 {

    f(3)
}

fn main() {
    use std::mem;

    let greeting = &quot;hello&quot;;
    // 不可複製的類型。
    // `to_owned` 從借用的數據創建有所有權的數據。
    let mut farewell = &quot;goodbye&quot;.to_owned();

    // 捕獲 2 個變量：通過引用捕獲 `greeting`，通過值捕獲 `farewell`。
    let diary = || {
        // `greeting` 通過引用捕獲，故需要閉包是 `Fn`。
        println!(&quot;I said {}.&quot;, greeting);

        // 下文改變了 `farewell` ，因而要求閉包通過可變引用來捕獲它。
        // 現在需要 `FnMut`。
        farewell.push_str(&quot;!!!&quot;);
        println!(&quot;Then I screamed {}.&quot;, farewell);
        println!(&quot;Now I can sleep. zzzzz&quot;);

        // 手動調用 drop 又要求閉包通過值獲取 `farewell`。
        // 現在需要 `FnOnce`。
        mem::drop(farewell);
    };

    // 以閉包作為參數，調用函數 `apply`。
    apply(diary);

    // 閉包 `double` 滿足 `apply_to_3` 的 trait 約束。
    let double = |x| 2 * x;

    println!(&quot;3 doubled: {}&quot;, apply_to_3(double));
}
</code></pre></pre>
<h3 id="參見-23"><a class="header" href="#參見-23">參見：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/mem/fn.drop.html"><code>std::mem::drop</code></a>, <a href="https://rustwiki.org/zh-CN/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://rustwiki.org/zh-CN/std/ops/trait.FnMut.html"><code>FnMut</code></a>, 和 <a href="https://rustwiki.org/zh-CN/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="類型匿名"><a class="header" href="#類型匿名">類型匿名</a></h1>
<p>閉包從周圍的作用域中捕獲變量是簡單明瞭的。這樣會有某些後果嗎？確實有。觀察一下使用閉包作為函數參數，這要求閉包是<a href="fn/closures/../../generics.html">泛型</a>的，閉包定義的方式決定了這是必要的。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `F` 必須是泛型的。
fn apply&lt;F&gt;(f: F) where
    F: FnOnce() {
    f();
}
<span class="boring">}
</span></code></pre></pre>
<p>當閉包被定義，編譯器會隱式地創建一個匿名類型的結構體，用以儲存閉包捕獲的變量，同時為這個未知類型的結構體實現函數功能，通過 <code>Fn</code>、<code>FnMut</code> 或 <code>FnOnce</code> 三種 <code>trait</code> 中的一種。</p>
<p>若使用閉包作為函數參數，由於這個結構體的類型未知，任何的用法都要求是泛型的。然而，使用未限定類型的參數 <code>&lt;T&gt;</code> 過於不明確，並且是不允許的。事實上，指明為該結構體實現的是 <code>Fn</code>、<code>FnMut</code>、或 <code>FnOnce</code> 中的哪種 <code>trait</code>，對於約束該結構體的類型而言就已經足夠了。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// `F` 必須為一個沒有輸入參數和返回值的閉包實現 `Fn`，這和對 `print` 的
// 要求恰好一樣。
fn apply&lt;F&gt;(f: F) where
    F: Fn() {
    f();
}

fn main() {
    let x = 7;

    // 捕獲 `x` 到匿名類型中，併為它實現 `Fn`。
    // 將閉包存儲到 `print` 中。
    let print = || println!(&quot;{}&quot;, x);

    apply(print);
}
</code></pre></pre>
<h3 id="參見-24"><a class="header" href="#參見-24">參見：</a></h3>
<p><a href="https://huonw.github.io/blog/2015/05/finding-closure-in-rust/">詳盡分析</a>, <a href="https://rustwiki.org/zh-CN/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://rustwiki.org/zh-CN/std/ops/trait.FnMut.html"><code>FnMut</code></a>,
和 <a href="https://rustwiki.org/zh-CN/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="輸入函數"><a class="header" href="#輸入函數">輸入函數</a></h1>
<p>既然閉包可以作為參數，你很可能想知道函數是否也可以呢。確實可以！如果你聲明一個接受閉包作為參數的函數，那麼任何滿足該閉包的 trait 約束的函數都可以作為其參數。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 定義一個函數，可以接受一個由 `Fn` 限定的泛型 `F` 參數並調用它。
fn call_me&lt;F: Fn()&gt;(f: F) {
    f()
}

// 定義一個滿足 `Fn` 約束的封裝函數（wrapper function）。
fn function() {
    println!(&quot;I'm a function!&quot;);
}

fn main() {
    // 定義一個滿足 `Fn` 約束的閉包。
    let closure = || println!(&quot;I'm a closure!&quot;);
    
    call_me(closure);
    call_me(function);
}
</code></pre></pre>
<p>多說一句，<code>Fn</code>、<code>FnMut</code> 和 <code>FnOnce</code> 這些 <code>trait</code> 明確了閉包如何從周圍的作用域中捕獲變量。</p>
<h3 id="參見-25"><a class="header" href="#參見-25">參見：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://rustwiki.org/zh-CN/std/ops/trait.FnMut.html"><code>FnMut</code></a>, 和 <a href="https://rustwiki.org/zh-CN/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="作為輸出參數"><a class="header" href="#作為輸出參數">作為輸出參數</a></h1>
<p>閉包作為輸入參數是可能的，所以返回閉包作為輸出參數（output parameter）也應該是可能的。然而返回閉包類型會有問題，因為目前 Rust 只支持返回具體（非泛型）的類型。按照定義，匿名的閉包的類型是未知的，所以只有使用<code>impl Trait</code>才能返回一個閉包。</p>
<p>返回閉包的有效特徵是：</p>
<ul>
<li><code>Fn</code></li>
<li><code>FnMut</code></li>
<li><code>FnOnce</code></li>
</ul>
<p>除此之外，還必須使用 <code>move</code> 關鍵字，它表明所有的捕獲都是通過值進行的。這是必須的，因為在函數退出時，任何通過引用的捕獲都被丟棄，在閉包中留下無效的引用。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn create_fn() -&gt; impl Fn() {
    let text = &quot;Fn&quot;.to_owned();

    move || println!(&quot;This is a: {}&quot;, text)
}

fn create_fnmut() -&gt; impl FnMut() {
    let text = &quot;FnMut&quot;.to_owned();

    move || println!(&quot;This is a: {}&quot;, text)
}

fn create_fnonce() -&gt; impl FnOnce() {
    let text = &quot;FnOnce&quot;.to_owned();
    
    move || println!(&quot;This is a: {}&quot;, text)
}

fn main() {
    let fn_plain = create_fn();
    let mut fn_mut = create_fnmut();
    let fn_once = create_fnonce();

    fn_plain();
    fn_mut();
    fn_once();
}

</code></pre></pre>
<h3 id="參見-26"><a class="header" href="#參見-26">參見：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://rustwiki.org/zh-CN/std/ops/trait.FnMut.html"><code>FnMut</code></a>, <a href="fn/closures/../../generics.html">泛型</a> 和 <a href="fn/closures/../../trait/impl_trait.html">impl Trait</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="std-中的例子"><a class="header" href="#std-中的例子"><code>std</code> 中的例子</a></h1>
<p>本小節列出幾個標準庫中使用閉包的例子。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iteratorany"><a class="header" href="#iteratorany">Iterator::any</a></h1>
<p><code>Iterator::any</code> 是一個函數，若傳給它一個迭代器（iterator），當其中任一元素滿足謂詞（predicate）時它將返回 <code>true</code>，否則返回 <code>false</code>（譯註：謂詞是閉包規定的， <code>true</code>/<code>false</code> 是閉包作用在元素上的返回值）。它的簽名如下：</p>
<pre><code class="language-rust ignore">pub trait Iterator {
    // 被迭代的類型。
    type Item;

    // `any` 接受 `&amp;mut self` 參數（譯註：回想一下，這是 `self: &amp;mut Self` 的簡寫）
    // 表明函數的調用者可以被借用和修改，但不會被消耗。
    fn any&lt;F&gt;(&amp;mut self, f: F) -&gt; bool where
        // `FnMut` 表示被捕獲的變量最多隻能被修改，而不能被消耗。
        // `Self::Item` 指明瞭被捕獲變量的類型（譯註：是迭代器的元素本身的類型）
        F: FnMut(Self::Item) -&gt; bool {}

        // 譯註：原文說 `Self::Item` 表明變量是通過值傳遞給閉包的，這是說錯了。
        // `FnMut` 就表示閉包只能通過引用捕獲變量。把類型為 `T` 的變量作為閉包
        // 的參數不代表閉包會拿走它的值，也可能是拿走它的引用。
}
</code></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let vec1 = vec![1, 2, 3];
    let vec2 = vec![4, 5, 6];

    // 對 vec 的 `iter()` 舉出 `&amp;i32`。（通過用 `&amp;x` 匹配）把它解構成 `i32`。
    // 譯註：注意 `any` 方法會自動地把 `vec.iter()` 舉出的迭代器的元素一個個地
    // 傳給閉包。因此閉包接收到的參數是 `&amp;i32` 類型的。
    println!(&quot;2 in vec1: {}&quot;, vec1.iter()     .any(|&amp;x| x == 2));
    // 對 vec 的 `into_iter()` 舉出 `i32` 類型。無需解構。
    println!(&quot;2 in vec2: {}&quot;, vec2.into_iter().any(| x| x == 2));

    let array1 = [1, 2, 3];
    let array2 = [4, 5, 6];

    // 對數組的 `iter()` 舉出 `&amp;i32`。
    println!(&quot;2 in array1: {}&quot;, array1.iter().any(|&amp;x| x == 2));
    // 對數組的 `into_iter()` 通常舉出 `&amp;i32`。
    println!(&quot;2 in array2: {}&quot;, array2.iter().any(|&amp;x| x == 2));
}
</code></pre></pre>
<h3 id="參見-27"><a class="header" href="#參見-27">參見：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/iter/trait.Iterator.html#method.any"><code>std::iter::Iterator::any</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iteratorfind"><a class="header" href="#iteratorfind">Iterator::find</a></h1>
<p><code>Iterator::find</code> 是一個函數，在傳給它一個迭代器時，將用 <code>Option</code> 類型返回第一個滿足謂詞的元素。它的簽名如下：</p>
<pre><code class="language-rust ignore">pub trait Iterator {
    // 被迭代的類型。
    type Item;

    // `find` 接受 `&amp;mut self` 參數，表明函數的調用者可以被借用和修改，
    // 但不會被消耗。
    fn find&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;Self::Item&gt; where
        // `FnMut` 表示被捕獲的變量最多隻能被修改，而不能被消耗。
        // `&amp;Self::Item` 指明瞭被捕獲變量的類型（譯註：是對迭代器元素的引用類型）
        P: FnMut(&amp;Self::Item) -&gt; bool {}
}
</code></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let vec1 = vec![1, 2, 3];
    let vec2 = vec![4, 5, 6];

    // 對 vec1 的 `iter()` 舉出 `&amp;i32` 類型。
    let mut iter = vec1.iter();
    // 對 vec2 的 `into_iter()` 舉出 `i32` 類型。
    let mut into_iter = vec2.into_iter();

    // 對迭代器舉出的元素的引用是 `&amp;&amp;i32` 類型。解構成 `i32` 類型。
    // 譯註：注意 `find` 方法會把迭代器元素的引用傳給閉包。迭代器元素自身
    // 是 `&amp;i32` 類型，所以傳給閉包的是 `&amp;&amp;i32` 類型。
    println!(&quot;Find 2 in vec1: {:?}&quot;, iter     .find(|&amp;&amp;x| x == 2));
    // 對迭代器舉出的元素的引用是 `&amp;i32` 類型。解構成 `i32` 類型。
    println!(&quot;Find 2 in vec2: {:?}&quot;, into_iter.find(| &amp;x| x == 2));

    let array1 = [1, 2, 3];
    let array2 = [4, 5, 6];

    // 對數組的 `iter()` 舉出 `&amp;i32`。
    println!(&quot;Find 2 in array1: {:?}&quot;, array1.iter()     .find(|&amp;&amp;x| x == 2));
    // 對數組的 `into_iter()` 通常舉出 `&amp;i32``。
    println!(&quot;Find 2 in array2: {:?}&quot;, array2.into_iter().find(|&amp;x| x == 2));
}
</code></pre></pre>
<h3 id="參見-28"><a class="header" href="#參見-28">參見：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/iter/trait.Iterator.html#method.find"><code>std::iter::Iterator::find</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高階函數"><a class="header" href="#高階函數">高階函數</a></h1>
<p>Rust 提供了高階函數（Higher Order Function, HOF），指那些輸入一個或多個函數，並且/或者產生一個更有用的函數的函數。HOF 和惰性迭代器（lazy iterator）給 Rust 帶來了函數式（functional）編程的風格。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn is_odd(n: u32) -&gt; bool {
    n % 2 == 1
}

fn main() {
    println!(&quot;Find the sum of all the squared odd numbers under 1000&quot;);
    let upper = 1000;

    // 命令式（imperative）的寫法
    // 聲明累加器變量
    let mut acc = 0;
    // 迭代：0，1, 2, ... 到無窮大
    for n in 0.. {
        // 數字的平方
        let n_squared = n * n;

        if n_squared &gt;= upper {
            // 若大於上限則退出循環
            break;
        } else if is_odd(n_squared) {
            // 如果是奇數就計數
            acc += n_squared;
        }
    }
    println!(&quot;imperative style: {}&quot;, acc);

    // 函數式的寫法
    let sum_of_squared_odd_numbers: u32 =
        (0..).map(|n| n * n)             // 所有自然數取平方
             .take_while(|&amp;n| n &lt; upper) // 取小於上限的
             .filter(|&amp;n| is_odd(n))     // 取奇數
             .fold(0, |sum, i| sum + i); // 最後加起來
    println!(&quot;functional style: {}&quot;, sum_of_squared_odd_numbers);
}
</code></pre></pre>
<p><a href="https://rustwiki.org/zh-CN/core/option/enum.Option.html">Option</a> 和 <a href="https://rustwiki.org/zh-CN/core/iter/trait.Iterator.html">迭代器</a> 都實現了不少高階函數。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="發散函數"><a class="header" href="#發散函數">發散函數</a></h1>
<p>發散函數（diverging function）絕不會返回。 它們使用 <code>!</code> 標記，這是一個空類型。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; ! {
    panic!(&quot;This call never returns.&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>和所有其他類型相反，這個類型無法實例化，因為此類型可能具有的所有可能值的集合為空。 注意，它與 <code>()</code> 類型不同，後者只有一個可能的值。</p>
<p>如下面例子，雖然返回值中沒有信息，但此函數會照常返回。</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn some_fn() {
    ()
}

fn main() {
    let a: () = some_fn();
    println!(&quot;This function returns and you can see this line.&quot;)
}
</code></pre></pre>
<p>下面這個函數相反，這個函數永遠不會將控制內容返回給調用者。</p>
<pre><code class="language-rust ignore">#![feature(never_type)]

fn main() {
    let x: ! = panic!(&quot;This call never returns.&quot;);
    println!(&quot;You will never see this line!&quot;);
}
</code></pre>
<p>雖然這看起來像是一個抽象的概念，但實際上這非常有用且方便。這種類型的主要優點是它可以被轉換為任何其他類型，從而可以在需要精確類型的地方使用，例如在 <code>match</code> 匹配分支。 這允許我們編寫如下代碼：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    fn sum_odd_numbers(up_to: u32) -&gt; u32 {
        let mut acc = 0;
        for i in 0..up_to {
            // 注意這個 match 表達式的返回值必須為 u32，
            // 因為 “addition” 變量是這個類型。
            let addition: u32 = match i%2 == 1 {
                // “i” 變量的類型為 u32，這毫無問題。
                true =&gt; i,
                // 另一方面，“continue” 表達式不返回 u32，但它仍然沒有問題，
                // 因為它永遠不會返回，因此不會違反匹配表達式的類型要求。
                false =&gt; continue,
            };
            acc += addition;
        }
        acc
    }
    println!(&quot;Sum of odd numbers up to 9 (excluding): {}&quot;, sum_odd_numbers(9));
}
</code></pre></pre>
<p>這也是永遠循環（如 <code>loop {}</code>）的函數（如網絡服務器）或終止進程的函數（如 <code>exit()</code>）的返回類型。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模塊"><a class="header" href="#模塊">模塊</a></h1>
<p>Rust 提供了一套強大的模塊（module）系統，可以將代碼按層次分成多個邏輯
單元（模塊），並管理這些模塊之間的可見性（公有（public）或私有（private））。</p>
<p>模塊是項（item）的集合，項可以是：函數，結構體，trait，<code>impl</code> 塊，甚至其它模塊。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="可見性"><a class="header" href="#可見性">可見性</a></h1>
<p>默認情況下，模塊中的項擁有私有的可見性（private visibility），不過可以加上
<code>pub</code> 修飾語來重載這一行為。模塊中只有公有的（public）項可以從模塊外的作用域
訪問。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 一個名為 `my_mod` 的模塊
mod my_mod {
    // 模塊中的項默認具有私有的可見性
    fn private_function() {
        println!(&quot;called `my_mod::private_function()`&quot;);
    }

    // 使用 `pub` 修飾語來改變默認可見性。
    pub fn function() {
        println!(&quot;called `my_mod::function()`&quot;);
    }

    // 在同一模塊中，項可以訪問其它項，即使它是私有的。
    pub fn indirect_access() {
        print!(&quot;called `my_mod::indirect_access()`, that\n&gt; &quot;);
        private_function();
    }

    // 模塊也可以嵌套
    pub mod nested {
        pub fn function() {
            println!(&quot;called `my_mod::nested::function()`&quot;);
        }

        #[allow(dead_code)]
        fn private_function() {
            println!(&quot;called `my_mod::nested::private_function()`&quot;);
        }

        // 使用 `pub(in path)` 語法定義的函數只在給定的路徑中可見。
        // `path` 必須是父模塊（parent module）或祖先模塊（ancestor module）
        pub(in crate::my_mod) fn public_function_in_my_mod() {
            print!(&quot;called `my_mod::nested::public_function_in_my_mod()`, that\n &gt; &quot;);
            public_function_in_nested()
        }

        // 使用 `pub(self)` 語法定義的函數則只在當前模塊中可見。
        pub(self) fn public_function_in_nested() {
            println!(&quot;called `my_mod::nested::public_function_in_nested&quot;);
        }

        // 使用 `pub(super)` 語法定義的函數只在父模塊中可見。
        pub(super) fn public_function_in_super_mod() {
            println!(&quot;called my_mod::nested::public_function_in_super_mod&quot;);
        }
    }

    pub fn call_public_function_in_my_mod() {
        print!(&quot;called `my_mod::call_public_funcion_in_my_mod()`, that\n&gt; &quot;);
        nested::public_function_in_my_mod();
        print!(&quot;&gt; &quot;);
        nested::public_function_in_super_mod();
    }

    // `pub(crate)` 使得函數只在當前 crate 中可見
    pub(crate) fn public_function_in_crate() {
        println!(&quot;called `my_mod::public_function_in_crate()&quot;);
    }

    // 嵌套模塊的可見性遵循相同的規則
    mod private_nested {
        #[allow(dead_code)]
        pub fn function() {
            println!(&quot;called `my_mod::private_nested::function()`&quot;);
        }
    }
}

fn function() {
    println!(&quot;called `function()`&quot;);
}

fn main() {
    // 模塊機制消除了相同名字的項之間的歧義。
    function();
    my_mod::function();

    // 公有項，包括嵌套模塊內的，都可以在父模塊外部訪問。
    my_mod::indirect_access();
    my_mod::nested::function();
    my_mod::call_public_function_in_my_mod();

    // pub(crate) 項可以在同一個 crate 中的任何地方訪問
    my_mod::public_function_in_crate();

    // pub(in path) 項只能在指定的模塊中訪問
    // 報錯！函數 `public_function_in_my_mod` 是私有的
    //my_mod::nested::public_function_in_my_mod();
    // 試一試 ^ 取消該行的註釋

    // 模塊的私有項不能直接訪問，即便它是嵌套在公有模塊內部的

    // 報錯！`private_function` 是私有的
    //my_mod::private_function();
    // 試一試 ^ 取消此行註釋

    // 報錯！`private_function` 是私有的
    //my_mod::nested::private_function();
    // 試一試 ^ 取消此行的註釋

    // Error! `private_nested` is a private module
    //my_mod::private_nested::function();
    // 試一試 ^ 取消此行的註釋
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="結構體的可見性"><a class="header" href="#結構體的可見性">結構體的可見性</a></h1>
<p>結構體的字段也是一個可見性的層次。字段默認擁有私有的可見性，也可以加上 <code>pub</code> 修
飾語來重載該行為。只有從結構體被定義的模塊之外訪問其字段時，這個可見性才會
起作用，其意義是隱藏信息（即封裝，encapsulation）。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">mod my {
    // 一個公有的結構體，帶有一個公有的字段（類型為泛型 `T`）
    pub struct OpenBox&lt;T&gt; {
        pub contents: T,
    }

    // 一個公有的結構體，帶有一個私有的字段（類型為泛型 `T`）    
    #[allow(dead_code)]
    pub struct ClosedBox&lt;T&gt; {
        contents: T,
    }

    impl&lt;T&gt; ClosedBox&lt;T&gt; {
        // 一個公有的構造器方法
        pub fn new(contents: T) -&gt; ClosedBox&lt;T&gt; {
            ClosedBox {
                contents: contents,
            }
        }
    }
}

fn main() {
    // 帶有公有字段的公有結構體，可以像平常一樣構造
    let open_box = my::OpenBox { contents: &quot;public information&quot; };

    // 並且它們的字段可以正常訪問到。
    println!(&quot;The open box contains: {}&quot;, open_box.contents);

    // 帶有私有字段的公有結構體不能使用字段名來構造。
    // 報錯！`ClosedBox` 含有私有字段。
    //let closed_box = my::ClosedBox { contents: &quot;classified information&quot; };
    // 試一試 ^ 取消此行註釋


    // 不過帶有私有字段的結構體可以使用公有的構造器來創建。
    let _closed_box = my::ClosedBox::new(&quot;classified information&quot;);

    // 並且一個結構體中的私有字段不能訪問到。
    // 報錯！`content` 字段是私有的。
    //println!(&quot;The closed box contains: {}&quot;, _closed_box.contents);
    // 試一試 ^ 取消此行註釋    

}
</code></pre></pre>
<h3 id="參見-29"><a class="header" href="#參見-29">參見：</a></h3>
<p><a href="mod/../generics.html">泛型</a> 和 <a href="mod/../fn/methods.html">方法</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-聲明"><a class="header" href="#use-聲明"><code>use</code> 聲明</a></h1>
<p><code>use</code> 聲明可以將一個完整的路徑綁定到一個新的名字，從而更容易訪問。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 將 `deeply::nested::function` 路徑綁定到 `other_function`。
use deeply::nested::function as other_function;

fn function() {
    println!(&quot;called `function()`&quot;);
}

mod deeply {
    pub mod nested {
        pub fn function() {
            println!(&quot;called `deeply::nested::function()`&quot;)
        }
    }
}

fn main() {
    // 更容易訪問 `deeply::nested::funcion`
    other_function();

    println!(&quot;Entering block&quot;);
    {
        // 這和 `use deeply::nested::function as function` 等價。
        // 此 `function()` 將遮蔽外部的同名函數。
        use deeply::nested::function;
        function();

        // `use` 綁定擁有局部作用域。在這個例子中，`function()`
        // 的遮蔽只存在在這個代碼塊中。
        println!(&quot;Leaving block&quot;);
    }

    function();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="super-和-self"><a class="header" href="#super-和-self"><code>super</code> 和 <code>self</code></a></h1>
<p>可以在路徑中使用 <code>super</code> （父級）和 <code>self</code>（自身）關鍵字，從而在訪問項時消除
歧義，以及防止不必要的路徑硬編碼。</p>
<pre><pre class="playground"><code class="language-rust editalbe edition2021">fn function() {
    println!(&quot;called `function()`&quot;);
}

mod cool {
    pub fn function() {
        println!(&quot;called `cool::function()`&quot;);
    }
}

mod my {
    fn function() {
        println!(&quot;called `my::function()`&quot;);
    }
    
    mod cool {
        pub fn function() {
            println!(&quot;called `my::cool::function()`&quot;);
        }
    }
    
    pub fn indirect_call() {
        // 讓我們從這個作用域中訪問所有名為 `function` 的函數！
        print!(&quot;called `my::indirect_call()`, that\n&gt; &quot;);
        
        // `self` 關鍵字表示當前的模塊作用域——在這個例子是 `my`。
        // 調用 `self::function()` 和直接調用 `function()` 都得到相同的結果，
        // 因為他們表示相同的函數。
        self::function();
        function();
        
        // 我們也可以使用 `self` 來訪問 `my` 內部的另一個模塊：
        self::cool::function();
        
        // `super` 關鍵字表示父作用域（在 `my` 模塊外面）。
        super::function();
        
        // 這將在 *crate* 作用域內綁定 `cool::function` 。
        // 在這個例子中，crate 作用域是最外面的作用域。
        {
            use crate::cool::function as root_function;
            root_function();
        }
    }
}

fn main() {
    my::indirect_call();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文件分層"><a class="header" href="#文件分層">文件分層</a></h1>
<p>模塊可以分配到文件/目錄的層次結構中。讓我們將《可見性》一節中
的<a href="mod/visibility.html">例子</a>的代碼拆分到多個文件中：</p>
<pre><code class="language-bash">$ tree .
.
|-- my
|   |-- inaccessible.rs
|   |-- mod.rs
|   `-- nested.rs
`-- split.rs
</code></pre>
<p><code>split.rs</code> 的內容：</p>
<pre><code class="language-rust ignore">// 此聲明將會查找名為 `my.rs` 或 `my/mod.rs` 的文件，並將該文件的內容放到
// 此作用域中一個名為 `my` 的模塊裡面。
mod my;

fn function() {
    println!(&quot;called `function()`&quot;);
}

fn main() {
    my::function();

    function();

    my::indirect_access();

    my::nested::function();
}
</code></pre>
<p><code>my/mod.rs</code> 的內容：</p>
<pre><code class="language-rust ignore">// 類似地，`mod inaccessible` 和 `mod nested` 將找到 `nested.rs` 和
// `inaccessible.rs` 文件，並在它們放到各自的模塊中。
mod inaccessible;
pub mod nested;

pub fn function() {
    println!(&quot;called `my::function()`&quot;);
}

fn private_function() {
    println!(&quot;called `my::private_function()`&quot;);
}

pub fn indirect_access() {
    print!(&quot;called `my::indirect_access()`, that\n&gt; &quot;);

    private_function();
}
</code></pre>
<p><code>my/nested.rs</code> 的內容：</p>
<pre><code class="language-rust ignore">pub fn function() {
    println!(&quot;called `my::nested::function()`&quot;);
}

#[allow(dead_code)]
fn private_function() {
    println!(&quot;called `my::nested::private_function()`&quot;);
}
</code></pre>
<p><code>my/inaccessible.rs</code> 的內容：</p>
<pre><code class="language-rust ignore">#[allow(dead_code)]
pub fn public_function() {
    println!(&quot;called `my::inaccessible::public_function()`&quot;);
}
</code></pre>
<p>我們看到代碼仍然正常運行，就和前面的一樣：</p>
<pre><code class="language-bash">$ rustc split.rs &amp;&amp; ./split
called `my::function()`
called `function()`
called `my::indirect_access()`, that
&gt; called `my::private_function()`
called `my::nested::function()`
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crate"><a class="header" href="#crate">crate</a></h1>
<p>crate（中文有 “包，包裝箱” 之意）是 Rust 的編譯單元。當調用 <code>rustc some_file.rs</code>
時，<code>some_file.rs</code> 被當作 <strong>crate 文件</strong>。如果 <code>some_file.rs</code> 裡面含有 <code>mod</code>
聲明，那麼模塊文件的內容將在編譯之前被插入 crate 文件的相應聲明處。換句話說，模
塊<strong>不會</strong>單獨被編譯，只有 crate 才會被編譯。</p>
<p>crate 可以編譯成二進制可執行文件（binary）或庫文件（library）。默認情況
下，<code>rustc</code> 將從 crate 產生二進制可執行文件。這種行為可以通過 <code>rustc</code> 的選項 <code>--crate-type</code>
重載。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="庫"><a class="header" href="#庫">庫</a></h1>
<p>讓我們創建一個庫，然後看看如何把它鏈接到另一個 crate。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub fn public_function() {
    println!(&quot;called rary's `public_function()`&quot;);
}

fn private_function() {
    println!(&quot;called rary's `private_function()`&quot;);
}

pub fn indirect_access() {
    print!(&quot;called rary's `indirect_access()`, that\n&gt; &quot;);

    private_function();
}
</code></pre></pre>
<pre><code class="language-bash">$ rustc --crate-type=lib rary.rs
$ ls lib*
library.rlib
</code></pre>
<p>默認情況下，庫會使用 crate 文件的名字，前面加上 “lib” 前綴，但這個默認名稱可以
使用 <a href="crates/../attribute/crate.html"><code>crate_name</code> 屬性</a> 覆蓋。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用庫"><a class="header" href="#使用庫">使用庫</a></h1>
<p>要將一個 crate 鏈接到上節新建的庫，可以使用 <code>rustc</code> 的 <code>--extern</code> 選項。然後將所有的物件導入到與庫名相同的模塊下。此模塊的操作通常與任何其他模塊相同。</p>
<pre><code class="language-rust ignore">// extern crate rary; // 在 Rust 2015 版或更早版本需要這個導入語句

fn main() {
    rary::public_function();

    // 報錯！ `private_function` 是私有的
    //rary::private_function();

    rary::indirect_access();
}
</code></pre>
<pre><code class="language-bash"># library.rlib 是已編譯好的庫的路徑，這裡假設它在同一目錄下：
$ rustc executable.rs --extern rary=library.rlib --edition=2018 &amp;&amp; ./executable 
called rary's `public_function()`
called rary's `indirect_access()`, that
&gt; called rary's `private_function()`
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo"><a class="header" href="#cargo">cargo</a></h1>
<p><code>cargo</code> 是官方的 Rust 包管理工具。 它有很多非常有用的功能來提高代碼質量和開發人員的開發效率！ 這些功能包括：</p>
<ul>
<li>依賴管理和與 <a href="https://crates.io">crates.io</a>（官方 Rust 包註冊服務）集成</li>
<li>方便的單元測試</li>
<li>方便的基準測試</li>
</ul>
<p>本章將介紹一些快速入門的基礎知識，不過你可以在 <a href="https://doc.rust-lang.org/cargo/">cargo 官方手冊</a>中找到詳細內容。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="依賴"><a class="header" href="#依賴">依賴</a></h1>
<p>大多數程序都會依賴於某些庫。如果你曾經手動管理過庫依賴，那麼你就知道這會帶來的極大的痛苦。幸運的是，Rust 的生態鏈標配 <code>cargo</code> 工具！<code>cargo</code> 可以管理項目的依賴關係。</p>
<p>下面創建一個新的 Rust 項目：</p>
<pre><code class="language-sh"># 二進制可執行文件
cargo new foo

# 或者庫
cargo new --lib foo
</code></pre>
<p>對於本章的其餘部分，我們選定創建的都是二進制可執行文件而不是庫，但所有的概念都是相同的。</p>
<p>完成上述命令後，將看到如下內容：</p>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<p><code>main.rs</code> 是新項目的入口源文件——這裡沒什麼新東西。 <code>Cargo.toml</code> 是本項目（<code>foo</code>）的 <code>cargo</code> 的配置文件。 瀏覽 <code>Cargo.toml</code> 文件，將看到類似以下的的內容：</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;mark&quot;]

[dependencies]
</code></pre>
<p><code>package</code> 下面的 <code>name</code> 字段表明項目的名稱。 如果您發佈 crate（後面將做更多介紹），那麼 <code>crates.io</code> 將使用此字段標明的名稱。 這也是編譯時輸出的二進制可執行文件的名稱。</p>
<p><code>version</code> 字段是使用<a href="https://semver.org/">語義版本控制</a>（Semantic
Versioning）的 crate 版本號。</p>
<p><code>authors</code> 字段表明發佈 crate 時的作者列表。</p>
<p><code>dependencies</code> 這部分可以讓你為項目添加依賴。</p>
<p>舉個例子，假設我們希望程序有一個很棒的命令行界面（command-line interface，CLI））。 你可以在 <a href="https://crates.io">crates.io</a>（官方的 Rust 包註冊服務）上找到很多很棒的 Rust 包。其中一個受歡迎的包是 <a href="https://crates.io/crates/clap">clap</a>（譯註：一個命令行參數的解析器）。在撰寫本文時，[clap] 最新發布的版本為 <code>2.27.1</code>。要在程序中添加依賴，我們可以很簡單地在 <code>Cargo.toml</code> 文件中的 <code>dependencies</code> 項後面將以下內容添加進來 ：<code>clap = &quot;2.27.1&quot;</code>。當然，在 <code>main.rs</code> 文件中寫上 <code>extern crate clap</code>，就和平常一樣。 就是這樣！你就可以在程序中開始使用 <code>clap</code> 了。</p>
<p><code>cargo</code> 還支持<a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">其他類型的依賴</a>。 下面是一個簡單的示例：</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;mark&quot;]

[dependencies]
clap = &quot;2.27.1&quot; # 來自 crates.io
rand = { git = &quot;https://github.com/rust-lang-nursery/rand&quot; } # 來自網上的倉庫
bar = { path = &quot;../bar&quot; } # 來自本地文件系統的路徑
</code></pre>
<p><code>cargo</code> 不僅僅是一個包依賴管理器。<code>Cargo.toml</code> 的所有可用配置選項都列在 <a href="https://doc.rust-lang.org/cargo/reference/manifest.html">格式規範</a>中。</p>
<p>要構建我們的項目，我們可以在項目目錄中的任何位置（包括子目錄！）執行 <code>cargo build</code>。我們也可以執行 <code>cargo run</code> 來構建和運行。請注意，這些命令將處理所有依賴，在需要時下載 crate，並構建所有內容，包括 crate。（請注意，它只重新構建尚未構建的內容，這和 <code>make</code> 類似）。</p>
<p>瞧！這裡的所有都和 <code>cargo</code> 有關！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="約定規範"><a class="header" href="#約定規範">約定規範</a></h1>
<p>在上一小節中，我們看到了以下目錄層次結構：</p>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<p>假設我們要在同一個項目中有兩個二進制可執行文件。 那要怎樣做呢？</p>
<p>很顯然，<code>cargo</code> 支持這一點。正如我們之前看到的，默認二進制名稱是 <code>main</code>，但可以通過將文件放在 <code>bin/</code> 目錄中來添加其他二進制可執行文件：</p>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    ├── main.rs
    └── bin
        └── my_other_bin.rs
</code></pre>
<p>為了使得 <code>cargo</code> 編譯或運行這個二進制可執行文件而不是默認或其他二進制可執行文件，我們只需給 <code>cargo</code> 增加一個參數 <code>--bin my_other_bin</code>，其中 <code>my_other_bin</code> 是我們想要使用的二進制可執行文件的名稱。</p>
<p>除了可添加其他二進制可執行文件外，<code>cargo</code> 還支持<a href="https://doc.rust-lang.org/cargo/guide/project-layout.html">更多功能</a>，如基準測試，測試和示例。</p>
<p>在下一節中，我們將更仔細地學習測試的內容。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="測試"><a class="header" href="#測試">測試</a></h1>
<p>我們知道測試是任何軟件不可缺少的一部分！Rust 對單元和集成測試提供一流的支持（參見《Rust 程序設計語言》中的關於<a href="https://rustwiki.org/zh-CN/book/ch11-00-testing.html">測試的章節</a>）。</p>
<p>通過上面鏈接的關於測試章節，我們看到了如何編寫單元測試和集成測試。在代碼目錄組織上，我們可以將單元測試放在需要測試的模塊中，並將集成測試放在源碼中 <code>tests/</code> 目錄中：</p>
<pre><code class="language-txt">foo
├── Cargo.toml
├── src
│   └── main.rs
└── tests
    ├── my_test.rs
    └── my_other_test.rs
</code></pre>
<p><code>tests</code> 目錄下的每個文件都是一個單獨的集成測試。</p>
<p><code>cargo</code> 很自然地提供了一種便捷的方法來運行所有測試！</p>
<pre><code class="language-sh">cargo test
</code></pre>
<p>你將會看到像這樣的輸出：</p>
<pre><code class="language-txt">$ cargo test
   Compiling blah v0.1.0 (file:///nobackup/blah)
    Finished dev [unoptimized + debuginfo] target(s) in 0.89 secs
     Running target/debug/deps/blah-d3b32b97275ec472

running 3 tests
test test_bar ... ok
test test_baz ... ok
test test_foo_bar ... ok
test test_foo ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>你還可以運行如下測試，其中名稱匹配一個模式：</p>
<pre><code class="language-sh">cargo test test_foo
</code></pre>
<pre><code class="language-txt">$ cargo test test_foo
   Compiling blah v0.1.0 (file:///nobackup/blah)
    Finished dev [unoptimized + debuginfo] target(s) in 0.35 secs
     Running target/debug/deps/blah-d3b32b97275ec472

running 2 tests
test test_foo ... ok
test test_foo_bar ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out
</code></pre>
<p>需要注意的一點是：<code>cargo</code> 可能同時進行多項測試，因此請確保它們不會相互競爭。例如，如果它們都輸出到文件，則應該將它們寫入不同的文件。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="構建腳本"><a class="header" href="#構建腳本">構建腳本</a></h1>
<p>有時使用 <code>cargo</code> 正常構建還是不夠的。也許你的 crate 在 cargo 成功編譯之前需要一些先決條件，比如代碼生成或者需要編譯的一些本地代碼。為了解決這個問題，我們構建了 cargo 可以運行的腳本。</p>
<p>要向包中添加構建腳本，可以在 <code>Cargo.toml</code> 中指定它，如下所示：</p>
<pre><code class="language-toml">[package]
...
build = &quot;build.rs&quot;
</code></pre>
<p>跟默認情況不同，這裡 cargo 將在項目目錄中優先查找 <code>build.rs</code> 文件。（本句採用意譯，英文原文為：Otherwise Cargo will look for a <code>build.rs</code> file in the project directory by default.）</p>
<h2 id="怎麼使用構建腳本"><a class="header" href="#怎麼使用構建腳本">怎麼使用構建腳本</a></h2>
<p>構建腳本只是另一個 Rust 文件，此文件將在編譯包中的任何其他內容之前，優先進行編譯和調用。 因此，此文件可實現滿足 crate 的先決條件。</p>
<p>cargo 通過<a href="https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts">此處指定</a>的可以使用的環境變量為腳本提供輸入。（英文原文：Cargo provides the script with inputs via environment variables <a href="https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts">specified
here</a> that can be used.）</p>
<p>此腳本通過 stdout （標準輸出）提供輸出。打印的所有行都寫入到 <code>target/debug/build/&lt;pkg&gt;/output</code>。另外，以 <code>cargo:</code> 為前綴的行將由 cargo 直接解析，因此可用於定義包編譯的參數。</p>
<p>有關進一步的說明和示例，請閱讀 <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">cargo 規定說明文檔</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="屬性"><a class="header" href="#屬性">屬性</a></h1>
<p>屬性是應用於某些模塊、crate 或項的元數據（metadata）。這元數據可以用來：</p>
<!-- TODO: Link these to their respective examples -->
<ul>
<li><a href="./attribute/cfg.html">條件編譯代碼</a></li>
<li><a href="./attribute/crate.html">設置 crate 名稱、版本和類型（二進制文件或庫）</a></li>
<li>禁用 <a href="https://en.wikipedia.org/wiki/Lint_%28software%29">lint</a> （警告）</li>
<li>啟用編譯器的特性（宏、全局導入（glob import）等）</li>
<li>鏈接到一個非 Rust 語言的庫</li>
<li>標記函數作為單元測試</li>
<li>標記函數作為基準測試的某個部分</li>
</ul>
<p>當屬性作用於整個 crate 時，它們的語法為 <code>#![crate_attribute]</code>，當它們用於模塊
或項時，語法為 <code>#[item_attribute]</code>（注意少了感嘆號 <code>!</code>）。</p>
<p>屬性可以接受參數，有不同的語法形式：</p>
<ul>
<li><code>#[attribute = &quot;value&quot;]</code></li>
<li><code>#[attribute(key = &quot;value&quot;)]</code></li>
<li><code>#[attribute(value)]</code></li>
</ul>
<p>屬性可以多個值，它們可以分開到多行中：</p>
<pre><code class="language-rust ignore">#[attribute(value, value2)]

#[attribute(value, value2, value3,
            value4, value5)]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="死代碼-dead_code"><a class="header" href="#死代碼-dead_code">死代碼 <code>dead_code</code></a></h1>
<p>編譯器提供了 <code>dead_code</code>（死代碼，無效代碼）<a href="https://en.wikipedia.org/wiki/Lint_%28software%29"><em>lint</em></a>，這會對未使用的函數
產生警告。可以用一個<strong>屬性</strong>來禁用這個 lint。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn used_function() {}

// `#[allow(dead_code)]` 屬性可以禁用 `dead_code` lint
#[allow(dead_code)]
fn unused_function() {}

fn noisy_unused_function() {}
// 改正 ^ 增加一個屬性來消除警告

fn main() {
    used_function();
}
</code></pre></pre>
<p>注意在實際程序中，需要將死代碼清除掉。由於本書的例子是交互性的，因而其中需要
允許一些死代碼的出現。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crate-1"><a class="header" href="#crate-1"><code>crate</code></a></h1>
<p><code>crate_type</code> 屬性可以告知編譯器 crate 是一個二進制的可執行文件還是一個
庫（甚至是哪種類型的庫），<code>crate_name</code> 屬性可以設定 crate 的名稱。</p>
<p>不過，一定要注意在使用 cargo 時，這兩種類型時都<strong>沒有</strong>作用。由於大多數 Rust
工程都使用 cargo，這意味著 <code>crate_type</code> 和 <code>crate_name</code> 的作用事實上很有限。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 這個 crate 是一個庫文件
#![crate_type = &quot;lib&quot;]
// 庫的名稱為 “rary”
#![crate_name = &quot;rary&quot;]

pub fn public_function() {
    println!(&quot;called rary's `public_function()`&quot;);
}

fn private_function() {
    println!(&quot;called rary's `private_function()`&quot;);
}

pub fn indirect_access() {
    print!(&quot;called rary's `indirect_access()`, that\n&gt; &quot;);

    private_function();
}
</code></pre></pre>
<p>當用到 <code>crate_type</code> 屬性時，就不再需要給 <code>rustc</code> 命令加上 <code>--crate-type</code> 標記。</p>
<pre><code class="language-bash">$ rustc lib.rs
$ ls lib*
library.rlib
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cfg"><a class="header" href="#cfg"><code>cfg</code></a></h1>
<p>條件編譯可能通過兩種不同的操作符實現：</p>
<ul>
<li><code>cfg</code> 屬性：在屬性位置中使用 <code>#[cfg(...)]</code></li>
<li><code>cfg!</code> 宏：在布爾表達式中使用 <code>cfg!(...)</code></li>
</ul>
<p>兩種形式使用的參數語法都相同。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 這個函數僅當目標系統是 Linux 的時候才會編譯
#[cfg(target_os = &quot;linux&quot;)]
fn are_you_on_linux() {
    println!(&quot;You are running linux!&quot;)
}

// 而這個函數僅當目標系統 **不是** Linux 時才會編譯
#[cfg(not(target_os = &quot;linux&quot;))]
fn are_you_on_linux() {
    println!(&quot;You are *not* running linux!&quot;)
}

fn main() {
    are_you_on_linux();
    
    println!(&quot;Are you sure?&quot;);
    if cfg!(target_os = &quot;linux&quot;) {
        println!(&quot;Yes. It's definitely linux!&quot;);
    } else {
        println!(&quot;Yes. It's definitely *not* linux!&quot;);
    }
}
</code></pre></pre>
<h3 id="參見-30"><a class="header" href="#參見-30">參見：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/reference/conditional-compilation.html">引用</a>, <a href="https://rustwiki.org/zh-CN/std/macro.cfg!.html"><code>cfg!</code></a>, 和 <a href="attribute/../macros.html">宏</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自定義條件"><a class="header" href="#自定義條件">自定義條件</a></h1>
<p>有部分條件如 <code>target_os</code> 是由 <code>rustc</code> 隱式地提供的，但是自定義條件必須使用
<code>--cfg</code> 標記來傳給 <code>rustc</code>。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">#[cfg(some_condition)]
fn conditional_function() {
    println!(&quot;condition met!&quot;)
}

fn main() {
    conditional_function();
}
</code></pre></pre>
<p>試試不使用自定義的 <code>cfg</code> 標記會發生什麼：</p>
<pre><code class="language-bash">$ rustc custom.rs &amp;&amp; ./custom
No such file or directory (os error 2)
</code></pre>
<p>使用自定義的 <code>cfg</code> 標記：</p>
<pre><code class="language-bash">$ rustc --cfg some_condition custom.rs &amp;&amp; ./custom
condition met!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型"><a class="header" href="#泛型">泛型</a></h1>
<p><strong>泛型</strong>（generic）是關於泛化類型和函數功能，以擴大其適用範圍的話題。泛型極大地
減少了代碼的重複，但它自身的語法很要求細心。也就是說，採用泛型意味著仔細地指定
泛型類型具體化時，什麼樣的具體類型是合法的。泛型最簡單和常用的用法是用於類型參數。</p>
<blockquote>
<p>譯註：定義泛型類型或泛型函數之類的東西時，我們會用 <code>&lt;A&gt;</code> 或者 <code>&lt;T&gt;</code> 這類標記
作為類型的代號，就像函數的形參一樣。在使用時，為把 <code>&lt;A&gt;</code>、<code>&lt;T&gt;</code> 具體化，我們
會把類型說明像實參一樣使用，像是 <code>&lt;i32&gt;</code> 這樣。這兩種把（泛型的或具體的）類型
當作參數的用法就是<strong>類型參數</strong>。</p>
</blockquote>
<p>泛型的類型參數是使用尖括號和<a href="https://en.wikipedia.org/wiki/CamelCase">大駝峰命名</a>的名稱：<code>&lt;Aaa, Bbb, ...&gt;</code>
來指定的。泛型類型參數一般用 <code>&lt;T&gt;</code> 來表示。在 Rust 中，“泛型的” 除了表示
類型，還表示可以接受一個或多個泛型類型參數 <code>&lt;T&gt;</code> 的任何內容。任何用泛型類型參數
表示的類型都是泛型，其他的類型都是具體（非泛型）類型。</p>
<p>例如定義一個名為 <code>foo</code> 的 <strong>泛型函數</strong>，它可接受類型為 <code>T</code> 的任何參數 <code>arg</code>：</p>
<pre><code class="language-rust ignore">fn foo&lt;T&gt;(arg: T) { ... }
</code></pre>
<p>因為我們使用了泛型類型參數 <code>&lt;T&gt;</code>，所以這裡的 <code>(arg: T)</code> 中的 <code>T</code> 就是泛型
類型。即使 <code>T</code> 在之前被定義為 <code>struct</code>，這裡的 <code>T</code> 仍然代表泛型。</p>
<p>下面例子展示了泛型語法的使用：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 一個具體類型 `A`。
struct A;

// 在定義類型 `Single` 時，第一次使用類型 `A` 之前沒有寫 `&lt;A&gt;`。
// 因此，`Single` 是個具體類型，`A` 取上面的定義。
struct Single(A);
//            ^ 這裡是 `Single` 對類型 `A` 的第一次使用。

// 此處 `&lt;T&gt;` 在第一次使用 `T` 前出現，所以 `SingleGen` 是一個泛型類型。
// 因為 `T` 是泛型的，所以它可以是任何類型，包括在上面定義的具體類型 `A`。
struct SingleGen&lt;T&gt;(T);

fn main() {
    // `Single` 是具體類型，並且顯式地使用類型 `A`。
    let _s = Single(A);
    
    // 創建一個 `SingleGen&lt;char&gt;` 類型的變量 `_char`，並令其值為 `SingleGen('a')`
    // 這裡的 `SingleGen` 的類型參數是顯式指定的。
    let _char: SingleGen&lt;char&gt; = SingleGen('a');

    // `SingleGen` 的類型參數也可以隱式地指定。
    let _t    = SingleGen(A); // 使用在上面定義的 `A`。
    let _i32  = SingleGen(6); // 使用 `i32` 類型。
    let _char = SingleGen('a'); // 使用 `char`。
}
</code></pre></pre>
<h3 id="參見-31"><a class="header" href="#參見-31">參見：</a></h3>
<p><a href="custom_types/structs.html"><code>struct</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函數-1"><a class="header" href="#函數-1">函數</a></h1>
<p>同樣的規則也適用於函數：在使用類型 <code>T</code> 前給出 <code>&lt;T&gt;</code>，那麼 <code>T</code> 就變成了泛型。</p>
<p>調用泛型函數有時需要顯式地指明類型參量。這可能是因為調用了返回類型是泛型的
函數，或者編譯器沒有足夠的信息來推斷類型參數。</p>
<p>調用函數時，使用顯式指定的類型參數會像是這樣：<code>fun::&lt;A, B, ...&gt;()</code>。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct A;          // 具體類型 `A`。
struct S(A);       // 具體類型 `S`。
struct SGen&lt;T&gt;(T); // 泛型類型 `SGen`。

// 下面全部函數都得到了變量的所有權，並立即使之離開作用域，將變量釋放。

// 定義一個函數 `reg_fn`，接受一個 `S` 類型的參數 `_s`。
// 因為沒有 `&lt;T&gt;` 這樣的泛型類型參數，所以這不是泛型函數。
fn reg_fn(_s: S) {}

// 定義一個函數 `gen_spec_t`，接受一個 `SGen&lt;A&gt;` 類型的參數 `_s`。
// `SGen&lt;&gt;` 顯式地接受了類型參數 `A`，且在 `gen_spec_t` 中，`A` 沒有被用作
// 泛型類型參數，所以函數不是泛型的。
fn gen_spec_t(_s: SGen&lt;A&gt;) {}

// 定義一個函數 `gen_spec_i32`，接受一個 `SGen&lt;i32&gt;` 類型的參數 `_s`。
// `SGen&lt;&gt;` 顯式地接受了類型參量 `i32`，而 `i32` 是一個具體類型。
// 由於 `i32` 不是一個泛型類型，所以這個函數也不是泛型的。
fn gen_spec_i32(_s: SGen&lt;i32&gt;) {}

// 定義一個函數 `generic`，接受一個 `SGen&lt;T&gt;` 類型的參數 `_s`。
// 因為 `SGen&lt;T&gt;` 之前有 `&lt;T&gt;`，所以這個函數是關於 `T` 的泛型函數。
fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) {}

fn main() {
    // 使用非泛型函數
    reg_fn(S(A));          // 具體類型。
    gen_spec_t(SGen(A));   // 隱式地指定類型參數 `A`。
    gen_spec_i32(SGen(6)); // 隱式地指定類型參數 `i32`。

    // 為 `generic()` 顯式地指定類型參數 `char`。
    generic::&lt;char&gt;(SGen('a'));

    // 為 `generic()` 隱式地指定類型參數 `char`。
    generic(SGen('c'));
}
</code></pre></pre>
<h3 id="參見-32"><a class="header" href="#參見-32">參見：</a></h3>
<p><a href="generics/../fn.html">函數</a> 和 <a href="generics/../custom_types/structs.html"><code>structs</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="實現"><a class="header" href="#實現">實現</a></h1>
<p>和函數類似，<code>impl</code> 塊要想實現泛型，也需要很仔細。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S; // 具體類型 `S`
struct GenericVal&lt;T&gt;(T,); // 泛型類型 `GenericVal`

// GenericVal 的 `impl`，此處我們顯式地指定了類型參數：
impl GenericVal&lt;f32&gt; {} // 指定 `f32` 類型
impl GenericVal&lt;S&gt; {} // 指定為上面定義的 `S`

// `&lt;T&gt;` 必須在類型之前寫出來，以使類型 `T` 代表泛型。
impl &lt;T&gt; GenericVal&lt;T&gt; {}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Val {
    val: f64
}

struct GenVal&lt;T&gt;{
    gen_val: T
}

// Val 的 `impl`
impl Val {
    fn value(&amp;self) -&gt; &amp;f64 { &amp;self.val }
}

// GenVal 的 `impl`，指定 `T` 是泛型類型
impl &lt;T&gt; GenVal&lt;T&gt; {
    fn value(&amp;self) -&gt; &amp;T { &amp;self.gen_val }
}

fn main() {
    let x = Val { val: 3.0 };
    let y = GenVal { gen_val: 3i32 };
    
    println!(&quot;{}, {}&quot;, x.value(), y.value());
}
</code></pre></pre>
<h3 id="參見-33"><a class="header" href="#參見-33">參見：</a></h3>
<p><a href="generics/../scope/lifetime/fn.html">返回引用的函數</a>, <a href="generics/../fn/methods.html"><code>impl</code></a>, 和 <a href="generics/../custom_types/structs.html"><code>struct</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait"><a class="header" href="#trait">trait</a></h1>
<p>當然 <code>trait</code> 也可以是泛型的。我們在這裡定義了一個 <code>trait</code>，它把 <code>Drop</code> <code>trait</code>
作為泛型方法實現了，可以 <code>drop</code>（丟棄）調用者本身和一個輸入參數。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 不可複製的類型。
struct Empty;
struct Null;

// `T` 的泛型 trait。
trait DoubleDrop&lt;T&gt; {
    // 定義一個調用者的方法，接受一個額外的參數 `T`，但不對它做任何事。
    fn double_drop(self, _: T);
}

// 對泛型的調用者類型 `U` 和任何泛型類型 `T` 實現 `DoubleDrop&lt;T&gt;` 。
impl&lt;T, U&gt; DoubleDrop&lt;T&gt; for U {
    // 此方法獲得兩個傳入參數的所有權，並釋放它們。
    fn double_drop(self, _: T) {}
}

fn main() {
    let empty = Empty;
    let null  = Null;

    // 釋放 `empty` 和 `null`。
    empty.double_drop(null);

    //empty;
    //null;
    // ^ 試一試：去掉這兩行的註釋。
}
</code></pre></pre>
<h3 id="參見-34"><a class="header" href="#參見-34">參見：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/ops/trait.Drop.html"><code>Drop</code></a>, <a href="generics/../custom_types/structs.html"><code>struct</code></a>, 和 <a href="generics/../trait.html"><code>trait</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="約束"><a class="header" href="#約束">約束</a></h1>
<p>在使用泛型時，類型參數常常必須使用 trait 作為<strong>約束</strong>（bound）來明確規定
類型應實現哪些功能。例如下面的例子用到了 <code>Display</code> trait 來打印，所以它用
<code>Display</code> 來約束 <code>T</code>，也就是說 <code>T</code> <strong>必須</strong>實現 <code>Display</code>。</p>
<pre><code class="language-rust ignore">// 定義一個函數 `printer`，接受一個類型為泛型 `T` 的參數，
// 其中 `T` 必須實現 `Display` trait。
fn printer&lt;T: Display&gt;(t: T) {
    println!(&quot;{}&quot;, t);
}
</code></pre>
<p>約束把泛型類型限制為符合約束的類型。請看：</p>
<pre><code class="language-rust ignore">struct S&lt;T: Display&gt;(T);

// 報錯！`Vec&lt;T&gt;` 未實現 `Display`。此次泛型具體化失敗。
let s = S(vec![1]);
</code></pre>
<p>約束的另一個作用是泛型的實例可以訪問作為約束的 trait 的方法。例如：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 這個 trait 用來實現打印標記：`{:?}`。
use std::fmt::Debug;

trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

impl HasArea for Rectangle {
    fn area(&amp;self) -&gt; f64 { self.length * self.height }
}

#[derive(Debug)]
struct Rectangle { length: f64, height: f64 }
#[allow(dead_code)]
struct Triangle  { length: f64, height: f64 }

// 泛型 `T` 必須實現 `Debug` 。只要滿足這點，無論什麼類型
// 都可以讓下面函數正常工作。
fn print_debug&lt;T: Debug&gt;(t: &amp;T) {
    println!(&quot;{:?}&quot;, t);
}

// `T` 必須實現 `HasArea`。任意符合該約束的泛型的實例
// 都可訪問 `HasArea` 的 `area` 函數
fn area&lt;T: HasArea&gt;(t: &amp;T) -&gt; f64 { t.area() }

fn main() {
    let rectangle = Rectangle { length: 3.0, height: 4.0 };
    let _triangle = Triangle  { length: 3.0, height: 4.0 };

    print_debug(&amp;rectangle);
    println!(&quot;Area: {}&quot;, area(&amp;rectangle));

    //print_debug(&amp;_triangle);
    //println!(&quot;Area: {}&quot;, area(&amp;_triangle));
    // ^ 試一試：取消上述語句的註釋。
    // | 報錯：未實現 `Debug` 或 `HasArea`。
}
</code></pre></pre>
<p>多說一句，某些情況下也可使用 <a href="generics/../generics/where.html"><code>where</code></a> 分句來形成約束，這擁有更好的表現力。</p>
<h3 id="參見-35"><a class="header" href="#參見-35">參見：</a></h3>
<p><a href="generics/../hello/print.html"><code>std::fmt</code></a>, <a href="generics/../custom_types/structs.html"><code>struct</code></a>, 和 <a href="generics/../trait.html"><code>trait</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="測試實例空約束"><a class="header" href="#測試實例空約束">測試實例：空約束</a></h1>
<p>約束的工作機制會產生這樣的效果：即使一個 <code>trait</code> 不包含任何功能，你仍然可以用它
作為約束。標準庫中的 <code>Eq</code> 和 <code>Ord</code> 就是這樣的 <code>trait</code>。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Cardinal;
struct BlueJay;
struct Turkey;

trait Red {}
trait Blue {}

impl Red for Cardinal {}
impl Blue for BlueJay {}

// 這些函數只對實現了相應的 trait 的類型有效。
// 事實上這些 trait 內部是空的，但這沒有關係。
fn red&lt;T: Red&gt;(_: &amp;T)   -&gt; &amp;'static str { &quot;red&quot; }
fn blue&lt;T: Blue&gt;(_: &amp;T) -&gt; &amp;'static str { &quot;blue&quot; }

fn main() {
    let cardinal = Cardinal;
    let blue_jay = BlueJay;
    let _turkey   = Turkey;

    // 由於約束，`red()` 不能作用於 blue_jay （藍鬆鳥），反過來也一樣。
    println!(&quot;A cardinal is {}&quot;, red(&amp;cardinal));
    println!(&quot;A blue jay is {}&quot;, blue(&amp;blue_jay));
    //println!(&quot;A turkey is {}&quot;, red(&amp;_turkey));
    // ^ 試一試：去掉此行註釋。
}
</code></pre></pre>
<h3 id="參見-36"><a class="header" href="#參見-36">參見：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/cmp/trait.Eq.html"><code>std::cmp::Eq</code></a>, <a href="https://rustwiki.org/zh-CN/std/cmp/trait.Ord.html"><code>std::cmp::Ord</code></a>, 和 <a href="generics/bounds/../../trait.html"><code>trait</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多重約束"><a class="header" href="#多重約束">多重約束</a></h1>
<p>多重約束（multiple bounds）可以用 <code>+</code> 連接。和平常一樣，類型之間使用 <code>,</code> 隔開。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt::{Debug, Display};

fn compare_prints&lt;T: Debug + Display&gt;(t: &amp;T) {
    println!(&quot;Debug: `{:?}`&quot;, t);
    println!(&quot;Display: `{}`&quot;, t);
}

fn compare_types&lt;T: Debug, U: Debug&gt;(t: &amp;T, u: &amp;U) {
    println!(&quot;t: `{:?}&quot;, t);
    println!(&quot;u: `{:?}&quot;, u);
}

fn main() {
    let string = &quot;words&quot;;
    let array = [1, 2, 3];
    let vec = vec![1, 2, 3];

    compare_prints(&amp;string);
    //compare_prints(&amp;array);
    // 試一試 ^ 將此行註釋去掉。

    compare_types(&amp;array, &amp;vec);
}
</code></pre></pre>
<h3 id="參見-37"><a class="header" href="#參見-37">參見：</a></h3>
<p><a href="generics/../hello/print.html"><code>std::fmt</code></a> 和 <a href="generics/../trait.html"><code>trait</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="where-分句"><a class="header" href="#where-分句">where 分句</a></h1>
<p>約束也可以使用 <code>where</code> 分句來表達，它放在 <code>{</code> 的前面，而不需寫在類型第一次出現
之前。另外 <code>where</code> 從句可以用於任意類型的限定，而不侷限於類型參數本身。</p>
<p><code>where</code> 在下面一些情況下有很用：</p>
<ul>
<li>當分別指定泛型的類型和約束會更清晰時：</li>
</ul>
<pre><code class="language-rust ignore">impl &lt;A: TraitB + TraitC, D: TraitE + TraitF&gt; MyTrait&lt;A, D&gt; for YourType {}

// 使用 `where` 從句來表達約束
impl &lt;A, D&gt; MyTrait&lt;A, D&gt; for YourType where
    A: TraitB + TraitC,
    D: TraitE + TraitF {}
</code></pre>
<ul>
<li>當使用 <code>where</code> 從句比正常語法更有表現力時。本例中的 <code>impl</code> 如果不用
<code>where</code> 從句，就無法直接表達。</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt::Debug;

trait PrintInOption {
    fn print_in_option(self);
}

// 這裡需要一個 `where` 從句，否則就要表達成 `T: Debug`（這樣意思就變了），
// 或著改用另一種間接的方法。
impl&lt;T&gt; PrintInOption for T where
    Option&lt;T&gt;: Debug {
    // 我們要將 `Option&lt;T&gt;: Debug` 作為約束，因為那是要打印的內容。
    // 否則我們會給出錯誤的約束。
    fn print_in_option(self) {
        println!(&quot;{:?}&quot;, Some(self));
    }
}

fn main() {
    let vec = vec![1, 2, 3];

    vec.print_in_option();
}
</code></pre></pre>
<h3 id="參見-38"><a class="header" href="#參見-38">參見：</a></h3>
<p>相關的 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0135-where.md">RFC</a>、<a href="generics/../custom_types/structs.html"><code>struct</code></a> 和 <a href="generics/../trait.html"><code>trait</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="new-type-慣用法"><a class="header" href="#new-type-慣用法">new type 慣用法</a></h1>
<p><code>newtype</code> 慣用法（譯註：即為不同種類的數據分別定義新的類型）能保證在編譯時，提供
給程序的都是正確的類型。</p>
<p>比如說，實現一個 “年齡認證” 函數，它要求輸入<strong>必須</strong>是 <code>Years</code> 類型。</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">struct Years(i64);

struct Days(i64);

impl Years {
    pub fn to_days(&amp;self) -&gt; Days {
        Days(self.0 * 365)
    }
}


impl Days {
    /// 捨去不滿一年的部分
    pub fn to_years(&amp;self) -&gt; Years {
        Years(self.0 / 365)
    }
}

fn old_enough(age: &amp;Years) -&gt; bool {
    age.0 &gt;= 18
}

fn main() {
    let age = Years(5);
    let age_days = age.to_days();
    println!(&quot;Old enough {}&quot;, old_enough(&amp;age));
    println!(&quot;Old enough {}&quot;, old_enough(&amp;age_days.to_years()));
    // println!(&quot;Old enough {}&quot;, old_enough(&amp;age_days));
}
</code></pre></pre>
<p>取消最後一行的註釋，就可以發現提供給 <code>old_enough</code> 的必須是 <code>Years</code> 類型。</p>
<h3 id="see-also"><a class="header" href="#see-also">See also:</a></h3>
<p><a href="generics/../custom_types/structs.html"><code>structs</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="關聯項"><a class="header" href="#關聯項">關聯項</a></h1>
<p>“關聯項”（associated item）指與多種類型的<a href="https://rustwiki.org/zh-CN/reference/items.html">項</a>有關的一組規則。它是 <code>trait</code>
泛型的擴展，允許在 <code>trait</code> 內部定義新的項。</p>
<p>一個這樣的項就叫做一個關聯類型。當 <code>trait</code> 對於實現了它的容器類型是泛型的，關聯
項就提供了簡單的使用方法。</p>
<blockquote>
<p>譯註：“關聯項”這個說法實際上只在 RFC 裡出現了，官方的《The Rust Programming
Language》第一版和第二版都只有“關聯類型”的說法。如果覺得這裡的說法很彆扭的話
不要理會就是了。TRPL 對關聯類型的定義是：“一種將類型佔位符與 trait 聯繫起來的
做法，這樣 trait 中的方法簽名中就可以使用這些佔位符類型。trait 的實現會指定在
該實現中那些佔位符對應什麼具體類型。”等看完這一節再回頭看這個定義就很明白了。</p>
</blockquote>
<h3 id="參見-39"><a class="header" href="#參見-39">參見：</a></h3>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md">RFC</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="存在問題"><a class="header" href="#存在問題">存在問題</a></h1>
<p><code>trait</code> 如果對實現了它的容器類型是泛型的，則須遵守類型規範要求——<code>trait</code> 的
使用者<strong>必須</strong>指出 <code>trait</code> 的全部泛型類型。</p>
<p>在下面例子中，<code>Contains</code> <code>trait</code> 允許使用泛型類型 <code>A</code> 和 <code>B</code>。然後我們為
<code>Container</code> 類型實現了這個 trait，將 <code>A</code> 和 <code>B</code> 指定為 <code>i32</code>，這樣就可以對
它們使用 <code>difference()</code> 函數。</p>
<p>因為 <code>Contains</code> 是泛型的，我們必須在 <code>fn difference()</code> 中顯式地指出<strong>所有的</strong>泛型
類型。但實際上，我們想要表達，<code>A</code> 和 <code>B</code> 究竟是什麼類型是由輸入 <code>C</code> 決定的。在
下一節會看到，關聯類型恰好提供了這樣的功能。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Container(i32, i32);

// 這個 trait 檢查給定的 2 個項是否儲存於容器中
// 並且能夠獲得容器的第一個或最後一個值。
trait Contains&lt;A, B&gt; {
    fn contains(&amp;self, _: &amp;A, _: &amp;B) -&gt; bool; // 顯式地要求 `A` 和 `B`
    fn first(&amp;self) -&gt; i32; // 未顯式地要求 `A` 或 `B`
    fn last(&amp;self) -&gt; i32;  // 未顯式地要求 `A` 或 `B`
}

impl Contains&lt;i32, i32&gt; for Container {
    // 如果存儲的數字和給定的相等則為真。
    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool {
        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)
    }

    // 得到第一個數字。
    fn first(&amp;self) -&gt; i32 { self.0 }

    // 得到最後一個數字。
    fn last(&amp;self) -&gt; i32 { self.1 }
}

// 容器 `C` 就包含了 `A` 和 `B` 類型。鑑於此，必須指出 `A` 和 `B` 顯得很麻煩。
fn difference&lt;A, B, C&gt;(container: &amp;C) -&gt; i32 where
    C: Contains&lt;A, B&gt; {
    container.last() - container.first()
}

fn main() {
    let number_1 = 3;
    let number_2 = 10;

    let container = Container(number_1, number_2);

    println!(&quot;Does container contain {} and {}: {}&quot;,
        &amp;number_1, &amp;number_2,
        container.contains(&amp;number_1, &amp;number_2));
    println!(&quot;First number: {}&quot;, container.first());
    println!(&quot;Last number: {}&quot;, container.last());

    println!(&quot;The difference is: {}&quot;, difference(&amp;container));
}
</code></pre></pre>
<h3 id="參見-40"><a class="header" href="#參見-40">參見：</a></h3>
<p><a href="generics/assoc_items/../../custom_types/structs.html"><code>struct</code></a>, 和 <a href="generics/assoc_items/../../trait.html"><code>trait</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="關聯類型"><a class="header" href="#關聯類型">關聯類型</a></h1>
<p>通過把容器內部的類型放到 <code>trait</code> 中作為<strong>輸出類型</strong>，使用 “關聯類型” 增加了代碼
的可讀性。這樣的 <code>trait</code> 的定義語法如下：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `A` 和 `B` 在 trait 裡面通過 `type` 關鍵字來定義。
// （注意：此處的 `type` 不同於為類型取別名時的 `type`）。
trait Contains {
    type A;
    type B;

	// 這種語法能夠泛型地表示這些新類型。
    fn contains(&amp;self, _: &amp;Self::A, _: &amp;Self::B) -&gt; bool;
}
<span class="boring">}
</span></code></pre></pre>
<p>注意使用了 <code>Contains</code> <code>trait</code> 的函數就不需要寫出 <code>A</code> 或 <code>B</code> 了：</p>
<pre><code class="language-rust ignore">// 不使用關聯類型
fn difference&lt;A, B, C&gt;(container: &amp;C) -&gt; i32 where
    C: Contains&lt;A, B&gt; { ... }

// 使用關聯類型
fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 { ... }
</code></pre>
<p>讓我們使用關聯類型來重寫上一小節的例子：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Container(i32, i32);

// 這個 trait 檢查給定的 2 個項是否儲存於容器中
// 並且能夠獲得容器的第一個或最後一個值。
trait Contains {
    // 在這裡定義可以被方法使用的泛型類型。
    type A;
    type B;

    fn contains(&amp;self, _: &amp;Self::A, _: &amp;Self::B) -&gt; bool;
    fn first(&amp;self) -&gt; i32;
    fn last(&amp;self) -&gt; i32;
}

impl Contains for Container {
    // 指出 `A` 和 `B` 是什麼類型。如果 `input`（輸入）類型
    // 為 `Container(i32, i32)`，那麼 `output`（輸出）類型
    // 會被確定為 `i32` 和 `i32`。
    type A = i32;
    type B = i32;

    // `&amp;Self::A` 和 `&amp;Self::B` 在這裡也是合法的類型。
    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool {
        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)
    }

    // 得到第一個數字。
    fn first(&amp;self) -&gt; i32 { self.0 }

    // 得到最後一個數字。
    fn last(&amp;self) -&gt; i32 { self.1 }
}

fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 {
    container.last() - container.first()
}

fn main() {
    let number_1 = 3;
    let number_2 = 10;

    let container = Container(number_1, number_2);

    println!(&quot;Does container contain {} and {}: {}&quot;,
        &amp;number_1, &amp;number_2,
        container.contains(&amp;number_1, &amp;number_2));
    println!(&quot;First number: {}&quot;, container.first());
    println!(&quot;Last number: {}&quot;, container.last());
    
    println!(&quot;The difference is: {}&quot;, difference(&amp;container));
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="虛類型參數"><a class="header" href="#虛類型參數">虛類型參數</a></h1>
<p>虛類型（phantom type）參數是一種在運行時不出現，而在（且僅在）編譯時進行靜態檢查
的類型參數。</p>
<p>可以用額外的泛型類型參數指定數據類型，這類型可以充當標記，也可以供編譯時類型檢查
使用。這些額外的參數沒有存儲值，也沒有運行時行為。</p>
<p>在下面例子中，我們使用 <a href="https://rustwiki.org/zh-CN/std/marker/struct.PhantomData.html">std::marker::PhantomData</a> 作為虛類型參數的類型，創建
包含不同數據類型的元組。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::marker::PhantomData;

// 這個虛元組結構體對 `A` 是泛型的，並且帶有隱藏參數 `B`。
#[derive(PartialEq)] // 允許這種類型進行相等測試（equality test）。
struct PhantomTuple&lt;A, B&gt;(A,PhantomData&lt;B&gt;);

// 這個虛類型結構體對 `A` 是泛型的，並且帶有隱藏參數 `B`。
#[derive(PartialEq)] // 允許這種類型進行相等測試。
struct PhantomStruct&lt;A, B&gt; { first: A, phantom: PhantomData&lt;B&gt; }

// 注意：對於泛型 `A` 會分配存儲空間，但 `B` 不會。
//       因此，`B` 不能參與運算。

fn main() {
    // 這裡的 `f32` 和 `f64` 是隱藏參數。
    // 被指定為 `&lt;char, f32&gt;` 的 `PhantomTuple` 類型。
    let _tuple1: PhantomTuple&lt;char, f32&gt; = PhantomTuple('Q', PhantomData);
    // 被指定為 `&lt;char, f64&gt;` `PhantomTuple` 類型。
    let _tuple2: PhantomTuple&lt;char, f64&gt; = PhantomTuple('Q', PhantomData);

    // 被指定為 `&lt;char, f32&gt;` 的類型。
    let _struct1: PhantomStruct&lt;char, f32&gt; = PhantomStruct {
        first: 'Q',
        phantom: PhantomData,
    };
    // 被指定為 `&lt;char, f64&gt;` 的類型。
    let _struct2: PhantomStruct&lt;char, f64&gt; = PhantomStruct {
        first: 'Q',
        phantom: PhantomData,
    };
    
    // 編譯期錯誤！類型不匹配，所以這些值不能夠比較：
    //println!(&quot;_tuple1 == _tuple2 yields: {}&quot;,
    //          _tuple1 == _tuple2);
    
    // 編譯期錯誤！類型不匹配，所以這些值不能夠比較：
    //println!(&quot;_struct1 == _struct2 yields: {}&quot;,
    //          _struct1 == _struct2);
}
</code></pre></pre>
<h3 id="參見-41"><a class="header" href="#參見-41">參見：</a></h3>
<p><a href="generics/../trait/derive.html">Derive</a>, <a href="generics/../custom_types/structs.html">結構體</a>, 和 <a href="generics/../custom_types/structs.html">元組結構體</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="測試實例單位說明"><a class="header" href="#測試實例單位說明">測試實例：單位說明</a></h1>
<p>通過實現一個帶虛類型參數的 <code>Add</code> trait 可以實現單位檢查。這種 <code>Add</code> trait 的
代碼如下：</p>
<pre><code class="language-rust ignore">// 這個 `trait` 會要求 `Self + RHS = Output`。`&lt;RHS = Self&gt;` 表示 RHS 的默認值
// 為 Self 類型，也就是如果沒有在實現中另行指定，RHS 就取 Self 類型。
pub trait Add&lt;RHS = Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}

// `Output` 必須是 `T&lt;U&gt;` 類型，所以是 `T&lt;U&gt; + T&lt;U&gt; = T&lt;U&gt;`。
impl&lt;U&gt; Add for T&lt;U&gt; {
    type Output = T&lt;U&gt;;
    ...
}
</code></pre>
<p>完整實現：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::ops::Add;
use std::marker::PhantomData;

/// 創建空枚舉類型來表示單位。
#[derive(Debug, Clone, Copy)]
enum Inch {}
#[derive(Debug, Clone, Copy)]
enum Mm {}

/// `Length` 是一個帶有虛類型參數 `Unit` 的類型，
/// 而且對於表示長度的類型（即 `f64`）而言，`Length` 不是泛型的。
///
/// `f64` 已經實現了 `Clone` 和 `Copy` trait.
#[derive(Debug, Clone, Copy)]
struct Length&lt;Unit&gt;(f64, PhantomData&lt;Unit&gt;);

/// `Add` trait 定義了 `+` 運算符的行為。
impl&lt;Unit&gt; Add for Length&lt;Unit&gt; {
     type Output = Length&lt;Unit&gt;;

    // add() 返回一個含有和的新的 `Length` 結構體。
    fn add(self, rhs: Length&lt;Unit&gt;) -&gt; Length&lt;Unit&gt; {
        // `+` 調用了針對 `f64` 類型的 `Add` 實現。
        Length(self.0 + rhs.0, PhantomData)
    }
}

fn main() {
    // 指定 `one_foot` 擁有虛類型參數 `Inch`。
    let one_foot:  Length&lt;Inch&gt; = Length(12.0, PhantomData);
    // `one_meter` 擁有虛類型參數 `Mm`。
    let one_meter: Length&lt;Mm&gt;   = Length(1000.0, PhantomData);

    // `+` 調用了我們對 `Length&lt;Unit&gt;` 實現的 `add()` 方法。
    //
    // 由於 `Length` 了實現了 `Copy`，`add()` 不會消耗 `one_foot`
    // 和 `one_meter`，而是複製它們作為 `self` 和 `rhs`。
    let two_feet = one_foot + one_foot;
    let two_meters = one_meter + one_meter;

    // 加法正常執行。
    println!(&quot;one foot + one_foot = {:?} in&quot;, two_feet.0);
    println!(&quot;one meter + one_meter = {:?} mm&quot;, two_meters.0);

    // 無意義的運算當然會失敗：
    // 編譯期錯誤：類型不匹配。
    //let one_feter = one_foot + one_meter;
}

</code></pre></pre>
<h3 id="參見-42"><a class="header" href="#參見-42">參見：</a></h3>
<p><a href="generics/phantom/../../scope/borrow.html">Borrowing (<code>&amp;</code>)</a>, <a href="generics/phantom/../../generics/bounds.html">Bounds (<code>X: Y</code>)</a>, <a href="generics/phantom/../../custom_types/enum.html">enum</a>, <a href="generics/phantom/../../fn/methods.html">impl &amp; self</a>,
<a href="generics/phantom/../../trait/ops.html">Overloading</a>, <a href="generics/phantom/../../scope/borrow/ref.html">ref</a>, <a href="generics/phantom/../../trait.html">Traits (<code>X for Y</code>)</a>, 和 <a href="generics/phantom/../../custom_types/structs.html">TupleStructs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="作用域規則"><a class="header" href="#作用域規則">作用域規則</a></h1>
<p>作用域在所有權（ownership）、借用（borrow）和生命週期（lifetime）中起著重要作用。也就是說，作用域告訴編譯器什麼時候借用是合法的、什麼時候資源可以釋放、以及變量何時被創建或銷燬。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raii"><a class="header" href="#raii">RAII</a></h1>
<p>Rust 的變量不只是在棧中保存數據：它們也<strong>佔有</strong>資源，比如 <code>Box&lt;T&gt;</code> 佔有堆（heap）中的內存。Rust 強制實行 <a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a>（Resource Acquisition Is Initiallization，資源獲取即初始化），所以任何對象在離開作用域時，它的析構函數（destructor）就被調用，然後它佔有的資源就被釋放。</p>
<p>這種行為避免了<strong>資源洩漏</strong>（resource leak），所以你再也不用手動釋放內存或者擔心內存洩漏（memory leak）！下面是個快速入門示例：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// raii.rs
fn create_box() {
    // 在堆上分配一個整型數據
    let _box1 = Box::new(3i32);

    // `_box1` 在這裡被銷燬，內存得到釋放
}

fn main() {
    // 在堆上分配一個整型數據
    let _box2 = Box::new(5i32);

    // 嵌套作用域：
    {
        // 在堆上分配一個整型數據
        let _box3 = Box::new(4i32);

        // `_box3` 在這裡被銷燬，內存得到釋放
    }

    // 創建一大堆 box（只是因為好玩）。
    // 完全不需要手動釋放內存！
    for _ in 0u32..1_000 {
        create_box();
    }

    // `_box2` 在這裡被銷燬，內存得到釋放
}
</code></pre></pre>
<p>當然我們可以使用 <a href="https://valgrind.org/info/"><code>valgrind</code></a> 對內存錯誤進行仔細檢查：</p>
<pre><code class="language-bash">$ rustc raii.rs &amp;&amp; valgrind ./raii
==26873== Memcheck, a memory error detector
==26873== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==26873== Using Valgrind-3.9.0 and LibVEX; rerun with -h for copyright info
==26873== Command: ./raii
==26873==
==26873==
==26873== HEAP SUMMARY:
==26873==     in use at exit: 0 bytes in 0 blocks
==26873==   total heap usage: 1,013 allocs, 1,013 frees, 8,696 bytes allocated
==26873==
==26873== All heap blocks were freed -- no leaks are possible
==26873==
==26873== For counts of detected and suppressed errors, rerun with: -v
==26873== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 2 from 2)
</code></pre>
<p>完全沒有洩漏！</p>
<h2 id="析構函數"><a class="header" href="#析構函數">析構函數</a></h2>
<p>Rust 中的析構函數概念是通過 <a href="https://rustwiki.org/zh-CN/std/ops/trait.Drop.html"><code>Drop</code></a> trait 提供的。當資源離開作用域，就調用析構函數。你無需為每種類型都實現 <a href="https://rustwiki.org/zh-CN/std/ops/trait.Drop.html"><code>Drop</code></a> trait，只要為那些需要自己的析構函數邏輯的類型實現就可以了。</p>
<p>運行下列例子，看看 <a href="https://rustwiki.org/zh-CN/std/ops/trait.Drop.html"><code>Drop</code></a> trait 是怎樣工作的。當 <code>main</code> 函數中的變量離開作用域，自定義的析構函數就會被調用：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct ToDrop;

impl Drop for ToDrop {
    fn drop(&amp;mut self) {
        println!(&quot;ToDrop is being dropped&quot;);
    }
}

fn main() {
    let x = ToDrop;
    println!(&quot;Made a ToDrop!&quot;);
}
</code></pre></pre>
<h3 id="參見-43"><a class="header" href="#參見-43">參見：</a></h3>
<p><a href="scope/../std/box.html">Box</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="所有權和移動"><a class="header" href="#所有權和移動">所有權和移動</a></h1>
<p>因為變量要負責釋放它們擁有的資源，所以<strong>資源只能擁有一個所有者</strong>。這也防止了資源的重複釋放。注意並非所有變量都擁有資源（例如<a href="scope/../flow_control/match/destructuring/destructure_pointers.html">引用</a>）。</p>
<p>在進行賦值（<code>let x = y</code>）或通過值來傳遞函數參數（<code>foo(x)</code>）的時候，資源的<strong>所有權</strong>（ownership）會發生轉移。按照 Rust 的說法，這被稱為資源的<strong>移動</strong>（move）。</p>
<p>在移動資源之後，原來的所有者不能再被使用，這可避免懸掛指針（dangling pointer）的產生。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 此函數取得堆分配的內存的所有權
fn destroy_box(c: Box&lt;i32&gt;) {
    println!(&quot;Destroying a box that contains {}&quot;, c);

    // `c` 被銷燬且內存得到釋放
}

fn main() {
    // 棧分配的整型
    let x = 5u32;

    // 將 `x` *複製*到 `y`——不存在資源移動
    let y = x;

    // 兩個值各自都可以使用
    println!(&quot;x is {}, and y is {}&quot;, x, y);

    // `a` 是一個指向堆分配的整數的指針
    let a = Box::new(5i32);

    println!(&quot;a contains: {}&quot;, a);

    // *移動* `a` 到 `b`
    let b = a;
    // 把 `a` 的指針地址（而非數據）複製到 `b`。現在兩者都指向
    // 同一個堆分配的數據，但是現在是 `b` 擁有它。

    // 報錯！`a` 不能訪問數據，因為它不再擁有那部分堆上的內存。
    //println!(&quot;a contains: {}&quot;, a);
    // 試一試 ^ 去掉此行註釋

    // 此函數從 `b` 中取得堆分配的內存的所有權
    destroy_box(b);

    // 此時堆內存已經被釋放，這個操作會導致解引用已釋放的內存，而這是編譯器禁止的。
    // 報錯！和前面出錯的原因一樣。
    //println!(&quot;b contains: {}&quot;, b);
    // 試一試 ^ 去掉此行註釋
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="可變性"><a class="header" href="#可變性">可變性</a></h1>
<p>當所有權轉移時，數據的可變性可能發生改變。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let immutable_box = Box::new(5u32);

    println!(&quot;immutable_box contains {}&quot;, immutable_box);

    // 可變性錯誤
    //*immutable_box = 4;

    // *移動* box，改變所有權（和可變性）
    let mut mutable_box = immutable_box;

    println!(&quot;mutable_box contains {}&quot;, mutable_box);

    // 修改 box 的內容
    *mutable_box = 4;

    println!(&quot;mutable_box now contains {}&quot;, mutable_box);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="部分移動"><a class="header" href="#部分移動">部分移動</a></h1>
<p>在單個變量的<a href="scope/move/../../flow_control/match/destructuring.html">解構</a>內，可以同時使用 <code>by-move</code> 和 <code>by-reference</code> 模式綁定。這樣做將導致變量的<strong>部分移動</strong>（partial move），這意味著變量的某些部分將被移動，而其他部分將保留。在這種情況下，後面不能整體使用父級變量，但是仍然可以使用只引用（而不移動）的部分。</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    #[derive(Debug)]
    struct Person {
        name: String,
        age: u8,
    }

    let person = Person {
        name: String::from(&quot;Alice&quot;),
        age: 20,
    };

    // `name` 從 person 中移走，但 `age` 只是引用
    let Person { name, ref age } = person;

    println!(&quot;The person's age is {}&quot;, age);

    println!(&quot;The person's name is {}&quot;, name);

    // 報錯！部分移動值的借用：`person` 部分借用產生
    //println!(&quot;The person struct is {:?}&quot;, person);

    // `person` 不能使用，但 `person.age` 因為沒有被移動而可以繼續使用
    println!(&quot;The person's age from person struct is {}&quot;, person.age);
}
</code></pre></pre>
<h3 id="參見-44"><a class="header" href="#參見-44">參見：</a></h3>
<p><a href="scope/move/../../flow_control/match/destructuring.html">解構</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="借用"><a class="header" href="#借用">借用</a></h1>
<p>多數情況下，我們更希望能訪問數據，同時不取得其所有權。為實現這點，Rust 使用了<strong>借用</strong>（borrowing）機制。對象可以通過引用（<code>&amp;T</code>）來傳遞，從而取代通過值（<code>T</code>）來傳遞。</p>
<p>編譯器（通過借用檢查）靜態地保證了引用<strong>總是</strong>指向有效的對象。也就是說，當存在引用指向一個對象時，該對象不能被銷燬。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">// 此函數取得一個 box 的所有權並銷燬它
fn eat_box_i32(boxed_i32: Box&lt;i32&gt;) {
    println!(&quot;Destroying box that contains {}&quot;, boxed_i32);
}

// 此函數借用了一個 i32 類型
fn borrow_i32(borrowed_i32: &amp;i32) {
    println!(&quot;This int is: {}&quot;, borrowed_i32);
}

fn main() {
    // 創建一個裝箱的 i32 類型，以及一個存在棧中的 i32 類型。
    let boxed_i32 = Box::new(5_i32);
    let stacked_i32 = 6_i32;

    // 借用了 box 的內容，但沒有取得所有權，所以 box 的內容之後可以再次借用。
    // 譯註：請注意函數自身就是一個作用域，因此下面兩個函數運行完成以後，
    // 在函數中臨時創建的引用也就不復存在了。
    borrow_i32(&amp;boxed_i32);
    borrow_i32(&amp;stacked_i32);

    {
        // 取得一個對 box 中數據的引用
        let _ref_to_i32: &amp;i32 = &amp;boxed_i32;

        // 報錯！
        // 當 `boxed_i32` 裡面的值之後在作用域中被借用時，不能將其銷燬。
        eat_box_i32(boxed_i32);
        // 改正 ^ 註釋掉此行

        // 在 `_ref_to_i32` 裡面的值被銷燬後，嘗試借用 `_ref_to_i32`
        //（譯註：如果此處不借用，則在上一行的代碼中，eat_box_i32(boxed_i32)可以將 `boxed_i32` 銷燬。）
        borrow_i32(_ref_to_i32);
        // `_ref_to_i32` 離開作用域且不再被借用。
    }

    // `boxed_i32` 現在可以將所有權交給 `eat_i32` 並被銷燬。
    //（譯註：能夠銷燬是因為已經不存在對 `boxed_i32` 的引用）
    eat_box_i32(boxed_i32);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="可變性-1"><a class="header" href="#可變性-1">可變性</a></h1>
<p>可變數據可以使用 <code>&amp;mut T</code> 進行可變借用。這叫做<strong>可變引用</strong>（mutable reference），它使借用者可以讀/寫數據。相反，<code>&amp;T</code> 通過不可變引用（immutable reference）來借用數據，借用者可以讀數據而不能更改數據：</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">#[allow(dead_code)]
#[derive(Clone, Copy)]
struct Book {
    // `&amp;'static str` 是一個對分配在只讀內存區的字符串的引用
    author: &amp;'static str,
    title: &amp;'static str,
    year: u32,
}

// 此函數接受一個對 Book 類型的引用
fn borrow_book(book: &amp;Book) {
    println!(&quot;I immutably borrowed {} - {} edition&quot;, book.title, book.year);
}

// 此函數接受一個對可變的 Book 類型的引用，它把年份 `year` 改為 2014 年
fn new_edition(book: &amp;mut Book) {
    book.year = 2014;
    println!(&quot;I mutably borrowed {} - {} edition&quot;, book.title, book.year);
}

fn main() {
    // 創建一個名為 `immutabook` 的不可變的 Book 實例
    let immutabook = Book {
        // 字符串字面量擁有 `&amp;'static str` 類型
        author: &quot;Douglas Hofstadter&quot;,
        title: &quot;Gödel, Escher, Bach&quot;,
        year: 1979,
    };

    // 創建一個 `immutabook` 的可變拷貝，命名為 `mutabook`
    let mut mutabook = immutabook;

    // 不可變地借用一個不可變對象
    borrow_book(&amp;immutabook);

    // 不可變地借用一個可變對象
    borrow_book(&amp;mutabook);

    // 可變地借用一個可變對象
    new_edition(&amp;mut mutabook);

    // 報錯！不能可變地借用一個不可變對象
    new_edition(&amp;mut immutabook);
    // 改正 ^ 註釋掉此行
}
</code></pre></pre>
<h3 id="參見-45"><a class="header" href="#參見-45">參見：</a></h3>
<p><a href="scope/borrow/../lifetime/static_lifetime.html"><code>static</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="別名使用"><a class="header" href="#別名使用">別名使用</a></h1>
<p>數據可以多次不可變借用，但是在不可變借用的同時，原始數據不能使用可變借用。或者說，同一時間內只允許<strong>一次</strong>可變借用。僅當最後一次使用可變引用<strong>之後</strong>，原始數據才可以再次借用。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Point { x: i32, y: i32, z: i32 }

fn main() {
    let mut point = Point { x: 0, y: 0, z: 0 };

    let borrowed_point = &amp;point;
    let another_borrow = &amp;point;

    // 數據可以通過引用或原始類型來訪問
    println!(&quot;Point has coordinates: ({}, {}, {})&quot;,
                borrowed_point.x, another_borrow.y, point.z);
    
    // 報錯！`point` 不能以可變方式借用，因為當前還有不可變借用。
    // let mutable_borrow = &amp;mut point;
    // TODO ^ 試一試去掉此行註釋

    // 被借用的值在這裡被重新使用
    println!(&quot;Point has coordinates: ({}, {}, {})&quot;,
                borrowed_point.x, another_borrow.y, point.z);

    // 不可變的引用不再用於其餘的代碼，因此可以使用可變的引用重新借用。
    let mutable_borrow = &amp;mut point;

    // 通過可變引用來修改數據
    mutable_borrow.x = 5;
    mutable_borrow.y = 2;
    mutable_borrow.z = 1;

    // 報錯！不能再以不可變方式來借用 `point`，因為它當前已經被可變借用。
    // let y = &amp;point.y;
    // TODO ^ 試一試去掉此行註釋

    // 報錯！無法打印，因為 `println!` 用到了一個不可變引用。
    // println!(&quot;Point Z coordinate is {}&quot;, point.z);
    // TODO ^ 試一試去掉此行註釋

    // 正常運行！可變引用能夠以不可變類型傳入 `println!`
    println!(&quot;Point has coordinates: ({}, {}, {})&quot;,
                mutable_borrow.x, mutable_borrow.y, mutable_borrow.z);

    // 可變引用不再用於其餘的代碼，因此可以重新借用
    let new_borrowed_point = &amp;point;
    println!(&quot;Point now has coordinates: ({}, {}, {})&quot;,
             new_borrowed_point.x, new_borrowed_point.y, new_borrowed_point.z);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ref-模式"><a class="header" href="#ref-模式"><code>ref</code> 模式</a></h1>
<p>在通過 <code>let</code> 綁定來進行模式匹配或解構時，<code>ref</code> 關鍵字可用來創建結構體/元組的字段的引用。下面的例子展示了幾個實例，可看到 <code>ref</code> 的作用：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Clone, Copy)]
struct Point { x: i32, y: i32 }

fn main() {
    let c = 'Q';

    // 賦值語句中左邊的 `ref` 關鍵字等價於右邊的 `&amp;` 符號。
    let ref ref_c1 = c;
    let ref_c2 = &amp;c;

    println!(&quot;ref_c1 equals ref_c2: {}&quot;, *ref_c1 == *ref_c2);

    let point = Point { x: 0, y: 0 };

    // 在解構一個結構體時 `ref` 同樣有效。
    let _copy_of_x = {
        // `ref_to_x` 是一個指向 `point` 的 `x` 字段的引用。
        let Point { x: ref ref_to_x, y: _ } = point;

        // 返回一個 `point` 的 `x` 字段的拷貝。
        *ref_to_x
    };

    // `point` 的可變拷貝
    let mut mutable_point = point;

    {
        // `ref` 可以與 `mut` 結合以創建可變引用。
        let Point { x: _, y: ref mut mut_ref_to_y } = mutable_point;

        // 通過可變引用來改變 `mutable_point` 的字段 `y`。
        *mut_ref_to_y = 1;
    }

    println!(&quot;point is ({}, {})&quot;, point.x, point.y);
    println!(&quot;mutable_point is ({}, {})&quot;, mutable_point.x, mutable_point.y);

    // 包含一個指針的可變元組
    let mut mutable_tuple = (Box::new(5u32), 3u32);
    
    {
        // 解構 `mutable_tuple` 來改變 `last` 的值。
        let (_, ref mut last) = mutable_tuple;
        *last = 2u32;
    }
    
    println!(&quot;tuple is {:?}&quot;, mutable_tuple);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生命週期"><a class="header" href="#生命週期">生命週期</a></h1>
<p><strong>生命週期</strong>（lifetime）是這樣一種概念，編譯器（中的借用檢查器）用它來保證所有的借用都是有效的。確切地說，一個變量的生命週期在它創建的時候開始，在它銷燬的時候結束。雖然生命週期和作用域經常被一起提到，但它們並不相同。</p>
<p>例如考慮這種情況，我們通過 <code>&amp;</code> 來借用一個變量。該借用擁有一個生命週期，此生命週期由它聲明的位置決定。於是，只要該借用在出借者（lender）被銷燬前結束，借用就是有效的。然而，借用的作用域則是由使用引用的位置決定的。</p>
<p>在下面的例子和本章節剩下的內容裡，我們將看到生命週期和作用域的聯繫與區別。</p>
<blockquote>
<p>譯註：如果代碼中的生命週期示意圖亂掉了，請把它複製到任何編輯器中，用等寬字體查看。為避免中文的顯示問題，下面一些註釋沒有翻譯。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 下面使用連線來標註各個變量的創建和銷燬，從而顯示出生命週期。
// `i` 的生命週期最長，因為它的作用域完全覆蓋了 `borrow1` 和
// `borrow2` 的。`borrow1` 和 `borrow2` 的週期沒有關聯，
// 因為它們各不相交。
fn main() {
    let i = 3; // Lifetime for `i` starts. ────────────────┐
    //                                                     │
    { //                                                   │
        let borrow1 = &amp;i; // `borrow1` lifetime starts. ──┐│
        //                                                ││
        println!(&quot;borrow1: {}&quot;, borrow1); //              ││
    } // `borrow1 ends. ──────────────────────────────────┘│
    //                                                     │
    //                                                     │
    { //                                                   │
        let borrow2 = &amp;i; // `borrow2` lifetime starts. ──┐│
        //                                                ││
        println!(&quot;borrow2: {}&quot;, borrow2); //              ││
    } // `borrow2` ends. ─────────────────────────────────┘│
    //                                                     │
}   // Lifetime ends. ─────────────────────────────────────┘
</code></pre></pre>
<p>注意到這裡沒有用到名稱或類型來標註生命週期，這限制了生命週期的用法，在後面我們將會看到生命週期更強大的功能。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="顯式標註"><a class="header" href="#顯式標註">顯式標註</a></h1>
<p>借用檢查器使用顯式的生命週期標記來明確引用的有效時間應該持續多久。在生命週期沒有省略<sup class="footnote-reference"><a href="#1">1</a></sup>的情況下，Rust 需要顯式標註來確定引用的生命週期應該是什麼樣的。可以用撇號顯式地標出生命週期，語法如下：</p>
<pre><code class="language-rust ignore">foo&lt;'a&gt;
// `foo` 帶有一個生命週期參數 `'a`
</code></pre>
<p>和<a href="scope/lifetime/../../fn/closures/anonymity.html">閉包</a>類似，使用生命週期需要泛型。另外這個生命週期的語法也表明了 <code>foo</code> 的生命週期不能超出 <code>'a</code> 的週期。若要給類型顯式地標註生命週期，其語法會像是 <code>&amp;'a T</code> 這樣，其中 <code>'a</code> 的作用剛剛已經介紹了。</p>
<pre><code class="language-rust ignore">foo&lt;'a, 'b&gt;
// `foo` 帶有生命週期參數 `'a` 和 `'b`
</code></pre>
<p>在上面這種情形中，<code>foo</code> 的生命週期不能超出 <code>'a</code> 和 <code>'b</code> 中任一個的週期。</p>
<p>看下面的例子，瞭解顯式生命週期標註的運用：</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">// `print_refs` 接受兩個 `i32` 的引用，它們有不同的生命週期 `'a` 和 `'b`。
// 這兩個生命週期都必須至少要和 `print_refs` 函數一樣長。
fn print_refs&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!(&quot;x is {} and y is {}&quot;, x, y);
}

// 不帶參數的函數，不過有一個生命週期參數 `'a`。
fn failed_borrow&lt;'a&gt;() {
    let _x = 12;

    // 報錯：`_x` 的生命週期不夠長
    //let y: &amp;'a i32 = &amp;_x;
    // 在函數內部使用生命週期 `'a` 作為顯式類型標註將導致失敗，因為 `&amp;_x` 的
    // 生命週期比 `y` 的短。短生命週期不能強制轉換成長生命週期。
}

fn main() {
    // 創建變量，稍後用於借用。
    let (four, nine) = (4, 9);

    // 兩個變量的借用（`&amp;`）都傳進函數。
    print_refs(&amp;four, &amp;nine);
    // 任何被借用的輸入量都必須比借用者生存得更長。
    // 也就是說，`four` 和 `nine` 的生命週期都必須比 `print_refs` 的長。

    failed_borrow();
    // `failed_borrow` 未包含引用，因此不要求 `'a` 長於函數的生命週期，
    // 但 `'a` 壽命確實更長。因為該生命週期從未被約束，所以默認為 `'static`。
}
</code></pre></pre>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="scope/lifetime/elision.html">省略</a> 隱式地標註了生命週期，所以情況不同。</p>
</div>
<h3 id="參見-46"><a class="header" href="#參見-46">參見：</a></h3>
<p><a href="scope/lifetime/../../generics.html">泛型</a> 和 <a href="scope/lifetime/../../fn/closures.html">閉包</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函數-2"><a class="header" href="#函數-2">函數</a></h1>
<p>排除<a href="scope/lifetime/elision.html">省略</a>（elision）的情況，帶上生命週期的函數簽名有一些限制：</p>
<ul>
<li>任何引用<strong>都必須</strong>擁有標註好的生命週期。</li>
<li>任何被返回的引用<strong>都必須</strong>有和某個輸入量相同的生命週期或是靜態類型（<code>static</code>）。</li>
</ul>
<p>另外要注意，如果沒有輸入的函數返回引用，有時會導致返回的引用指向無效數據，這種情況下禁止它返回這樣的引用。下面例子展示了一些合法的帶有生命週期的函數：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 一個擁有生命週期 `'a` 的輸入引用，其中 `'a` 的存活時間
// 至少與函數的一樣長。
fn print_one&lt;'a&gt;(x: &amp;'a i32) {
    println!(&quot;`print_one`: x is {}&quot;, x);
}

// 可變引用同樣也可能擁有生命週期。
fn add_one&lt;'a&gt;(x: &amp;'a mut i32) {
    *x += 1;
}

// 擁有不同生命週期的多個元素。對下面這種情形，兩者即使擁有
// 相同的生命週期 `'a` 也沒問題，但對一些更復雜的情形，可能
// 就需要不同的生命週期了。
fn print_multi&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!(&quot;`print_multi`: x is {}, y is {}&quot;, x, y);
}

// 返回傳遞進來的引用也是可行的。
// 但必須返回正確的生命週期。
fn pass_x&lt;'a, 'b&gt;(x: &amp;'a i32, _: &amp;'b i32) -&gt; &amp;'a i32 { x }

//fn invalid_output&lt;'a&gt;() -&gt; &amp;'a String { &amp;String::from(&quot;foo&quot;) }
// 上面代碼是無效的：`'a` 存活的時間必須比函數的長。
// 這裡的 `&amp;String::from(&quot;foo&quot;)` 將會創建一個 `String` 類型，然後對它取引用。
// 數據在離開作用域時刪掉，返回一個指向無效數據的引用。

fn main() {
    let x = 7;
    let y = 9;

    print_one(&amp;x);
    print_multi(&amp;x, &amp;y);

    let z = pass_x(&amp;x, &amp;y);
    print_one(z);

    let mut t = 3;
    add_one(&amp;mut t);
    print_one(&amp;t);
}
</code></pre></pre>
<h3 id="參見-47"><a class="header" href="#參見-47">參見：</a></h3>
<p><a href="scope/lifetime/fn.html">函數</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="方法-1"><a class="header" href="#方法-1">方法</a></h1>
<p>方法的標註和函數類似：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Owner(i32);

impl Owner {
    // 標註生命週期，就像獨立的函數一樣。
    fn add_one&lt;'a&gt;(&amp;'a mut self) { self.0 += 1; }
    fn print&lt;'a&gt;(&amp;'a self) {
        println!(&quot;`print`: {}&quot;, self.0);
    }
}

fn main() {
    let mut owner  = Owner(18);

    owner.add_one();
    owner.print();
}
</code></pre></pre>
<blockquote>
<p>譯註：方法一般是不需要標明生命週期的，因為 <code>self</code> 的生命週期會賦給所有的輸出生命週期參數，詳見 <a href="https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html#%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E7%9C%81%E7%95%A5lifetime-elision">TRPL</a>。</p>
</blockquote>
<h3 id="參見-48"><a class="header" href="#參見-48">參見：</a></h3>
<p><a href="scope/lifetime/../../fn/methods.html">方法</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="結構體-2"><a class="header" href="#結構體-2">結構體</a></h1>
<p>在結構體中標註生命週期也和函數的類似：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 一個 `Borrowed` 類型，含有一個指向 `i32` 類型的引用。
// 該引用必須比 `Borrowed` 壽命更長。
#[derive(Debug)]
struct Borrowed&lt;'a&gt;(&amp;'a i32);

// 和前面類似，這裡的兩個引用都必須比這個結構體長壽。
#[derive(Debug)]
struct NamedBorrowed&lt;'a&gt; {
    x: &amp;'a i32,
    y: &amp;'a i32,
}

// 一個枚舉類型，其取值不是 `i32` 類型就是一個指向 `i32` 的引用。
#[derive(Debug)]
enum Either&lt;'a&gt; {
    Num(i32),
    Ref(&amp;'a i32),
}

fn main() {
    let x = 18;
    let y = 15;

    let single = Borrowed(&amp;x);
    let double = NamedBorrowed { x: &amp;x, y: &amp;y };
    let reference = Either::Ref(&amp;x);
    let number    = Either::Num(y);

    println!(&quot;x is borrowed in {:?}&quot;, single);
    println!(&quot;x and y are borrowed in {:?}&quot;, double);
    println!(&quot;x is borrowed in {:?}&quot;, reference);
    println!(&quot;y is *not* borrowed in {:?}&quot;, number);
}
</code></pre></pre>
<h3 id="參見-49"><a class="header" href="#參見-49">參見：</a></h3>
<p><a href="scope/lifetime/../../custom_types/structs.html">結構體</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-1"><a class="header" href="#trait-1">trait</a></h1>
<p>trait 方法中生命期的標註基本上與函數類似。注意，<code>impl</code> 也可能有生命週期的標註。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 帶有生命週期標註的結構體。
#[derive(Debug)]
 struct Borrowed&lt;'a&gt; {
     x: &amp;'a i32,
 }

// 給 impl 標註生命週期。
impl&lt;'a&gt; Default for Borrowed&lt;'a&gt; {
    fn default() -&gt; Self {
        Self {
            x: &amp;10,
        }
    }
}

fn main() {
    let b: Borrowed = Default::default();
    println!(&quot;b is {:?}&quot;, b);
}
</code></pre></pre>
<h3 id="參見-50"><a class="header" href="#參見-50">參見：</a></h3>
<p><a href="scope/lifetime/../../trait.html"><code>trait</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="約束-1"><a class="header" href="#約束-1">約束</a></h1>
<p>就如泛型類型能夠被約束一樣，生命週期（它們本身就是泛型）也可以使用約束。<code>:</code> 字符的意義在這裡稍微有些不同，不過 <code>+</code> 是相同的。注意下面的說明：</p>
<ol>
<li><code>T: 'a</code>：在 <code>T</code> 中的<strong>所有</strong>引用都必須比生命週期 <code>'a</code> 活得更長。</li>
<li><code>T: Trait + 'a</code>：<code>T</code> 類型必須實現 <code>Trait</code> trait，並且在 <code>T</code> 中的<strong>所有</strong>引用都必須比 <code>'a</code> 活得更長。</li>
</ol>
<p>下面例子展示了上述語法的實際應用：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt::Debug; // 用於約束的 trait。

#[derive(Debug)]
struct Ref&lt;'a, T: 'a&gt;(&amp;'a T);
// `Ref` 包含一個指向泛型類型 `T` 的引用，其中 `T` 擁有一個未知的生命週期
// `'a`。`T` 擁有生命週期限制， `T` 中的任何*引用*都必須比 `'a` 活得更長。另外
// `Ref` 的生命週期也不能超出 `'a`。

// 一個泛型函數，使用 `Debug` trait 來打印內容。
fn print&lt;T&gt;(t: T) where
    T: Debug {
    println!(&quot;`print`: t is {:?}&quot;, t);
}

// 這裡接受一個指向 `T` 的引用，其中 `T` 實現了 `Debug` trait，並且在 `T` 中的
// 所有*引用*都必須比 `'a'` 存活時間更長。另外，`'a` 也要比函數活得更長。
fn print_ref&lt;'a, T&gt;(t: &amp;'a T) where
    T: Debug + 'a {
    println!(&quot;`print_ref`: t is {:?}&quot;, t);
}

fn main() {
    let x = 7;
    let ref_x = Ref(&amp;x);

    print_ref(&amp;ref_x);
    print(ref_x);
}
</code></pre></pre>
<h3 id="參見-51"><a class="header" href="#參見-51">參見：</a></h3>
<p><a href="scope/lifetime/../../generics.html">泛型</a>, <a href="scope/lifetime/../../generics/bounds.html">泛型中的約束</a>, 以及 <a href="scope/lifetime/../../generics/multi_bounds.html">泛型中的多重約束</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="強制轉換"><a class="header" href="#強制轉換">強制轉換</a></h1>
<p>一個較長的生命週期可以強制轉成一個較短的生命週期，使它在一個通常情況下不能工作的作用域內也能正常工作。強制轉換可由編譯器隱式地推導並執行，也可以通過聲明不同的生命週期的形式實現。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 在這裡，Rust 推導了一個儘可能短的生命週期。
// 然後這兩個引用都被強制轉成這個生命週期。
fn multiply&lt;'a&gt;(first: &amp;'a i32, second: &amp;'a i32) -&gt; i32 {
    first * second
}

// `&lt;'a: 'b, 'b&gt;` 讀作生命週期 `'a` 至少和 `'b` 一樣長。
// 在這裡我們我們接受了一個 `&amp;'a i32` 類型並返回一個 `&amp;'b i32` 類型，這是
// 強制轉換得到的結果。
fn choose_first&lt;'a: 'b, 'b&gt;(first: &amp;'a i32, _: &amp;'b i32) -&gt; &amp;'b i32 {
    first
}

fn main() {
    let first = 2; // 較長的生命週期

    {
        let second = 3; // 較短的生命週期

        println!(&quot;The product is {}&quot;, multiply(&amp;first, &amp;second));
        println!(&quot;{} is the first&quot;, choose_first(&amp;first, &amp;second));
    };
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="static"><a class="header" href="#static">static</a></h1>
<p><code>'static</code> 生命週期是可能的生命週期中最長的，它會在整個程序運行的時期中存在。<code>'static</code> 生命週期也可被強制轉換成一個更短的生命週期。有兩種方式使變量擁有 <code>'static</code> 生命週期，它們都把數據保存在可執行文件的只讀內存區：</p>
<ul>
<li>使用 <code>static</code> 聲明來產生常量（constant）。</li>
<li>產生一個擁有 <code>&amp;'static str</code> 類型的 <code>string</code> 字面量。</li>
</ul>
<p>看下面的例子，瞭解列舉到的各個方法：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 產生一個擁有 `'static` 生命週期的常量。
static NUM: i32 = 18;

// 返回一個指向 `NUM` 的引用，該引用不取 `NUM` 的 `'static` 生命週期，
// 而是被強制轉換成和輸入參數的一樣。
fn coerce_static&lt;'a&gt;(_: &amp;'a i32) -&gt; &amp;'a i32 {
    &amp;NUM
}

fn main() {
    {
        // 產生一個 `string` 字面量並打印它：
        let static_string = &quot;I'm in read-only memory&quot;;
        println!(&quot;static_string: {}&quot;, static_string);

        // 當 `static_string` 離開作用域時，該引用不能再使用，不過
        // 數據仍然存在於二進制文件裡面。
    }

    {
        // 產生一個整型給 `coerce_static` 使用：
        let lifetime_num = 9;

        // 將對 `NUM` 的引用強制轉換成 `lifetime_num` 的生命週期：
        let coerced_static = coerce_static(&amp;lifetime_num);

        println!(&quot;coerced_static: {}&quot;, coerced_static);
    }

    println!(&quot;NUM: {} stays accessible!&quot;, NUM);
}
</code></pre></pre>
<h3 id="參見-52"><a class="header" href="#參見-52">參見：</a></h3>
<p><a href="scope/lifetime/../../custom_types/constants.html"><code>'static</code> 常量</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="省略"><a class="header" href="#省略">省略</a></h1>
<p>有些生命週期的模式太常用了，所以借用檢查器將會隱式地添加它們以減少程序輸入量和增強可讀性。這種隱式添加生命週期的過程稱為省略（elision）。在 Rust 使用省略僅僅是因為這些模式太普遍了。</p>
<p>下面代碼展示了一些省略的例子。對於省略的詳細描述，可以參考官方文檔的<a href="https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html#%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E7%9C%81%E7%95%A5lifetime-elision">生命週期省略</a>。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// `elided_input` 和 `annotated_input` 事實上擁有相同的簽名，
// `elided_input` 的生命週期會被編譯器自動添加：
fn elided_input(x: &amp;i32) {
    println!(&quot;`elided_input`: {}&quot;, x)
}

fn annotated_input&lt;'a&gt;(x: &amp;'a i32) {
    println!(&quot;`annotated_input`: {}&quot;, x)
}

// 類似地，`elided_pass` 和 `annotated_pass` 也擁有相同的簽名，
// 生命週期會被隱式地添加進 `elided_pass`：
fn elided_pass(x: &amp;i32) -&gt; &amp;i32 { x }

fn annotated_pass&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32 { x }

fn main() {
    let x = 3;

    elided_input(&amp;x);
    annotated_input(&amp;x);

    println!(&quot;`elided_pass`: {}&quot;, elided_pass(&amp;x));
    println!(&quot;`annotated_pass`: {}&quot;, annotated_pass(&amp;x));
}
</code></pre></pre>
<h3 id="參見-53"><a class="header" href="#參見-53">參見：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html#%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E7%9C%81%E7%95%A5lifetime-elision">省略</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="特質-trait"><a class="header" href="#特質-trait">特質 trait</a></h1>
<p><code>trait</code> 是對未知類型 <code>Self</code> 定義的方法集。該類型也可以訪問同一個 trait 中定義的
其他方法。</p>
<p>對任何數據類型都可以實現 trait。在下面例子中，我們定義了包含一系列方法
的 <code>Animal</code>。然後針對 <code>Sheep</code> 數據類型實現 <code>Animal</code> <code>trait</code>，因而 <code>Sheep</code>
的實例可以使用 <code>Animal</code> 中的所有方法。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Sheep { naked: bool, name: &amp;'static str }

trait Animal {
    // 靜態方法簽名；`Self` 表示實現者類型（implementor type）。
    fn new(name: &amp;'static str) -&gt; Self;

    // 實例方法簽名；這些方法將返回一個字符串。
    fn name(&amp;self) -&gt; &amp;'static str;
    fn noise(&amp;self) -&gt; &amp;'static str;

    // trait 可以提供默認的方法定義。
    fn talk(&amp;self) {
        println!(&quot;{} says {}&quot;, self.name(), self.noise());
    }
}

impl Sheep {
    fn is_naked(&amp;self) -&gt; bool {
        self.naked
    }

    fn shear(&amp;mut self) {
        if self.is_naked() {
            // 實現者可以使用它的 trait 方法。
            println!(&quot;{} is already naked...&quot;, self.name());
        } else {
            println!(&quot;{} gets a haircut!&quot;, self.name);

            self.naked = true;
        }
    }
}

// 對 `Sheep` 實現 `Animal` trait。
impl Animal for Sheep {
    // `Self` 是實現者類型：`Sheep`。
    fn new(name: &amp;'static str) -&gt; Sheep {
        Sheep { name: name, naked: false }
    }

    fn name(&amp;self) -&gt; &amp;'static str {
        self.name
    }

    fn noise(&amp;self) -&gt; &amp;'static str {
        if self.is_naked() {
            &quot;baaaaah?&quot;
        } else {
            &quot;baaaaah!&quot;
        }
    }
    
    // 默認 trait 方法可以重載。
    fn talk(&amp;self) {
        // 例如我們可以增加一些安靜的沉思。
        println!(&quot;{} pauses briefly... {}&quot;, self.name, self.noise());
    }
}

fn main() {
    // 這種情況需要類型標註。
    let mut dolly: Sheep = Animal::new(&quot;Dolly&quot;);
    // 試一試 ^ 移除類型標註。

    dolly.talk();
    dolly.shear();
    dolly.talk();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="派生"><a class="header" href="#派生">派生</a></h1>
<p>通過 <code>#[derive]</code> <a href="trait/../attribute.html">屬性</a>，編譯器能夠提供某些 trait 的基本實現。如果
需要更復雜的行為，這些 trait 也可以手動實現。</p>
<p>下面是可以自動派生的 trait：</p>
<ul>
<li>比較 trait:
<a href="https://rustwiki.org/zh-CN/std/cmp/trait.Eq.html"><code>Eq</code></a>, <a href="https://rustwiki.org/zh-CN/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a>, <a href="https://rustwiki.org/zh-CN/std/cmp/trait.Ord.html"><code>Ord</code></a>, <a href="https://rustwiki.org/zh-CN/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a></li>
<li><a href="https://rustwiki.org/zh-CN/std/clone/trait.Clone.html"><code>Clone</code></a>, 用來從 <code>&amp;T</code> 創建副本 <code>T</code>。</li>
<li><a href="https://rustwiki.org/zh-CN/core/marker/trait.Copy.html"><code>Copy</code></a>，使類型具有 “複製語義”（copy semantics）而非 “移動語義”（move semantics）。</li>
<li><a href="https://rustwiki.org/zh-CN/std/hash/trait.Hash.html"><code>Hash</code></a>，從 <code>&amp;T</code> 計算哈希值（hash）。</li>
<li><a href="https://rustwiki.org/zh-CN/std/default/trait.Default.html"><code>Default</code></a>, 創建數據類型的一個空實例。</li>
<li><a href="https://rustwiki.org/zh-CN/std/fmt/trait.Debug.html"><code>Debug</code></a>，使用 <code>{:?}</code> formatter 來格式化一個值。</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">// `Centimeters`，可以比較的元組結構體
#[derive(PartialEq, PartialOrd)]
struct Centimeters(f64);

// `Inches`，可以打印的元組結構體
#[derive(Debug)]
struct Inches(i32);

impl Inches {
    fn to_centimeters(&amp;self) -&gt; Centimeters {
        let &amp;Inches(inches) = self;

        Centimeters(inches as f64 * 2.54)
    }
}

// `Seconds`，不帶附加屬性的元組結構體
struct Seconds(i32);

fn main() {
    let _one_second = Seconds(1);

    // 報錯：`Seconds` 不能打印；它沒有實現 `Debug` trait
    //println!(&quot;One second looks like: {:?}&quot;, _one_second);
    // 試一試 ^ 取消此行註釋

    // 報錯：`Seconds`不能比較；它沒有實現 `PartialEq` trait
    //let _this_is_true = (_one_second == _one_second);
    // 試一試 ^ 取消此行註釋

    let foot = Inches(12);

    println!(&quot;One foot equals {:?}&quot;, foot);

    let meter = Centimeters(100.0);

    let cmp =
        if foot.to_centimeters() &lt; meter {
            &quot;smaller&quot;
        } else {
            &quot;bigger&quot;
        };

    println!(&quot;One foot is {} than one meter.&quot;, cmp);
}
</code></pre></pre>
<h3 id="參見-54"><a class="header" href="#參見-54">參見</a></h3>
<p><a href="https://rustwiki.org/zh-CN/reference/attributes.html#%E6%B4%BE%E7%94%9F"><code>derive</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用-dyn-返回-trait"><a class="header" href="#使用-dyn-返回-trait">使用 <code>dyn</code> 返回 trait</a></h1>
<p>Rust 編譯器需要知道每個函數的返回類型需要多少空間。這意味著所有函數都必須返回一個具體類型。與其他語言不同，如果你有個像 <code>Animal</code> 那樣的的 trait，則不能編寫返回 <code>Animal</code> 的函數，因為其不同的實現將需要不同的內存量。</p>
<p>但是，有一個簡單的解決方法。相比於直接返回一個 trait 對象，我們的函數返回一個包含一些 <code>Animal</code> 的 <code>Box</code>。<code>box</code> 只是對堆中某些內存的引用。因為引用的大小是靜態已知的，並且編譯器可以保證引用指向已分配的堆 <code>Animal</code>，所以我們可以從函數中返回 trait！</p>
<p>每當在堆上分配內存時，Rust 都會嘗試儘可能明確。因此，如果你的函數以這種方式返回指向堆的 trait 指針，則需要使用 <code>dyn</code> 關鍵字編寫返回類型，例如 <code>Box&lt;dyn Animal&gt;</code>。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Sheep {}
struct Cow {}

trait Animal {
    // 實例方法簽名
    fn noise(&amp;self) -&gt; &amp;'static str;
}

// 實現 `Sheep` 的 `Animal` trait。
impl Animal for Sheep {
    fn noise(&amp;self) -&gt; &amp;'static str {
        &quot;baaaaah!&quot;
    }
}

// 實現 `Cow` 的 `Animal` trait。
impl Animal for Cow {
    fn noise(&amp;self) -&gt; &amp;'static str {
        &quot;moooooo!&quot;
    }
}

// 返回一些實現 Animal 的結構體，但是在編譯時我們不知道哪個結構體。
fn random_animal(random_number: f64) -&gt; Box&lt;dyn Animal&gt; {
    if random_number &lt; 0.5 {
        Box::new(Sheep {})
    } else {
        Box::new(Cow {})
    }
}

fn main() {
    let random_number = 0.234;
    let animal = random_animal(random_number);
    println!(&quot;You've randomly chosen an animal, and it says {}&quot;, animal.noise());
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="運算符重載"><a class="header" href="#運算符重載">運算符重載</a></h1>
<p>在 Rust 中，很多運算符可以通過 trait 來重載。也就是說，這些運算符可以根據它們的
輸入參數來完成不同的任務。這之所以可行，是因為運算符就是方法調用的語法糖。例
如，<code>a + b</code> 中的 <code>+</code> 運算符會調用 <code>add</code> 方法（也就是 <code>a.add(b)</code>）。這個 <code>add</code> 方
法是 <code>Add</code> trait 的一部分。因此，<code>+</code> 運算符可以被任何 <code>Add</code> trait 的實現者使用。</p>
<p>會重載運算符的 <code>trait</code>（比如 <code>Add</code> 這種）可以在<a href="https://rustwiki.org/zh-CN/core/ops/">這裡</a>查看。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::ops;

struct Foo;
struct Bar;

#[derive(Debug)]
struct FooBar;

#[derive(Debug)]
struct BarFoo;

// `std::ops::Add` trait 用來指明 `+` 的功能，這裡我們實現 `Add&lt;Bar&gt;`，它是用於
// 把對象和 `Bar` 類型的右操作數（RHS）加起來的 `trait`。
// 下面的代碼塊實現了 `Foo + Bar = FooBar` 這樣的運算。
impl ops::Add&lt;Bar&gt; for Foo {
    type Output = FooBar;

    fn add(self, _rhs: Bar) -&gt; FooBar {
        println!(&quot;&gt; Foo.add(Bar) was called&quot;);

        FooBar
    }
}

// 通過顛倒類型，我們實現了不服從交換律的加法。
// 這裡我們實現 `Add&lt;Foo&gt;`，它是用於把對象和 `Foo` 類型的右操作數加起來的 trait。
// 下面的代碼塊實現了 `Bar + Foo = BarFoo` 這樣的運算。
impl ops::Add&lt;Foo&gt; for Bar {
    type Output = BarFoo;

    fn add(self, _rhs: Foo) -&gt; BarFoo {
        println!(&quot;&gt; Bar.add(Foo) was called&quot;);

        BarFoo
    }
}

fn main() {
    println!(&quot;Foo + Bar = {:?}&quot;, Foo + Bar);
    println!(&quot;Bar + Foo = {:?}&quot;, Bar + Foo);
}
</code></pre></pre>
<h3 id="參見-55"><a class="header" href="#參見-55">參見：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/core/ops/trait.Add.html">Add</a>, <a href="https://rustwiki.org/zh-CN/book/appendix-02-operators.html">語法索引</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drop"><a class="header" href="#drop">Drop</a></h1>
<p><a href="https://rustwiki.org/zh-CN/std/ops/trait.Drop.html"><code>Drop</code></a> trait 只有一個方法：<code>drop</code>，當對象離開作用域時會自動調用該
方法。<code>Drop</code> trait 的主要作用是釋放實現者的實例擁有的資源。</p>
<p><code>Box</code>，<code>Vec</code>，<code>String</code>，<code>File</code>，以及 <code>Process</code> 是一些實現了 <code>Drop</code> trait 來釋放
資源的類型。<code>Drop</code> trait 也可以為任何自定義數據類型手動實現。</p>
<p>下面示例給 <code>drop</code> 函數增加了打印到控制檯的功能，用於宣佈它在什麼時候被調用。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Droppable {
    name: &amp;'static str,
}

// 這個簡單的 `drop` 實現添加了打印到控制檯的功能。
impl Drop for Droppable {
    fn drop(&amp;mut self) {
        println!(&quot;&gt; Dropping {}&quot;, self.name);
    }
}

fn main() {
    let _a = Droppable { name: &quot;a&quot; };

    // 代碼塊 A
    {
        let _b = Droppable { name: &quot;b&quot; };

        // 代碼塊 B
        {
            let _c = Droppable { name: &quot;c&quot; };
            let _d = Droppable { name: &quot;d&quot; };

            println!(&quot;Exiting block B&quot;);
        }
        println!(&quot;Just exited block B&quot;);

        println!(&quot;Exiting block A&quot;);
    }
    println!(&quot;Just exited block A&quot;);

    // 變量可以手動使用 `drop` 函數來銷燬。
    drop(_a);
    // 試一試 ^ 將此行註釋掉。

    println!(&quot;end of the main function&quot;);

    // `_a` *不會*在這裡再次銷燬，因為它已經被（手動）銷燬。
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterator"><a class="header" href="#iterator">Iterator</a></h1>
<p><code>Iterator</code> trait 用來對集合（collection）類型（比如數組）實現迭代器。</p>
<p>這個 trait 只需定義一個返回 <code>next</code>（下一個）元素的方法，這可手動在 <code>impl</code> 代碼塊
中定義，或者自動定義（比如在數組或區間中）。</p>
<p>為方便起見，<code>for</code> 結構會使用 <a href="https://rustwiki.org/zh-CN/std/iter/trait.IntoIterator.html"><code>.into_iterator()</code></a> 方法將一些集合類型
轉換為迭代器。</p>
<p>下面例子展示瞭如何使用 <code>Iterator</code> trait 的方法，更多可用的方法可以看<a href="https://rustwiki.org/zh-CN/core/iter/trait.Iterator.html">這裡</a>。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Fibonacci {
    curr: u32,
    next: u32,
}

// 為 `Fibonacci`（斐波那契）實現 `Iterator`。
// `Iterator` trait 只需定義一個能返回 `next`（下一個）元素的方法。
impl Iterator for Fibonacci {
    type Item = u32;
    
    // 我們在這裡使用 `.curr` 和 `.next` 來定義數列（sequence）。
    // 返回類型為 `Option&lt;T&gt;`：
    //     * 當 `Iterator` 結束時，返回 `None`。
    //     * 其他情況，返回被 `Some` 包裹（wrap）的下一個值。
    fn next(&amp;mut self) -&gt; Option&lt;u32&gt; {
        let new_next = self.curr + self.next;

        self.curr = self.next;
        self.next = new_next;

        // 既然斐波那契數列不存在終點，那麼 `Iterator` 將不可能
        // 返回 `None`，而總是返回 `Some`。
        Some(self.curr)
    }
}

// 返回一個斐波那契數列生成器
fn fibonacci() -&gt; Fibonacci {
    Fibonacci { curr: 1, next: 1 }
}

fn main() {
    // `0..3` 是一個 `Iterator`，會產生：0、1 和 2。
    let mut sequence = 0..3;

    println!(&quot;Four consecutive `next` calls on 0..3&quot;);
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());

    // `for` 遍歷 `Iterator` 直到返回 `None`，
    // 並且每個 `Some` 值都被解包（unwrap），然後綁定給一個變量（這裡是 `i`）。       
    println!(&quot;Iterate through 0..3 using `for`&quot;);
    for i in 0..3 {
        println!(&quot;&gt; {}&quot;, i);
    }

    // `take(n)` 方法提取 `Iterator` 的前 `n` 項。
    println!(&quot;The first four terms of the Fibonacci sequence are: &quot;);
    for i in fibonacci().take(4) {
        println!(&quot;&gt; {}&quot;, i);
    }

    // `skip(n)` 方法移除前 `n` 項，從而縮短了 `Iterator` 。
    println!(&quot;The next four terms of the Fibonacci sequence are: &quot;);
    for i in fibonacci().skip(4).take(4) {
        println!(&quot;&gt; {}&quot;, i);
    }

    let array = [1u32, 3, 3, 7];

    // `iter` 方法對數組/slice 產生一個 `Iterator`。
    println!(&quot;Iterate the following array {:?}&quot;, &amp;array);
    for i in array.iter() {
        println!(&quot;&gt; {}&quot;, i);
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impl-trait"><a class="header" href="#impl-trait"><code>impl Trait</code></a></h1>
<p>如果函數返回實現了 <code>MyTrait</code> 的類型，可以將其返回類型編寫為 <code>-&gt; impl MyTrait</code>。這可以大大簡化你的類型簽名！</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::iter;
use std::vec::IntoIter;

// 該函數組合了兩個 `Vec &lt;i32&gt;` 並在其上返回一個迭代器。
// 看看它的返回類型多麼複雜！
fn combine_vecs_explicit_return_type(
    v: Vec&lt;i32&gt;,
    u: Vec&lt;i32&gt;,
) -&gt; iter::Cycle&lt;iter::Chain&lt;IntoIter&lt;i32&gt;, IntoIter&lt;i32&gt;&gt;&gt; {
    v.into_iter().chain(u.into_iter()).cycle()
}

// 這是完全相同的函數，但其返回類型使用 `impl Trait`。
// 看看它多麼簡單！
fn combine_vecs(
    v: Vec&lt;i32&gt;,
    u: Vec&lt;i32&gt;,
) -&gt; impl Iterator&lt;Item=i32&gt; {
    v.into_iter().chain(u.into_iter()).cycle()
}

fn main() {
    let v1 = vec![1, 2, 3];
    let v2 = vec![4, 5];
    let mut v3 = combine_vecs(v1, v2);
    assert_eq!(Some(1), v3.next());
    assert_eq!(Some(2), v3.next());
    assert_eq!(Some(3), v3.next());
    assert_eq!(Some(4), v3.next());
    assert_eq!(Some(5), v3.next());
    println!(&quot;all done&quot;);
}
</code></pre></pre>
<p>更重要的是，某些 Rust 類型無法寫出。例如，每個閉包都有自己未命名的具體類型。在使用 <code>impl Trait</code> 語法之前，必須在堆上進行分配才能返回閉包。但是現在你可以像下面這樣靜態地完成所有操作：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 返回一個將輸入和 `y` 相加的函數
fn make_adder_function(y: i32) -&gt; impl Fn(i32) -&gt; i32 {
    let closure = move |x: i32| { x + y };
    closure
}

fn main() {
    let plus_one = make_adder_function(1);
    assert_eq!(plus_one(2), 3);
}
</code></pre></pre>
<p>您還可以使用 <code>impl Trait</code> 返回使用 <code>map</code> 或 <code>filter</code> 閉包的迭代器！這使得使用 <code>map</code> 和 <code>filter</code> 更容易。因為閉包類型沒有名稱，所以如果函數返回帶閉包的迭代器，則無法寫出顯式的返回類型。但是有了 <code>impl Trait</code>，你就可以輕鬆地做到這一點：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn double_positives&lt;'a&gt;(numbers: &amp;'a Vec&lt;i32&gt;) -&gt; impl Iterator&lt;Item = i32&gt; + 'a {
    numbers
        .iter()
        .filter(|x| x &gt; &amp;&amp;0)
        .map(|x| x * 2)
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clone"><a class="header" href="#clone">Clone</a></h1>
<p>當處理資源時，默認的行為是在賦值或函數調用的同時將它們轉移。但是我們有時候也需要
把資源複製一份。</p>
<p><a href="https://rustwiki.org/zh-CN/std/clone/trait.Clone.html"><code>Clone</code></a> trait 正好幫助我們完成這任務。通常，我們可以使用由 <code>Clone</code>
trait 定義的 <code>.clone()</code> 方法。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 不含資源的單元結構體
#[derive(Debug, Clone, Copy)]
struct Nil;

// 一個包含資源的結構體，它實現了 `Clone` trait
#[derive(Clone, Debug)]
struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);

fn main() {
    // 實例化 `Nil`
    let nil = Nil;
    // 複製 `Nil`，沒有資源用於移動（move）
    let copied_nil = nil;

    // 兩個 `Nil` 都可以獨立使用
    println!(&quot;original: {:?}&quot;, nil);
    println!(&quot;copy: {:?}&quot;, copied_nil);

    // 實例化 `Pair`
    let pair = Pair(Box::new(1), Box::new(2));
    println!(&quot;original: {:?}&quot;, pair);

    // 將 `pair` 綁定到 `moved_pair`，移動（move）了資源
    let moved_pair = pair;
    println!(&quot;copy: {:?}&quot;, moved_pair);

    // 報錯！`pair` 已失去了它的資源。
    //println!(&quot;original: {:?}&quot;, pair);
    // 試一試 ^ 取消此行註釋。

    // 將 `moved_pair`（包括其資源）克隆到 `cloned_pair`。
    let cloned_pair = moved_pair.clone();
    // 使用 std::mem::drop 來銷燬原始的 pair。
    drop(moved_pair);

    // 報錯！`moved_pair` 已被銷燬。
    //println!(&quot;copy: {:?}&quot;, moved_pair);
    // 試一試 ^ 將此行註釋掉。

    // 由 .clone() 得來的結果仍然可用！
    println!(&quot;clone: {:?}&quot;, cloned_pair);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="父-trait"><a class="header" href="#父-trait">父 trait</a></h1>
<p>Rust 沒有“繼承”，但是您可以將一個 trait 定義為另一個 trait 的超集（即父 trait）。例如：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait Person {
    fn name(&amp;self) -&gt; String;
}

// Person 是 Student 的父 trait。
// 實現 Student 需要你也 impl 了 Person。
trait Student: Person {
    fn university(&amp;self) -&gt; String;
}

trait Programmer {
    fn fav_language(&amp;self) -&gt; String;
}

// CompSciStudent (computer science student，計算機科學的學生) 是 Programmer 和 Student 兩者的子類。
// 實現 CompSciStudent 需要你同時 impl 了兩個父 trait。
trait CompSciStudent: Programmer + Student {
    fn git_username(&amp;self) -&gt; String;
}

fn comp_sci_student_greeting(student: &amp;dyn CompSciStudent) -&gt; String {
    format!(
        &quot;My name is {} and I attend {}. My favorite language is {}. My Git username is {}&quot;,
        student.name(),
        student.university(),
        student.fav_language(),
        student.git_username()
    )
}

fn main() {}
</code></pre></pre>
<h3 id="參見-56"><a class="header" href="#參見-56">參見：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/book/ch19-03-advanced-traits.html#%E7%88%B6-trait-%E7%94%A8%E6%96%BC%E5%9C%A8%E5%8F%A6%E4%B8%80%E5%80%8B-trait-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9F%90-trait-%E7%9A%84%E5%8A%9F%E8%83%BD">《Rust 程序設計語言》的“父級 trait”章節</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="消除重疊-trait"><a class="header" href="#消除重疊-trait">消除重疊 trait</a></h1>
<p>一個類型可以實現許多不同的 trait。如果兩個 trait 都需要相同的名稱怎麼辦？例如，許多 trait 可能擁有名為 <code>get()</code> 的方法。他們甚至可能有不同的返回類型！</p>
<p>有個好消息：由於每個 trait 實現都有自己的 <code>impl</code> 塊，因此很清楚您要實現哪個 trait 的 <code>get</code> 方法。</p>
<p>何時需要<strong>調用</strong>這些方法呢？為了消除它們之間的歧義，我們必須使用完全限定語法（Fully Qualified Syntax）。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait UsernameWidget {
    // 從這個 widget 中獲取選定的用戶名
    fn get(&amp;self) -&gt; String;
}

trait AgeWidget {
    // 從這個 widget 中獲取選定的年齡
    fn get(&amp;self) -&gt; u8;
}

// 同時具有 UsernameWidget 和 AgeWidget 的表單
struct Form {
    username: String,
    age: u8,
}

impl UsernameWidget for Form {
    fn get(&amp;self) -&gt; String {
        self.username.clone()
    }
}

impl AgeWidget for Form {
    fn get(&amp;self) -&gt; u8 {
        self.age
    }
}

fn main() {
    let form = Form{
        username: &quot;rustacean&quot;.to_owned(),
        age: 28,
    };

    // 如果取消註釋此行，則會收到一條錯誤消息，提示 “multiple `get` found”（找到了多個`get`）。
    // 因為畢竟有多個名為 `get` 的方法。
    // println!(&quot;{}&quot;, form.get());

    let username = &lt;Form as UsernameWidget&gt;::get(&amp;form);
    assert_eq!(&quot;rustacean&quot;.to_owned(), username);
    let age = &lt;Form as AgeWidget&gt;::get(&amp;form);
    assert_eq!(28, age);
}
</code></pre></pre>
<h3 id="參見-57"><a class="header" href="#參見-57">參見：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/book/ch19-03-advanced-traits.html#%E5%AE%8C%E5%85%A8%E9%99%90%E5%AE%9A%E8%AA%9E%E6%B3%95%E8%88%87%E6%B6%88%E6%AD%A7%E7%BE%A9%E8%AA%BF%E7%94%A8%E7%9B%B8%E5%90%8C%E5%90%8D%E7%A8%B1%E7%9A%84%E6%96%B9%E6%B3%95">《Rust 程序設計語言》中關於“完全限定語法”的章節</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用-macro_rules-來創建宏"><a class="header" href="#使用-macro_rules-來創建宏">使用 <code>macro_rules!</code> 來創建宏</a></h1>
<p>Rust 提供了一個強大的宏系統，可進行元編程（metaprogramming）。你已經在前面的
章節中看到，宏看起來和函數很像，只不過名稱末尾有一個感嘆號 <code>!</code> 。宏並不產
生函數調用，而是展開成源碼，並和程序的其餘部分一起被編譯。Rust 又有一點和 C
以及其他語言都不同，那就是 Rust 的宏會展開為抽象語法樹（AST，abstract syntax
tree），而不是像字符串預處理那樣直接替換成代碼，這樣就不會產生無法預料的優先權
錯誤。</p>
<p>宏是通過 <code>macro_rules!</code> 宏來創建的。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 這是一個簡單的宏，名為 `say_hello`。
macro_rules! say_hello {
    // `()` 表示此宏不接受任何參數。
    () =&gt; (
        // 此宏將會展開成這個代碼塊裡面的內容。
        println!(&quot;Hello!&quot;);
    )
}

fn main() {
    // 這個調用將會展開成 `println(&quot;Hello&quot;);`!
    say_hello!()
}
</code></pre></pre>
<p>為什麼宏是有用的？</p>
<ol>
<li>不寫重複代碼（DRY，Don't repeat yourself.）。很多時候你需要在一些地方針對不同
的類型實現類似的功能，這時常常可以使用宏來避免重複代碼（稍後詳述）。</li>
<li>領域專用語言（DSL，domain-specific language）。宏允許你為特定的目的創造特定的
語法（稍後詳述）。</li>
<li>可變接口（variadic interface）。有時你需要能夠接受不定數目參數的接口，比如
<code>println!</code>，根據格式化字符串的不同，它需要接受任意多的參數（稍後詳述）。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="語法"><a class="header" href="#語法">語法</a></h1>
<p>在下面的小節中，我們將展示如何在 Rust 中定義宏。基本的概念有三個：</p>
<ul>
<li><a href="macros/designators.html">模式與指示符</a></li>
<li><a href="macros/overload.html">重載</a></li>
<li><a href="macros/repeat.html">重複</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="指示符"><a class="header" href="#指示符">指示符</a></h1>
<p>宏的參數使用一個美元符號 <code>$</code> 作為前綴，並使用一個<strong>指示符</strong>（designator）來
註明類型：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">macro_rules! create_function {
    // 此宏接受一個 `ident` 指示符表示的參數，並創建一個名為 `$func_name` 的函數。
    // `ident` 指示符用於變量名或函數名
    ($func_name:ident) =&gt; (
        fn $func_name() {
            // `stringify!` 宏把 `ident` 轉換成字符串。
            println!(&quot;You called {:?}()&quot;,
                     stringify!($func_name))
        }
    )
}

// 藉助上述宏來創建名為 `foo` 和 `bar` 的函數。
create_function!(foo);
create_function!(bar);

macro_rules! print_result {
    // 此宏接受一個 `expr` 類型的表達式，並將它作為字符串，連同其結果一起
    // 打印出來。
    // `expr` 指示符表示表達式。
    ($expression:expr) =&gt; (
        // `stringify!` 把表達式*原樣*轉換成一個字符串。
        println!(&quot;{:?} = {:?}&quot;,
                 stringify!($expression),
                 $expression)
    )
}

fn main() {
    foo();
    bar();

    print_result!(1u32 + 1);

    // 回想一下，代碼塊也是表達式！
    print_result!({
        let x = 1u32;

        x * x + 2 * x - 1
    });
}
</code></pre></pre>
<p>這裡列出全部指示符：</p>
<ul>
<li><code>block</code></li>
<li><code>expr</code> 用於表達式</li>
<li><code>ident</code> 用於變量名或函數名</li>
<li><code>item</code></li>
<li><code>pat</code> (<strong>模式</strong> <em>pattern</em>)</li>
<li><code>path</code></li>
<li><code>stmt</code> (<strong>語句</strong> <em>statement</em>)</li>
<li><code>tt</code> (<strong>標記樹</strong> <em>token tree</em>)</li>
<li><code>ty</code> (<strong>類型</strong> <em>type</em>)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="重載"><a class="header" href="#重載">重載</a></h1>
<p>宏可以重載，從而接受不同的參數組合。在這方面，<code>macro_rules!</code> 的作用類似於
匹配（match）代碼塊：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 根據你調用它的方式，`test!` 將以不同的方式來比較 `$left` 和 `$right`。
macro_rules! test {
    // 參數不需要使用逗號隔開。
    // 參數可以任意組合！
    ($left:expr; and $right:expr) =&gt; (
        println!(&quot;{:?} and {:?} is {:?}&quot;,
                 stringify!($left),
                 stringify!($right),
                 $left &amp;&amp; $right)
    );
    // ^ 每個分支都必須以分號結束。
    ($left:expr; or $right:expr) =&gt; (
        println!(&quot;{:?} or {:?} is {:?}&quot;,
                 stringify!($left),
                 stringify!($right),
                 $left || $right)
    );
}

fn main() {
    test!(1i32 + 1 == 2i32; and 2i32 * 2 == 4i32);
    test!(true; or false);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="重複"><a class="header" href="#重複">重複</a></h1>
<p>宏在參數列表中可以使用 <code>+</code> 來表示一個參數可能出現一次或多次，使用 <code>*</code> 來表示該
參數可能出現零次或多次。</p>
<p>在下面例子中，把模式這樣： <code>$(...),+</code> 包圍起來，就可以匹配一個或多個用逗號隔開
的表達式。另外注意到，宏定義的最後一個分支可以不用分號作為結束。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// `min!` 將求出任意數量的參數的最小值。
macro_rules! find_min {
    // 基本情形：
    ($x:expr) =&gt; ($x);
    // `$x` 後面跟著至少一個 `$y,`
    ($x:expr, $($y:expr),+) =&gt; (
        // 對 `$x` 後面的 `$y` 們調用 `find_min!` 
        std::cmp::min($x, find_min!($($y),+))
    )
}

fn main() {
    println!(&quot;{}&quot;, find_min!(1u32));
    println!(&quot;{}&quot;, find_min!(1u32 + 2 , 2u32));
    println!(&quot;{}&quot;, find_min!(5u32, 2u32 * 3, 4u32));
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dry-不寫重複代碼"><a class="header" href="#dry-不寫重複代碼">DRY (不寫重複代碼)</a></h1>
<p>通過提取函數或測試集的公共部分，宏可以讓你寫出 DRY 的代碼（DRY 是 Don't Repeat
Yourself 的縮寫，意思為 “不要寫重複代碼”）。這裡給出一個例子，對 <code>Vec&lt;T&gt;</code> 實現
並測試了關於 <code>+=</code>、<code>*=</code> 和 <code>-=</code> 等運算符。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::ops::{Add, Mul, Sub};

macro_rules! assert_equal_len {
    // `tt`（token tree，標記樹）指示符表示運算符和標記。
    ($a:ident, $b: ident, $func:ident, $op:tt) =&gt; (
        assert!($a.len() == $b.len(),
                &quot;{:?}: dimension mismatch: {:?} {:?} {:?}&quot;,
                stringify!($func),
                ($a.len(),),
                stringify!($op),
                ($b.len(),));
    )
}

macro_rules! op {
    ($func:ident, $bound:ident, $op:tt, $method:ident) =&gt; (
        fn $func&lt;T: $bound&lt;T, Output=T&gt; + Copy&gt;(xs: &amp;mut Vec&lt;T&gt;, ys: &amp;Vec&lt;T&gt;) {
            assert_equal_len!(xs, ys, $func, $op);

            for (x, y) in xs.iter_mut().zip(ys.iter()) {
                *x = $bound::$method(*x, *y);
                // *x = x.$method(*y);
            }
        }
    )
}

// 實現 `add_assign`、`mul_assign` 和 `sub_assign` 等函數。
op!(add_assign, Add, +=, add);
op!(mul_assign, Mul, *=, mul);
op!(sub_assign, Sub, -=, sub);

mod test {
    use std::iter;
    macro_rules! test {
        ($func: ident, $x:expr, $y:expr, $z:expr) =&gt; {
            #[test]
            fn $func() {
                for size in 0usize..10 {
                    let mut x: Vec&lt;_&gt; = iter::repeat($x).take(size).collect();
                    let y: Vec&lt;_&gt; = iter::repeat($y).take(size).collect();
                    let z: Vec&lt;_&gt; = iter::repeat($z).take(size).collect();

                    super::$func(&amp;mut x, &amp;y);

                    assert_eq!(x, z);
                }
            }
        }
    }

    // 測試 `add_assign`、`mul_assign` 和 `sub_assign`
    test!(add_assign, 1u32, 2u32, 3u32);
    test!(mul_assign, 2u32, 3u32, 6u32);
    test!(sub_assign, 3u32, 2u32, 1u32);
}

</code></pre></pre>
<pre><code class="language-bash">$ rustc --test dry.rs &amp;&amp; ./dry
running 3 tests
test test::mul_assign ... ok
test test::add_assign ... ok
test test::sub_assign ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dsl領域專用語言"><a class="header" href="#dsl領域專用語言">DSL（領域專用語言）</a></h1>
<p>DSL 是 Rust 的宏中集成的微型 “語言”。這種語言是完全合法的，因為宏系統會把它轉換
成普通的 Rust 語法樹，它只不過看起來像是另一種語言而已。這就允許你為一些特定功能
創造一套簡潔直觀的語法（當然是有限制的）。</p>
<p>比如說我想要定義一套小的計算器 API，可以傳給它表達式，它會把結果打印到控制檯上。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">macro_rules! calculate {
    (eval $e:expr) =&gt; {{
        {
            let val: usize = $e; // 強制類型為整型
            println!(&quot;{} = {}&quot;, stringify!{$e}, val);
        }
    }};
}

fn main() {
    calculate! {
        eval 1 + 2 // 看到了吧，`eval` 可並不是 Rust 的關鍵字！
    }

    calculate! {
        eval (1 + 2) * (3 / 4)
    }
}
</code></pre></pre>
<p>輸出:</p>
<pre><code class="language-txt">1 + 2 = 3
(1 + 2) * (3 / 4) = 0
</code></pre>
<p>這個例子非常簡單，但是已經有很多利用宏開發的複雜接口了，比如
<a href="https://crates.io/crates/lazy_static"><code>lazy_static</code></a> 和
<a href="https://crates.io/crates/clap"><code>clap</code></a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="可變參數接口"><a class="header" href="#可變參數接口">可變參數接口</a></h1>
<p>可變參數接口可以接受任意數目的參數。比如說 <code>println</code> 就可以，其參數的數目是由
格式化字符串指定的。</p>
<p>我們可以把之前的 <code>calculater!</code> 宏改寫成可變參數接口：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">macro_rules! calculate {
    // 單個 `eval` 的模式
    (eval $e:expr) =&gt; {{
        {
            let val: usize = $e; // Force types to be integers
            println!(&quot;{} = {}&quot;, stringify!{$e}, val);
        }
    }};

    // 遞歸地拆解多重的 `eval`
    (eval $e:expr, $(eval $es:expr),+) =&gt; {{
        calculate! { eval $e }
        calculate! { $(eval $es),+ }
    }};
}

fn main() {
    calculate! { // 媽媽快看，可變參數的 `calculate!`！
        eval 1 + 2,
        eval 3 + 4,
        eval (2 * 3) + 1
    }
}
</code></pre></pre>
<p>輸出：</p>
<pre><code class="language-txt">1 + 2 = 3
3 + 4 = 7
(2 * 3) + 1 = 7
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="錯誤處理"><a class="header" href="#錯誤處理">錯誤處理</a></h1>
<p>錯誤處理（error handling）是處理可能發生的失敗情況的過程。例如讀取一個文件時
失敗了，如果繼續使用這個<strong>無效的</strong>輸入，那顯然是有問題的。注意到並且顯式地
處理這種錯誤可以避免程序的其他部分產生潛在的問題。</p>
<p>在 Rust 中有多種處理錯誤的方式，在接下來的小節中會一一介紹。它們多少有些
區別，使用場景也不盡相同。總的來說：</p>
<ul>
<li>顯式的 <code>panic</code> 主要用於測試，以及處理不可恢復的錯誤。在原型開發中這很有用，比如
用來測試還沒有實現的函數，不過這時使用 <code>unimplemented</code> 更能表達意圖。另外在
測試中，<code>panic</code> 是一種顯式地失敗（fail）的好方法。</li>
<li><code>Option</code> 類型是為了值是可選的、或者缺少值並不是錯誤的情況準備的。比如說尋找
父目錄時，<code>/</code> 和 <code>C:</code> 這樣的目錄就沒有父目錄，這應當並不是一個錯誤。當處理
<code>Option</code> 時，<code>unwrap</code> 可用於原型開發，也可以用於能夠確定 <code>Option</code> 中一定有值
的情形。然而 <code>expect</code> 更有用，因為它允許你指定一條錯誤信息，以免萬一還是出現
了錯誤。</li>
<li>當錯誤有可能發生，且應當由調用者處理時，使用 <code>Result</code>。你也可以 <code>unwrap</code> 然後
使用 <code>expect</code>，但是除了在測試或者原型開發中，請不要這樣做。</li>
</ul>
<p>有關錯誤處理的更多內容，可參考<a href="https://rustwiki.org/zh-CN/book/ch09-00-error-handling.html">官方文檔</a>的錯誤處理的章節。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic"><a class="header" href="#panic"><code>panic</code></a></h1>
<p>我們將要看到的最簡單的錯誤處理機制就是 <code>panic</code>。它會打印一個錯誤消息，開始
回退（unwind）任務，且通常會退出程序。這裡我們顯式地在錯誤條件下調用 <code>panic</code>：</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">fn give_princess(gift: &amp;str) {
    // 公主討厭蛇，所以如果公主表示厭惡的話我們要停止！
    if gift == &quot;snake&quot; { panic!(&quot;AAAaaaaa!!!!&quot;); }

    println!(&quot;I love {}s!!!!!&quot;, gift);
}

fn main() {
    give_princess(&quot;teddy bear&quot;);
    give_princess(&quot;snake&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option-和-unwrap"><a class="header" href="#option-和-unwrap"><code>Option</code> 和 <code>unwrap</code></a></h1>
<p>上個例子展示瞭如何主動地引入程序失敗（program failure）。當公主收到蛇這件不合適
的禮物時，我們就讓程序 <code>panic</code>。但是，如果公主期待收到禮物，卻沒收到呢？這同樣
是一件糟糕的事情，所以我們要想辦法來解決這個問題！</p>
<p>我們<strong>可以</strong>檢查空字符串（<code>&quot;&quot;</code>），就像處理蛇那樣。但既然我們在用 Rust，不如
讓編譯器辨別沒有禮物的情況。</p>
<p>在標準庫（<code>std</code>）中有個叫做 <code>Option&lt;T&gt;</code>（option 中文意思是 “選項”）的枚舉
類型，用於有 “不存在” 的可能性的情況。它表現為以下兩個 “option”（選項）中
的一個：</p>
<ul>
<li><code>Some(T)</code>：找到一個屬於 <code>T</code> 類型的元素</li>
<li><code>None</code>：找不到相應元素</li>
</ul>
<p>這些選項可以通過 <code>match</code> 顯式地處理，或使用 <code>unwrap</code> 隱式地處理。隱式處理要麼
返回 <code>Some</code> 內部的元素，要麼就 <code>panic</code>。</p>
<p>請注意，手動使用 <a href="https://rustwiki.org/zh-CN/std/option/enum.Option.html#method.expect">expect</a> 方法自定義 <code>panic</code> 信息是可能的，但相比顯式
處理，<code>unwrap</code> 的輸出仍顯得不太有意義。在下面例子中，顯式處理將舉出更受控制的
結果，同時如果需要的話，仍然可以使程序 <code>panic</code>。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">// 平民（commoner）們見多識廣，收到什麼禮物都能應對。
// 所有禮物都顯式地使用 `match` 來處理。
fn give_commoner(gift: Option&lt;&amp;str&gt;) {
    // 指出每種情況下的做法。
    match gift {
        Some(&quot;snake&quot;) =&gt; println!(&quot;Yuck! I'm throwing that snake in a fire.&quot;),
        Some(inner)   =&gt; println!(&quot;{}? How nice.&quot;, inner),
        None          =&gt; println!(&quot;No gift? Oh well.&quot;),
    }
}

// 養在深閨人未識的公主見到蛇就會 `panic`（恐慌）。
// 這裡所有的禮物都使用 `unwrap` 隱式地處理。
fn give_princess(gift: Option&lt;&amp;str&gt;) {
    // `unwrap` 在接收到 `None` 時將返回 `panic`。
    let inside = gift.unwrap();
    if inside == &quot;snake&quot; { panic!(&quot;AAAaaaaa!!!!&quot;); }

    println!(&quot;I love {}s!!!!!&quot;, inside);
}

fn main() {
    let food  = Some(&quot;chicken&quot;);
    let snake = Some(&quot;snake&quot;);
    let void  = None;

    give_commoner(food);
    give_commoner(snake);
    give_commoner(void);

    let bird = Some(&quot;robin&quot;);
    let nothing = None;

    give_princess(bird);
    give_princess(nothing);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用--解開-option"><a class="header" href="#使用--解開-option">使用 <code>?</code> 解開 <code>Option</code></a></h1>
<p>你可以使用 <code>match</code> 語句來解開 <code>Option</code>，但使用 <code>?</code> 運算符通常會更容易。如果 <code>x</code> 是 <code>Option</code>，那麼若 <code>x</code> 是 <code>Some</code> ，對<code>x?</code>表達式求值將返回底層值，否則無論函數是否正在執行都將終止且返回 <code>None</code>。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn next_birthday(current_age: Option&lt;u8&gt;) -&gt; Option&lt;String&gt; {
    // 如果 `current_age` 是 `None`，這將返回 `None`。
    // 如果 `current_age` 是 `Some`，內部的 `u8` 將賦值給 `next_age`。
    let next_age: u8 = current_age?;
    Some(format!(&quot;Next year I will be {}&quot;, next_age))
}
</code></pre></pre>
<p>你可以將多個 <code>?</code> 鏈接在一起，以使代碼更具可讀性。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Person {
    job: Option&lt;Job&gt;,
}

#[derive(Clone, Copy)]
struct Job {
    phone_number: Option&lt;PhoneNumber&gt;,
}

#[derive(Clone, Copy)]
struct PhoneNumber {
    area_code: Option&lt;u8&gt;,
    number: u32,
}

impl Person {

    // 獲取此人的工作電話號碼的區號（如果存在的話）。
    fn work_phone_area_code(&amp;self) -&gt; Option&lt;u8&gt; {
        // 沒有`？`運算符的話，這將需要很多的嵌套的 `match` 語句。
        // 這將需要更多代碼——嘗試自己編寫一下，看看哪個更容易。
        self.job?.phone_number?.area_code
    }
}

fn main() {
    let p = Person {
        job: Some(Job {
            phone_number: Some(PhoneNumber {
                area_code: Some(61),
                number: 439222222,
            }),
        }),
    };

    assert_eq!(p.work_phone_area_code(), Some(61));
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="組合算子map"><a class="header" href="#組合算子map">組合算子：<code>map</code></a></h1>
<p><code>match</code> 是處理 <code>Option</code> 的一個可用的方法，但你會發現大量使用它會很繁瑣，特別是當
操作只對一種輸入是有效的時。這時，可以使用<a href="https://rustwiki.org/zh-CN/reference/glossary.html#%E7%B5%84%E5%90%88%E7%AE%97%E5%AD%90">組合算子</a>（combinator），以
模塊化的風格來管理控制流。</p>
<p><code>Option</code> 有一個內置方法 <code>map()</code>，這個組合算子可用於 <code>Some -&gt; Some</code> 和
<code>None -&gt; None</code> 這樣的簡單映射。多個不同的 <code>map()</code> 調用可以串起來，這樣更加靈活。</p>
<p>在下面例子中，<code>process()</code> 輕鬆取代了前面的所有函數，且更加緊湊。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#![allow(dead_code)]

#[derive(Debug)] enum Food { Apple, Carrot, Potato }

#[derive(Debug)] struct Peeled(Food);
#[derive(Debug)] struct Chopped(Food);
#[derive(Debug)] struct Cooked(Food);

// 削皮。如果沒有食物，就返回 `None`。否則返回削好皮的食物。
fn peel(food: Option&lt;Food&gt;) -&gt; Option&lt;Peeled&gt; {
    match food {
        Some(food) =&gt; Some(Peeled(food)),
        None       =&gt; None,
    }
}

// 切食物。如果沒有食物，就返回 `None`。否則返回切好的食物。
fn chop(peeled: Option&lt;Peeled&gt;) -&gt; Option&lt;Chopped&gt; {
    match peeled {
        Some(Peeled(food)) =&gt; Some(Chopped(food)),
        None               =&gt; None,
    }
}

// 烹飪食物。這裡，我們使用 `map()` 來替代 `match` 以處理各種情況。
fn cook(chopped: Option&lt;Chopped&gt;) -&gt; Option&lt;Cooked&gt; {
    chopped.map(|Chopped(food)| Cooked(food))
}

// 這個函數會完成削皮切塊烹飪一條龍。我們把 `map()` 串起來，以簡化代碼。
fn process(food: Option&lt;Food&gt;) -&gt; Option&lt;Cooked&gt; {
    food.map(|f| Peeled(f))
        .map(|Peeled(f)| Chopped(f))
        .map(|Chopped(f)| Cooked(f))
}

// 在嘗試吃食物之前確認食物是否存在是非常重要的！
fn eat(food: Option&lt;Cooked&gt;) {
    match food {
        Some(food) =&gt; println!(&quot;Mmm. I love {:?}&quot;, food),
        None       =&gt; println!(&quot;Oh no! It wasn't edible.&quot;),
    }
}

fn main() {
    let apple = Some(Food::Apple);
    let carrot = Some(Food::Carrot);
    let potato = None;

    let cooked_apple = cook(chop(peel(apple)));
    let cooked_carrot = cook(chop(peel(carrot)));

    // 現在讓我們試試看起來更簡單的 `process()`。
    let cooked_potato = process(potato);

    eat(cooked_apple);
    eat(cooked_carrot);
    eat(cooked_potato);
}
</code></pre></pre>
<h3 id="參見-58"><a class="header" href="#參見-58">參見：</a></h3>
<p><a href="error/option_unwrap/../../fn/closures.html">閉包</a>, <a href="https://rustwiki.org/zh-CN/std/option/enum.Option.html"><code>Option</code></a>, 和 <a href="https://rustwiki.org/zh-CN/std/option/enum.Option.html#method.map"><code>Option::map()</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="組合算子and_then"><a class="header" href="#組合算子and_then">組合算子：<code>and_then</code></a></h1>
<p><code>map()</code> 以鏈式調用的方式來簡化 <code>match</code> 語句。然而，如果以返回類型是 <code>Option&lt;T&gt;</code>
的函數作為 <code>map()</code> 的參數，會導致出現嵌套形式 <code>Option&lt;Option&lt;T&gt;&gt;</code>。這樣多層串聯
調用就會變得混亂。所以有必要引入 <code>and_then()</code>，在某些語言中它叫做 flatmap。</p>
<p><code>and_then()</code> 使用被 <code>Option</code> 包裹的值來調用其輸入函數並返回結果。 如果 <code>Option</code>
是 <code>None</code>，那麼它返回 <code>None</code>。</p>
<p>在下面例子中，<code>cookable_v2()</code> 會產生一個 <code>Option&lt;Food&gt;</code>。如果在這裡使用 <code>map()</code>
而不是 <code>and_then()</code> 將會得到 <code>Option&lt;Option&lt;Food&gt;&gt;</code>，這對 <code>eat()</code> 來說是一個
無效類型。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#![allow(dead_code)]

#[derive(Debug)] enum Food { CordonBleu, Steak, Sushi }
#[derive(Debug)] enum Day { Monday, Tuesday, Wednesday }

// 我們沒有製作壽司所需的原材料（ingredient）（有其他的原材料）。
fn have_ingredients(food: Food) -&gt; Option&lt;Food&gt; {
    match food {
        Food::Sushi =&gt; None,
        _           =&gt; Some(food),
    }
}

// 我們擁有全部食物的食譜，除了法國藍帶豬排（Cordon Bleu）的。
fn have_recipe(food: Food) -&gt; Option&lt;Food&gt; {
    match food {
        Food::CordonBleu =&gt; None,
        _                =&gt; Some(food),
    }
}


// 要做一份好菜，我們需要原材料和食譜。
// 我們可以藉助一系列 `match` 來表達這個邏輯：
fn cookable_v1(food: Food) -&gt; Option&lt;Food&gt; {
    match have_ingredients(food) {
        None       =&gt; None,
        Some(food) =&gt; match have_recipe(food) {
            None       =&gt; None,
            Some(food) =&gt; Some(food),
        },
    }
}

// 也可以使用 `and_then()` 把上面的邏輯改寫得更緊湊：
fn cookable_v2(food: Food) -&gt; Option&lt;Food&gt; {
    have_ingredients(food).and_then(have_recipe)
}

fn eat(food: Food, day: Day) {
    match cookable_v2(food) {
        Some(food) =&gt; println!(&quot;Yay! On {:?} we get to eat {:?}.&quot;, day, food),
        None       =&gt; println!(&quot;Oh no. We don't get to eat on {:?}?&quot;, day),
    }
}

fn main() {
    let (cordon_bleu, steak, sushi) = (Food::CordonBleu, Food::Steak, Food::Sushi);

    eat(cordon_bleu, Day::Monday);
    eat(steak, Day::Tuesday);
    eat(sushi, Day::Wednesday);
}
</code></pre></pre>
<h3 id="參見-59"><a class="header" href="#參見-59">參見：</a></h3>
<p><a href="error/option_unwrap/../../fn/closures.html">閉包</a>，<a href="https://rustwiki.org/zh-CN/std/option/enum.Option.html#method.map"><code>Option::map()</code></a>, 和 <a href="https://rustwiki.org/zh-CN/std/option/enum.Option.html#method.and_then"><code>Option::and_then()</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="結果-result"><a class="header" href="#結果-result">結果 <code>Result</code></a></h1>
<p><a href="https://rustwiki.org/zh-CN/std/result/enum.Result.html"><code>Result</code></a> 是 <a href="https://rustwiki.org/zh-CN/std/option/enum.Option.html"><code>Option</code></a> 類型的更豐富的版本，描述的是可能
的<strong>錯誤</strong>而不是可能的<strong>不存在</strong>。</p>
<p>也就是說，<code>Result&lt;T，E&gt;</code> 可以有兩個結果的其中一個：</p>
<ul>
<li><code>Ok&lt;T&gt;</code>：找到 <code>T</code> 元素</li>
<li><code>Err&lt;E&gt;</code>：找到 <code>E</code> 元素，<code>E</code> 即表示錯誤的類型。</li>
</ul>
<p>按照約定，預期結果是 “Ok”，而意外結果是 “Err”。</p>
<p><code>Result</code> 有很多類似 <code>Option</code> 的方法。例如 <code>unwrap()</code>，它要麼舉出元素
<code>T</code>，要麼就 <code>panic</code>。 對於事件的處理，<code>Result</code> 和 <code>Option</code> 有很多相同的組合算子。</p>
<p>在使用 Rust 時，你可能會遇到返回 <code>Result</code> 類型的方法，例如 <a href="https://rustwiki.org/zh-CN/std/primitive.str.html#method.parse"><code>parse()</code></a>
方法。它並不是總能把字符串解析成指定的類型，所以 <code>parse()</code> 返回一個
<code>Result</code> 表示可能的失敗。</p>
<p>我們來看看當 <code>parse()</code> 字符串成功和失敗時會發生什麼：</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; i32 {
    // 我們試著用 `unwrap()` 把數字放出來。它會咬我們一口嗎？
    let first_number = first_number_str.parse::&lt;i32&gt;().unwrap();
    let second_number = second_number_str.parse::&lt;i32&gt;().unwrap();
    first_number * second_number
}

fn main() {
    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
    println!(&quot;double is {}&quot;, twenty);

    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    println!(&quot;double is {}&quot;, tt);
}
</code></pre></pre>
<p>在失敗的情況下，<code>parse()</code> 產生一個錯誤，留給 <code>unwrap()</code> 來解包併產生 <code>panic</code>。另
外，<code>panic</code> 會退出我們的程序，並提供一個讓人很不爽的錯誤消息。</p>
<p>為了改善錯誤消息的質量，我們應該更具體地瞭解返回類型並考慮顯式地處理錯誤。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result-的-map"><a class="header" href="#result-的-map"><code>Result</code> 的 <code>map</code></a></h1>
<p>上一節的 <code>multiply</code> 函數的 panic 設計不是健壯的（robust）。一般地，我們希望把
錯誤返回給調用者，這樣它可以決定迴應錯誤的正確方式。</p>
<p>首先，我們需要了解需要處理的錯誤類型是什麼。為了確定 <code>Err</code> 的類型，我們可以
用 <a href="https://rustwiki.org/zh-CN/std/primitive.str.html#method.parse"><code>parse()</code></a> 來試驗。Rust 已經為 <a href="https://rustwiki.org/zh-CN/std/primitive.i32.html"><code>i32</code></a> 類型使用
<a href="https://rustwiki.org/zh-CN/std/str/trait.FromStr.html"><code>FromStr</code></a> trait 實現了 <code>parse()</code>。結果表明，這裡的 <code>Err</code> 類型被指定為
<a href="https://rustwiki.org/zh-CN/std/num/struct.ParseIntError.html"><code>ParseIntError</code></a>。</p>
<blockquote>
<p>譯註：原文沒有具體講如何確定 <code>Err</code> 的類型。由於目前用於獲取類型的函數仍然是不
穩定的，我們可以用間接的方法。使用下面的代碼：</p>
<pre><code class="language-rust editable ignore">fn main () {
    let i: () = &quot;t&quot;.parse::&lt;i32&gt;();
}
</code></pre>
<p>由於不可能把 <code>Result</code> 類型賦給單元類型變量 <code>i</code>，編譯器會提示我們：</p>
<pre><code class="language-text">note: expected type `()`
         found type `std::result::Result&lt;i32, std::num::ParseIntError&gt;`
</code></pre>
<p>這樣就知道了 <code>parse&lt;i32&gt;</code> 函數的返回類型詳情。</p>
</blockquote>
<p>在下面的例子中，使用簡單的 <code>match</code> 語句導致了更加繁瑣的代碼。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

// 修改了上一節中的返回類型，現在使用模式匹配而不是 `unwrap()`。
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    match first_number_str.parse::&lt;i32&gt;() {
        Ok(first_number)  =&gt; {
            match second_number_str.parse::&lt;i32&gt;() {
                Ok(second_number)  =&gt; {
                    Ok(first_number * second_number)
                },
                Err(e) =&gt; Err(e),
            }
        },
        Err(e) =&gt; Err(e),
    }
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    // 這種情形下仍然會給出正確的答案。
    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
    print(twenty);

    // 這種情況下就會提供一條更有用的錯誤信息。
    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    print(tt);
}
</code></pre></pre>
<p>幸運的是，<code>Option</code> 的 <code>map</code>、<code>and_then</code>、以及很多其他組合算子也為 <code>Result</code> 實現
了。官方文檔的 <a href="https://rustwiki.org/zh-CN/std/result/enum.Result.html"><code>Result</code></a> 一節包含完整的方法列表。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

// 就像 `Option` 那樣，我們可以使用 `map()` 之類的組合算子。
// 除去寫法外，這個函數與上面那個完全一致，它的作用是：
// 如果值是合法的，計算其乘積，否則返回錯誤。
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    first_number_str.parse::&lt;i32&gt;().and_then(|first_number| {
        second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number)
    })
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    // 這種情況下仍然會給出正確的答案。
    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
    print(twenty);

    // 這種情況下就會提供一條更有用的錯誤信息。
    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    print(tt);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="給-result-取別名"><a class="header" href="#給-result-取別名">給 <code>Result</code> 取別名</a></h1>
<p>當我們要重用某個 <code>Result</code> 類型時，該怎麼辦呢？回憶一下，Rust 允許我們
創建<a href="error/result/../../types/alias.html">別名</a>。若某個 <code>Result</code> 有可能被重用，我們可以方便地給它取一個別名。</p>
<p>在模塊的層面上創建別名特別有幫助。同一模塊中的錯誤常常會有相同的 <code>Err</code> 類
型，所以單個別名就能簡便地定義<strong>所有</strong>相關的 <code>Result</code>。這太有用了，以至於標準庫
也提供了一個別名： <a href="https://rustwiki.org/zh-CN/std/io/type.Result.html"><code>io::Result</code></a>！</p>
<p>下面給出一個簡短的示例來展示語法：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

// 為帶有錯誤類型 `ParseIntError` 的 `Result` 定義一個泛型別名。
type AliasedResult&lt;T&gt; = Result&lt;T, ParseIntError&gt;;

// 使用上面定義過的別名來表示上一節中的 `Result&lt;i32,ParseIntError&gt;` 類型。
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; AliasedResult&lt;i32&gt; {
    first_number_str.parse::&lt;i32&gt;().and_then(|first_number| {
        second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number)
    })
}

// 在這裡使用別名又讓我們節省了一些代碼量。
fn print(result: AliasedResult&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<h3 id="參見-60"><a class="header" href="#參見-60">參見：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/io/type.Result.html"><code>io::Result</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="提前返回"><a class="header" href="#提前返回">提前返回</a></h1>
<p>在上一個例子中，我們顯式地使用組合算子處理了錯誤。另一種處理錯誤的方式是使用
<code>match</code> 語句和<strong>提前返回</strong>（early return）的結合。</p>
<p>這也就是說，如果發生錯誤，我們可以停止函數的執行然後返回錯誤。對有些人來說，這樣
的代碼更好寫，更易讀。這次我們使用提前返回改寫之前的例子：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = match first_number_str.parse::&lt;i32&gt;() {
        Ok(first_number)  =&gt; first_number,
        Err(e) =&gt; return Err(e),
    };

    let second_number = match second_number_str.parse::&lt;i32&gt;() {
        Ok(second_number)  =&gt; second_number,
        Err(e) =&gt; return Err(e),
    };

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<p>到此為止，我們已經學會了如何使用組合算子和提前返回顯式地處理錯誤。我們一般是
想要避免 panic 的，但顯式地處理所有錯誤確實顯得過於繁瑣。</p>
<p>在下一部分，我們將看到，當只是需要 <code>unwrap</code> 並且不產生 <code>panic</code> 時，可以使用
<code>?</code> 來達到同樣的效果。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="引入-"><a class="header" href="#引入-">引入 <code>?</code></a></h1>
<p>有時我們只是想 <code>unwrap</code> 且避免產生 <code>panic</code>。到現在為止，對 <code>unwrap</code> 的錯誤處理都在強迫
我們一層層地嵌套，然而我們只是想把裡面的變量拿出來。<code>?</code> 正是為這種情況準備的。</p>
<p>當找到一個 <code>Err</code> 時，可以採取兩種行動：</p>
<ol>
<li><code>panic!</code>，不過我們已經決定要儘可能避免 panic 了。</li>
<li>返回它，因為 <code>Err</code> 就意味著它已經不能被處理了。</li>
</ol>
<p><code>?</code> <strong>幾乎</strong><sup class="footnote-reference"><a href="#†">1</a></sup> 就等於一個會返回 <code>Err</code> 而不是 <code>panic</code> 的 <code>unwrap</code>。我們來看看
怎樣簡化之前使用組合算子的例子：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = first_number_str.parse::&lt;i32&gt;()?;
    let second_number = second_number_str.parse::&lt;i32&gt;()?;

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<h2 id="try-宏"><a class="header" href="#try-宏"><code>try!</code> 宏</a></h2>
<p>在 <code>?</code> 出現以前，相同的功能是使用 <code>try!</code> 宏完成的。現在我們推薦使用 <code>?</code> 運算符，但是
在老代碼中仍然會看到 <code>try!</code>。如果使用 <code>try!</code> 的話，上一個例子中的 <code>multiply</code> 函數
看起來會像是這樣：</p>
<pre><pre class="playground"><code class="language-rust editable edition2015">use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = try!(first_number_str.parse::&lt;i32&gt;());
    let second_number = try!(second_number_str.parse::&lt;i32&gt;());

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<div class="footnote-definition" id="†"><sup class="footnote-definition-label">1</sup>
<p>更多細節請看<a href="error/result/../multiple_error_types/reenter_question_mark.html"><code>?</code> 的更多用法</a>。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="處理多種錯誤類型"><a class="header" href="#處理多種錯誤類型">處理多種錯誤類型</a></h1>
<p>前面出現的例子都是很方便的情況；都是 <code>Result</code> 和其他 <code>Result</code> 交互，還有 <code>Option</code>
和其他 <code>Option</code> 交互。</p>
<p>有時 <code>Option</code> 需要和 <code>Result</code> 進行交互，或是 <code>Result&lt;T, Error1&gt;</code> 需要和
<code>Result&lt;T, Error2&gt;</code> 進行交互。在這類情況下，我們想要以一種方式來管理不同的錯誤
類型，使得它們可組合且易於交互。</p>
<p>在下面代碼中，<code>unwrap</code> 的兩個實例生成了不同的錯誤類型。<code>Vec::first</code> 返回一個
<code>Option</code>，而 <code>parse::&lt;i32&gt;</code> 返回一個 <code>Result&lt;i32, ParseIntError&gt;</code>：</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; i32 {
    let first = vec.first().unwrap(); // 生成錯誤 1
    2 * first.parse::&lt;i32&gt;().unwrap() // 生成錯誤 2
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    
    println!(&quot;The first doubled is {}&quot;, double_first(numbers));
    
    println!(&quot;The first doubled is {}&quot;, double_first(empty));
    // 錯誤1：輸入 vector 為空
    
    println!(&quot;The first doubled is {}&quot;, double_first(strings));
    // 錯誤2：此元素不能解析成數字
}
</code></pre></pre>
<p>在下面幾節中，我們會看到處理這類問題的幾種策略。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="從-option-中取出-result"><a class="header" href="#從-option-中取出-result">從 <code>Option</code> 中取出 <code>Result</code></a></h1>
<p>處理混合錯誤類型的最基本的手段就是讓它們互相包含。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Option&lt;Result&lt;i32, ParseIntError&gt;&gt; {
    vec.first().map(|first| {
        first.parse::&lt;i32&gt;().map(|n| 2 * n)
    })
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    println!(&quot;The first doubled is {:?}&quot;, double_first(numbers));

    println!(&quot;The first doubled is {:?}&quot;, double_first(empty));
    // Error 1: the input vector is empty

    println!(&quot;The first doubled is {:?}&quot;, double_first(strings));
    // Error 2: the element doesn't parse to a number
}
</code></pre></pre>
<p>有時候我們不想再處理錯誤（比如使用 <a href="error/multiple_error_types/../result/enter_question_mark.html"><code>?</code></a> 的時候），但如果
<code>Option</code> 是 <code>None</code> 則繼續處理錯誤。一些組合算子可以讓我們輕鬆地交換 <code>Result</code> 和
<code>Option</code>。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;Option&lt;i32&gt;, ParseIntError&gt; {
    let opt = vec.first().map(|first| {
        first.parse::&lt;i32&gt;().map(|n| 2 * n)
    });

    opt.map_or(Ok(None), |r| r.map(Some))
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    println!(&quot;The first doubled is {:?}&quot;, double_first(numbers));
    println!(&quot;The first doubled is {:?}&quot;, double_first(empty));
    println!(&quot;The first doubled is {:?}&quot;, double_first(strings));
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="定義一個錯誤類型"><a class="header" href="#定義一個錯誤類型">定義一個錯誤類型</a></h1>
<p>有時候把所有不同的錯誤都視為一種錯誤類型會簡化代碼。我們將用一個自定義錯誤類型來
演示這一點。</p>
<p>Rust 允許我們定義自己的錯誤類型。一般來說，一個 “好的” 錯誤類型應當：</p>
<ul>
<li>用同一個類型代表了多種錯誤</li>
<li>向用戶提供了清楚的錯誤信息</li>
<li>能夠容易地與其他類型比較
<ul>
<li>好的例子：<code>Err(EmptyVec)</code></li>
<li>壞的例子：<code>Err(&quot;Please use a vector with at least one element&quot;.to_owned())</code></li>
</ul>
</li>
<li>能夠容納錯誤的具體信息
<ul>
<li>好的例子：<code>Err(BadChar(c, position))</code></li>
<li>壞的例子：<code>Err(&quot;+ cannot be used here&quot;.to_owned())</code></li>
</ul>
</li>
<li>能夠與其他錯誤很好地整合</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::error;
use std::fmt;

type Result&lt;T&gt; = std::result::Result&lt;T, DoubleError&gt;;

#[derive(Debug, Clone)]
// 定義我們的錯誤類型，這種類型可以根據錯誤處理的實際情況定製。
// 我們可以完全自定義錯誤類型，也可以在類型中完全採用底層的錯誤實現，
// 也可以介於二者之間。
struct DoubleError;

// 錯誤的生成與它如何顯示是完全沒關係的。沒有必要擔心複雜的邏輯會導致混亂的顯示。
//
// 注意我們沒有儲存關於錯誤的任何額外信息，也就是說，如果不修改我們的錯誤類型定義的話，
// 就無法指明是哪個字符串解析失敗了。
impl fmt::Display for DoubleError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;invalid first item to double&quot;)
    }
}

// 為 `DoubleError` 實現 `Error` trait，這樣其他錯誤可以包裹這個錯誤類型。
impl error::Error for DoubleError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn error::Error + 'static)&gt; {
        // 泛型錯誤，沒有記錄其內部原因。
        None
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    vec.first()
       // 把錯誤換成我們的新類型。
       .ok_or(DoubleError)
       .and_then(|s| {
            s.parse::&lt;i32&gt;()
                // 這裡也換成新類型。
                .map_err(|_| DoubleError)
                .map(|i| 2 * i)
        })
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="把錯誤-裝箱"><a class="header" href="#把錯誤-裝箱">把錯誤 “裝箱”</a></h1>
<p>如果又想寫簡單的代碼，又想保存原始錯誤信息，一個方法是把它們<a href="https://rustwiki.org/zh-CN/std/boxed/struct.Box.html">裝箱</a>（<code>Box</code>）。這
樣做的壞處就是，被包裝的錯誤類型只能在運行時瞭解，而不能被<a href="https://rustwiki.org/zh-CN/book/ch17-02-trait-objects.html#trait-%E5%B0%8D%E8%B1%A1%E5%9F%B7%E8%A1%8C%E5%8B%95%E6%85%8B%E5%88%86%E7%99%BC">靜態地
判別</a>。</p>
<p>對任何實現了 <code>Error</code> trait 的類型，標準庫的 <code>Box</code> 通過 <a href="https://rustwiki.org/zh-CN/std/convert/trait.From.html"><code>From</code></a> 為它們提供了
到 <code>Box&lt;Error&gt;</code> 的轉換。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::error;
use std::fmt;

// 為 `Box&lt;error::Error&gt;` 取別名。
type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;dyn error::Error&gt;&gt;;

#[derive(Debug, Clone)]
struct EmptyVec;

impl fmt::Display for EmptyVec {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;invalid first item to double&quot;)
    }
}

impl error::Error for EmptyVec {
    fn description(&amp;self) -&gt; &amp;str {
        &quot;invalid first item to double&quot;
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;dyn error::Error&gt; {
        // 泛型錯誤。沒有記錄其內部原因。
        None
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    vec.first()
       .ok_or_else(|| EmptyVec.into())  // 裝箱
       .and_then(|s| {
            s.parse::&lt;i32&gt;()
                .map_err(|e| e.into())  // 裝箱
                .map(|i| 2 * i)
        })
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<h3 id="參見-61"><a class="header" href="#參見-61">參見：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/book/ch17-02-trait-objects.html#trait-%E5%B0%8D%E8%B1%A1%E5%9F%B7%E8%A1%8C%E5%8B%95%E6%85%8B%E5%88%86%E7%99%BC">動態分發</a> and <a href="https://rustwiki.org/zh-CN/std/error/trait.Error.html"><code>Error</code> trait</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-的其他用法"><a class="header" href="#-的其他用法"><code>?</code> 的其他用法</a></h1>
<p>注意在上一個例子中，我們調用 <code>parse</code> 後總是立即將錯誤從標準庫的錯誤 <code>map</code>（映射）到裝箱錯誤。</p>
<pre><code class="language-rust ignore">.and_then(|s| s.parse::&lt;i32&gt;()
    .map_err(|e| e.into())
</code></pre>
<p>因為這個操作很簡單常見，如果有省略寫法就好了。遺憾的是 <code>and_then</code> 不夠靈活，所以實現不了這樣的寫法。不過，我們可以使用 <code>?</code> 來代替它。</p>
<p><code>?</code> 之前被解釋為要麼 <code>unwrap</code>，要麼 <code>return Err(err)</code>，這只是在大多數情況下是正確的。<code>?</code> 實際上是指  <code>unwrap</code> 或 <code>return Err(From::from(err))</code>。由於 <code>From::from</code> 是不同類型之間的轉換工具，也就是說，如果在錯誤可轉換成返回類型地方使用 <code>?</code>，它將自動轉換成返回類型。</p>
<p>我們在這裡使用 <code>?</code> 重寫之前的例子。重寫後，只要為我們的錯誤類型實現 <code>From::from</code>，就可以不再使用 <code>map_err</code>。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::error;
use std::fmt;

// 為 `Box&lt;error::Error&gt;` 取別名。
type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;dyn error::Error&gt;&gt;;

#[derive(Debug)]
struct EmptyVec;

impl fmt::Display for EmptyVec {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;invalid first item to double&quot;)
    }
}

impl error::Error for EmptyVec {}

// 這裡的結構和之前一樣，但是這次沒有把所有的 `Result` 和 `Option` 串起來，
// 而是使用 `?` 立即得到內部值。
fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    let first = vec.first().ok_or(EmptyVec)?;
    let parsed = first.parse::&lt;i32&gt;()?;
    Ok(2 * parsed)
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<p>這段代碼已經相當清晰了。與原來的 <code>panic</code> 相比，除了返回類型是 <code>Result</code> 之外，它就像是把所有的 <code>unwrap</code> 調用都換成 <code>?</code> 一樣。因此必須在頂層解構它們。</p>
<h3 id="參見-62"><a class="header" href="#參見-62">參見：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/convert/trait.From.html"><code>From::from</code></a> 和 <a href="https://rustwiki.org/zh-CN/reference/expressions/operator-expr.html#%E5%95%8F%E8%99%9F%E6%93%8D%E4%BD%9C%E7%AC%A6"><code>?</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包裹錯誤"><a class="header" href="#包裹錯誤">包裹錯誤</a></h1>
<p>把錯誤裝箱這種做法也可以改成把它包裹到你自己的錯誤類型中。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::error;
use std::num::ParseIntError;
use std::fmt;

type Result&lt;T&gt; = std::result::Result&lt;T, DoubleError&gt;;

#[derive(Debug)]
enum DoubleError {
    EmptyVec,
    // 在這個錯誤類型中，我們採用 `parse` 的錯誤類型中 `Err` 部分的實現。
    // 若想提供更多信息，則該類型中還需要加入更多數據。
    Parse(ParseIntError),
}

impl fmt::Display for DoubleError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {
            DoubleError::EmptyVec =&gt;
                write!(f, &quot;please use a vector with at least one element&quot;),
            // 這是一個封裝（wrapper），它採用內部各類型對 `fmt` 的實現。
            DoubleError::Parse(ref e) =&gt; e.fmt(f),
        }
    }
}

impl error::Error for DoubleError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn error::Error + 'static)&gt; {
        match *self {
            DoubleError::EmptyVec =&gt; None,
            // 原因採取內部對錯誤類型的實現。它隱式地轉換成了 trait 對象 `&amp;error:Error`。
            // 這可以工作，因為內部的類型已經實現了 `Error` trait。
            DoubleError::Parse(ref e) =&gt; Some(e),
        }
    }
}

// 實現從 `ParseIntError` 到 `DoubleError` 的轉換。
// 在使用 `?` 時，或者一個 `ParseIntError` 需要轉換成 `DoubleError` 時，它會被自動調用。
impl From&lt;ParseIntError&gt; for DoubleError {
    fn from(err: ParseIntError) -&gt; DoubleError {
        DoubleError::Parse(err)
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    let first = vec.first().ok_or(DoubleError::EmptyVec)?;
    let parsed = first.parse::&lt;i32&gt;()?;

    Ok(2 * parsed)
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<p>這種做法會在錯誤處理中增加一些模板化的代碼，而且也不是所有的應用都需要這樣做。一些
庫可以幫你處理模板化代碼的問題。</p>
<h3 id="see-also-1"><a class="header" href="#see-also-1">See also:</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/convert/trait.From.html"><code>From::from</code></a> and <a href="error/multiple_error_types/../../custom_types/enum.html"><code>枚舉類型</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="遍歷-result"><a class="header" href="#遍歷-result">遍歷 <code>Result</code></a></h1>
<p><code>Iter::map</code> 操作可能失敗，比如：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let numbers: Vec&lt;_&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .collect();
    println!(&quot;Results: {:?}&quot;, numbers);
}
</code></pre></pre>
<p>我們來看一些處理這種問題的策略：</p>
<h2 id="使用-filter_map-忽略失敗的項"><a class="header" href="#使用-filter_map-忽略失敗的項">使用 <code>filter_map()</code> 忽略失敗的項</a></h2>
<p><code>filter_map</code> 會調用一個函數，過濾掉為 <code>None</code> 的所有結果。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let numbers: Vec&lt;_&gt; = strings
        .into_iter()
        .filter_map(|s| s.parse::&lt;i32&gt;().ok())
        .collect();
    println!(&quot;Results: {:?}&quot;, numbers);
}
</code></pre></pre>
<h2 id="使用-collect-使整個操作失敗"><a class="header" href="#使用-collect-使整個操作失敗">使用 <code>collect()</code> 使整個操作失敗</a></h2>
<p><code>Result</code> 實現了 <code>FromIter</code>，因此結果的向量（<code>Vec&lt;Result&lt;T, E&gt;&gt;</code>）可以被轉換成
結果包裹著向量（<code>Result&lt;Vec&lt;T&gt;, E&gt;</code>）。一旦找到一個 <code>Result::Err</code> ，遍歷就被終止。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let numbers: Result&lt;Vec&lt;_&gt;, _&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .collect();
    println!(&quot;Results: {:?}&quot;, numbers);
}
</code></pre></pre>
<p>同樣的技巧可以對 <code>Option</code> 使用。</p>
<h2 id="使用-partition-收集所有合法的值與錯誤"><a class="header" href="#使用-partition-收集所有合法的值與錯誤">使用 <code>Partition()</code> 收集所有合法的值與錯誤</a></h2>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let (numbers, errors): (Vec&lt;_&gt;, Vec&lt;_&gt;) = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .partition(Result::is_ok);
    println!(&quot;Numbers: {:?}&quot;, numbers);
    println!(&quot;Errors: {:?}&quot;, errors);
}
</code></pre></pre>
<p>當你看著這些結果時，你會發現所有東西還在 <code>Result</code> 中保存著。要取出它們，需要一些
模板化的代碼。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let (numbers, errors): (Vec&lt;_&gt;, Vec&lt;_&gt;) = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .partition(Result::is_ok);
    let numbers: Vec&lt;_&gt; = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec&lt;_&gt; = errors.into_iter().map(Result::unwrap_err).collect();
    println!(&quot;Numbers: {:?}&quot;, numbers);
    println!(&quot;Errors: {:?}&quot;, errors);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="標準庫類型"><a class="header" href="#標準庫類型">標準庫類型</a></h1>
<p>標準庫提供了很多自定義類型，在<strong>原生類型</strong>基礎上進行了大量擴充。這是部分自定義
類型：</p>
<ul>
<li>可增長的 <code>String</code>（字符串），如: <code>&quot;hello world&quot;</code></li>
<li>可增長的向量（vector）: <code>[1, 2, 3]</code></li>
<li>選項類型（optional types）: <code>Option&lt;i32&gt;</code></li>
<li>錯誤處理類型（error handling types）: <code>Result&lt;i32, i32&gt;</code></li>
<li>堆分配的指針（heap allocated pointers）: <code>Box&lt;i32&gt;</code></li>
</ul>
<h3 id="參見-63"><a class="header" href="#參見-63">參見：</a></h3>
<p><a href="primitives.html">原生類型</a> 和 <a href="https://rustwiki.org/zh-CN/std/">標準庫</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="箱子棧和堆"><a class="header" href="#箱子棧和堆">箱子、棧和堆</a></h1>
<p>在 Rust 中，所有值默認都是棧分配的。通過創建 <code>Box&lt;T&gt;</code>，可以把值<strong>裝箱</strong>（boxed）來
使它在堆上分配。箱子（box，即 <code>Box&lt;T&gt;</code> 類型的實例）是一個智能指針，指向堆分配
的 <code>T</code> 類型的值。當箱子離開作用域時，它的析構函數會被調用，內部的對象會被
銷燬，堆上分配的內存也會被釋放。</p>
<p>被裝箱的值可以使用 <code>*</code> 運算符進行解引用；這會移除掉一層裝箱。</p>
<pre><pre class="playground"><code class="language-rust editalbe edition2021">use std::mem;

#[allow(dead_code)]
#[derive(Debug, Clone, Copy)]
struct Point {
    x: f64,
    y: f64,
}

#[allow(dead_code)]
struct Rectangle {
    p1: Point,
    p2: Point,
}

fn origin() -&gt; Point {
    Point { x: 0.0, y: 0.0 }
}

fn boxed_origin() -&gt; Box&lt;Point&gt; {
    // 在堆上分配這個點（point），並返回一個指向它的指針
    Box::new(Point { x: 0.0, y: 0.0 })
}

fn main() {
    // （所有的類型標註都不是必需的）
    // 棧分配的變量
    let point: Point = origin();
    let rectangle: Rectangle = Rectangle {
        p1: origin(),
        p2: Point { x: 3.0, y: 4.0 }
    };

    // 堆分配的 rectangle（矩形）
    let boxed_rectangle: Box&lt;Rectangle&gt; = Box::new(Rectangle {
        p1: origin(),
        p2: origin()
    });

    // 函數的輸出可以裝箱
    let boxed_point: Box&lt;Point&gt; = Box::new(origin());

    // 兩層裝箱
    let box_in_a_box: Box&lt;Box&lt;Point&gt;&gt; = Box::new(boxed_origin());

    println!(&quot;Point occupies {} bytes in the stack&quot;,
             mem::size_of_val(&amp;point));
    println!(&quot;Rectangle occupies {} bytes in the stack&quot;,
             mem::size_of_val(&amp;rectangle));

    // box 的寬度就是指針寬度
    println!(&quot;Boxed point occupies {} bytes in the stack&quot;,
             mem::size_of_val(&amp;boxed_point));
    println!(&quot;Boxed rectangle occupies {} bytes in the stack&quot;,
             mem::size_of_val(&amp;boxed_rectangle));
    println!(&quot;Boxed box occupies {} bytes in the stack&quot;,
             mem::size_of_val(&amp;box_in_a_box));

    // 將包含在 `boxed_point` 中的數據複製到 `unboxed_point`
    let unboxed_point: Point = *boxed_point;
    println!(&quot;Unboxed point occupies {} bytes in the stack&quot;,
             mem::size_of_val(&amp;unboxed_point));
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="動態數組-vector"><a class="header" href="#動態數組-vector">動態數組 vector</a></h1>
<p>vector 是大小可變的數組。和 slice（切片）類似，它們的大小在編譯時是未知的，但
它們可以隨時擴大或縮小。一個 vector 使用 3 個詞來表示：一個指向數據的指針，vector
的長度，還有它的容量。此容量指明瞭要為這個 vector 保留多少內存。vector 的長度
只要小於該容量，就可以隨意增長；當需要超過這個閾值時，會給 vector 重新分配一段
更大的容量。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">fn main() {
    // 迭代器可以被收集到 vector 中
    let collected_iterator: Vec&lt;i32&gt; = (0..10).collect();
    println!(&quot;Collected (0..10) into: {:?}&quot;, collected_iterator);

    // `vec!` 宏可用來初始化一個 vector
    let mut xs = vec![1i32, 2, 3];
    println!(&quot;Initial vector: {:?}&quot;, xs);

    // 在 vector 的尾部插入一個新的元素
    println!(&quot;Push 4 into the vector&quot;);
    xs.push(4);
    println!(&quot;Vector: {:?}&quot;, xs);

    // 報錯！不可變 vector 不可增長
    collected_iterator.push(0);
    // 改正 ^ 將此行註釋掉

    // `len` 方法獲得一個 vector 的當前大小
    println!(&quot;Vector size: {}&quot;, xs.len());

    // 下標使用中括號表示（從 0 開始）
    println!(&quot;Second element: {}&quot;, xs[1]);

    // `pop` 移除 vector 的最後一個元素並將它返回
    println!(&quot;Pop last element: {:?}&quot;, xs.pop());

    // 超出下標範圍將拋出一個 panic
    println!(&quot;Fourth element: {}&quot;, xs[3]);
    // 改正 ^ 註釋掉此行

    // 迭代一個 `Vector` 很容易
    println!(&quot;Contents of xs:&quot;);
    for x in xs.iter() {
        println!(&quot;&gt; {}&quot;, x);
    }

    // 可以在迭代 `Vector` 的同時，使用獨立變量（`i`）來記錄迭代次數
    for (i, x) in xs.iter().enumerate() {
        println!(&quot;In position {} we have value {}&quot;, i, x);
    }

    // 多虧了 `iter_mut`，可變的 `Vector` 在迭代的同時，其中每個值都能被修改
    for x in xs.iter_mut() {
        *x *= 3;
    }
    println!(&quot;Updated vector: {:?}&quot;, xs);
}
</code></pre></pre>
<p>更多 <code>Vec</code> 方法可以在 <a href="https://rustwiki.org/zh-CN/std/vec/">std::vec</a> 模塊中找到。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符串"><a class="header" href="#字符串">字符串</a></h1>
<p>Rust 中有兩種字符串類型：<code>String</code> 和 <code>&amp;str</code>。</p>
<p><code>String</code> 被存儲為由字節組成的 vector（<code>Vec&lt;u8&gt;</code>），但保證了它一定是一個有效的
UTF-8 序列。<code>String</code> 是堆分配的，可增長的，且不是零結尾的（null terminated）。</p>
<p><code>&amp;str</code> 是一個總是指向有效 UTF-8 序列的切片（<code>&amp;[u8]</code>），並可用來查看 <code>String</code> 的內容，就如同 <code>&amp;[T]</code> 是 <code>Vec&lt;T&gt;</code> 的全部或部分引用。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // （所有的類型標註都不是必需的）
    // 一個對只讀內存中分配的字符串的引用
    let pangram: &amp;'static str = &quot;the quick brown fox jumps over the lazy dog&quot;;
    println!(&quot;Pangram: {}&quot;, pangram);

    // 逆序迭代單詞，這裡並沒有分配新的字符串
    println!(&quot;Words in reverse&quot;);
    for word in pangram.split_whitespace().rev() {
        println!(&quot;&gt; {}&quot;, word);
    }

    // 複製字符到一個 vector，排序並移除重複值
    let mut chars: Vec&lt;char&gt; = pangram.chars().collect();
    chars.sort();
    chars.dedup();

    // 創建一個空的且可增長的 `String`
    let mut string = String::new();
    for c in chars {
        // 在字符串的尾部插入一個字符
        string.push(c);
        // 在字符串尾部插入一個字符串
        string.push_str(&quot;, &quot;);
    }

    // 這個縮短的字符串是原字符串的一個切片，所以沒有執行新的分配操作
    let chars_to_trim: &amp;[char] = &amp;[' ', ','];
    let trimmed_str: &amp;str = string.trim_matches(chars_to_trim);
    println!(&quot;Used characters: {}&quot;, trimmed_str);

    // 堆分配一個字符串
    let alice = String::from(&quot;I like dogs&quot;);
    // 分配新內存並存儲修改過的字符串
    let bob: String = alice.replace(&quot;dog&quot;, &quot;cat&quot;);

    println!(&quot;Alice says: {}&quot;, alice);
    println!(&quot;Bob says: {}&quot;, bob);
}
</code></pre></pre>
<p>更多 <code>str</code>/<code>String</code> 方法可以在 <a href="https://rustwiki.org/zh-CN/std/str/">std::str</a> 和 <a href="https://rustwiki.org/zh-CN/std/string/">std::string</a> 模塊中
找到。</p>
<h2 id="字面量與轉義字符"><a class="header" href="#字面量與轉義字符">字面量與轉義字符</a></h2>
<p>書寫含有特殊字符的字符串字面量有很多種方法。它們都會產生類似的 <code>&amp;str</code>，所以最好
選擇最方便的寫法。類似地，字節串（byte string）字面量也有多種寫法，它們都會產生
<code>&amp;[u8; N]</code> 類型。</p>
<p>通常特殊字符是使用反斜槓字符 <code>\</code> 來轉義的，這樣你就可以在字符串中寫入各種各樣的
字符，甚至是不可打印的字符以及你不知道如何輸入的字符。如果你需要反斜槓字符，再用
另一個反斜槓來轉義它就可以，像這樣：<code>\\</code>。</p>
<p>字面量中出現的字符串或字符定界符必須轉義：<code>&quot;\&quot;&quot;</code>、<code>'\''</code>。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // 通過轉義，可以用十六進制值來表示字節。
    let byte_escape = &quot;I'm writing \x52\x75\x73\x74!&quot;;
    println!(&quot;What are you doing\x3F (\\x3F means ?) {}&quot;, byte_escape);

    // 也可以使用 Unicode 碼位表示。
    let unicode_codepoint = &quot;\u{211D}&quot;;
    let character_name = &quot;\&quot;DOUBLE-STRUCK CAPITAL R\&quot;&quot;;

    println!(&quot;Unicode character {} (U+211D) is called {}&quot;,
                unicode_codepoint, character_name );


    let long_string = &quot;String literals
                        can span multiple lines.
                        The linebreak and indentation here -&gt;\
                        &lt;- can be escaped too!&quot;;
    println!(&quot;{}&quot;, long_string);
}
</code></pre></pre>
<p>有時會有太多需要轉義的字符，或者是直接原樣寫出會更便利。這時可以使用原始字符
串（raw string）。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let raw_str = r&quot;Escapes don't work here: \x3F \u{211D}&quot;;
    println!(&quot;{}&quot;, raw_str);

    // 如果你要在原始字符串中寫引號，請在兩邊加一對 #
    let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#;
    println!(&quot;{}&quot;, quotes);

    // 如果字符串中需要寫 &quot;#，那就在定界符中使用更多的 #。
    // 可使用的 # 的數目沒有限制。
    let longer_delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###;
    println!(&quot;{}&quot;, longer_delimiter);
}
</code></pre></pre>
<p>想要非 UTF-8 字符串（記住，<code>&amp;str</code> 和 <code>String</code> 都必須是合法的 UTF-8 序列），或者
需要一個字節數組，其中大部分是文本？請使用字節串（byte string）！</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::str;

fn main() {
    // 注意這並不是一個 &amp;str
    let bytestring: &amp;[u8; 20] = b&quot;this is a bytestring&quot;;

    // 字節串沒有實現 Display，所以它們的打印功能有些受限
    println!(&quot;A bytestring: {:?}&quot;, bytestring);

    // 字節串可以使用單字節的轉義字符...
    let escaped = b&quot;\x52\x75\x73\x74 as bytes&quot;;
    // ...但不能使用 Unicode 轉義字符
    // let escaped = b&quot;\u{211D} is not allowed&quot;;
    println!(&quot;Some escaped bytes: {:?}&quot;, escaped);


    // 原始字節串和原始字符串的寫法一樣
    let raw_bytestring = br&quot;\u{211D} is not escaped here&quot;;
    println!(&quot;{:?}&quot;, raw_bytestring);

    // 把字節串轉換為 &amp;str 可能失敗
    if let Ok(my_str) = str::from_utf8(raw_bytestring) {
        println!(&quot;And the same as text: '{}'&quot;, my_str);
    }

    let quotes = br#&quot;You can also use &quot;fancier&quot; formatting, \
                    like with normal raw strings&quot;#;

    // 字節串可以不使用 UTF-8 編碼
    let shift_jis = b&quot;\x82\xe6\x82\xa8\x82\xb1\x82&quot;; // SHIFT-JIS 編碼的 &quot;ようこそ&quot;

    // 但這樣的話它們就無法轉換成 &amp;str 了
    match str::from_utf8(shift_jis) {
        Ok(my_str) =&gt; println!(&quot;Conversion successful: '{}'&quot;, my_str),
        Err(e) =&gt; println!(&quot;Conversion failed: {:?}&quot;, e),
    };
}

</code></pre></pre>
<p>若需要在編碼間轉換，請使用 <a href="https://crates.io/crates/encoding">encoding</a> crate。</p>
<p>Rust 參考中的 <a href="https://rustwiki.org/zh-CN/reference/tokens.html">Tokens</a> 一章詳細地列出了書寫字符串字面量和轉義字符的方法。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="選項-option"><a class="header" href="#選項-option">選項 <code>Option</code></a></h1>
<p>有時候想要捕捉到程序某部分的失敗信息，而不是調用 <code>panic!</code>；這可使用 <code>Option</code>
枚舉類型來實現。</p>
<p><code>Option&lt;T&gt;</code> 有兩個變量：</p>
<ul>
<li><code>None</code>，表明失敗或缺少值</li>
<li><code>Some(value)</code>，元組結構體，封裝了一個 <code>T</code> 類型的值 <code>value</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">// 不會 `panic!` 的整數除法。
fn checked_division(dividend: i32, divisor: i32) -&gt; Option&lt;i32&gt; {
    if divisor == 0 {
        // 失敗表示成 `None` 取值
        None
    } else {
        // 結果 Result 被包裝到 `Some` 取值中
        Some(dividend / divisor)
    }
}

// 此函數處理可能失敗的除法
fn try_division(dividend: i32, divisor: i32) {
    // `Option` 值可以進行模式匹配，就和其他枚舉類型一樣
    match checked_division(dividend, divisor) {
        None =&gt; println!(&quot;{} / {} failed!&quot;, dividend, divisor),
        Some(quotient) =&gt; {
            println!(&quot;{} / {} = {}&quot;, dividend, divisor, quotient)
        },
    }
}

fn main() {
    try_division(4, 2);
    try_division(1, 0);

    // 綁定 `None` 到一個變量需要類型標註
    let none: Option&lt;i32&gt; = None;
    let _equivalent_none = None::&lt;i32&gt;;

    let optional_float = Some(0f32);

    // 解包 `Some` 將取出被包裝的值。
    println!(&quot;{:?} unwraps to {:?}&quot;, optional_float, optional_float.unwrap());

    // 解包 `None` 將會引發 `panic!`。
    println!(&quot;{:?} unwraps to {:?}&quot;, none, none.unwrap());
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="結果-result-1"><a class="header" href="#結果-result-1">結果 <code>Result</code></a></h1>
<p>我們已經看到 <code>Option</code> 枚舉類型可以用作可能失敗的函數的返回值，其中返回 <code>None</code>
可以表明失敗。但是有時要強調<strong>為什麼</strong>一個操作會失敗。為做到這點，我們提供
了 <code>Result</code> 枚舉類型。</p>
<p><code>Result&lt;T, E&gt;</code> 類型擁有兩個取值：</p>
<ul>
<li><code>Ok(value)</code> 表示操作成功，幷包裝操作返回的 <code>value</code>（<code>value</code> 擁有 <code>T</code> 類型）。</li>
<li><code>Err(why)</code>，表示操作失敗，幷包裝 <code>why</code>，它（但願）能夠解釋失敗的原因（<code>why</code>
擁有 <code>E</code> 類型）。</li>
</ul>
<pre><pre class="playground"><code class="language-rust editalbe ignore mdbook-runnable edition2021">mod checked {
    // 我們想要捕獲的數學 “錯誤”
    #[derive(Debug)]
    pub enum MathError {
        DivisionByZero,
        NegativeLogarithm,
        NegativeSquareRoot,
    }

    pub type MathResult = Result&lt;f64, MathError&gt;;

    pub fn div(x: f64, y: f64) -&gt; MathResult {
        if y == 0.0 {
            // 此操作將會失敗，那麼（與其讓程序崩潰）不如把失敗的原因包裝在
            // `Err` 中並返回
            Err(MathError::DivisionByZero)
        } else {
            // 此操作是有效的，返回包裝在 `Ok` 中的結果
            Ok(x / y)
        }
    }

    pub fn sqrt(x: f64) -&gt; MathResult {
        if x &lt; 0.0 {
            Err(MathError::NegativeSquareRoot)
        } else {
            Ok(x.sqrt())
        }
    }

    pub fn ln(x: f64) -&gt; MathResult {
        if x &lt; 0.0 {
            Err(MathError::NegativeLogarithm)
        } else {
            Ok(x.ln())
        }
    }
}

// `op(x, y)` === `sqrt(ln(x / y))`
fn op(x: f64, y: f64) -&gt; f64 {
    // 這是一個三層的 match 金字塔！
    match checked::div(x, y) {
        Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
        Ok(ratio) =&gt; match checked::ln(ratio) {
            Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
            Ok(ln) =&gt; match checked::sqrt(ln) {
                Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
                Ok(sqrt) =&gt; sqrt,
            },
        },
    }
}

fn main() {
    // 這會失敗嗎？
    println!(&quot;{}&quot;, op(1.0, 10.0));
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-運算符"><a class="header" href="#-運算符"><code>?</code> 運算符</a></h1>
<p>把 result 用 match 連接起來會顯得很難看；幸運的是，<code>?</code> 運算符可以把這種邏輯變得
乾淨漂亮。<code>?</code> 運算符用在返回值為 <code>Result</code> 的表達式後面，它等同於這樣一個匹配
表達式：其中 <code>Err(err)</code> 分支展開成提前返回的 <code>return Err(err)</code>，而 <code>Ok(ok)</code>
分支展開成 <code>ok</code> 表達式。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">mod checked {
    #[derive(Debug)]
    enum MathError {
        DivisionByZero,
        NegativeLogarithm,
        NegativeSquareRoot,
    }

    type MathResult = Result&lt;f64, MathError&gt;;

    fn div(x: f64, y: f64) -&gt; MathResult {
        if y == 0.0 {
            Err(MathError::DivisionByZero)
        } else {
            Ok(x / y)
        }
    }

    fn sqrt(x: f64) -&gt; MathResult {
        if x &lt; 0.0 {
            Err(MathError::NegativeSquareRoot)
        } else {
            Ok(x.sqrt())
        }
    }

    fn ln(x: f64) -&gt; MathResult {
        if x &lt; 0.0 {
            Err(MathError::NegativeLogarithm)
        } else {
            Ok(x.ln())
        }
    }

    // 中間函數
    fn op_(x: f64, y: f64) -&gt; MathResult {
        // 如果 `div` “失敗” 了，那麼返回 `DivisionByZero`
        let ratio = div(x, y)?;

        // 如果 `ln` “失敗” 了，那麼返回 `NegativeLogarithm`
        let ln = ln(ratio)?;

        sqrt(ln)
    }

    pub fn op(x: f64, y: f64) {
        match op_(x, y) {
            Err(why) =&gt; panic!(&quot;{}&quot;,match why {
                MathError::NegativeLogarithm
                    =&gt; &quot;logarithm of negative number&quot;,
                MathError::DivisionByZero
                    =&gt; &quot;division by zero&quot;,
                MathError::NegativeSquareRoot
                    =&gt; &quot;square root of negative number&quot;,
            }),
            Ok(value) =&gt; println!(&quot;{}&quot;, value),
        }
    }
}

fn main() {
    checked::op(1.0, 10.0);
}
</code></pre></pre>
<p>記得查閱<a href="https://rustwiki.org/zh-CN/std/result/index.html">文檔</a>，裡面有很多匹配/組合 <code>Result</code> 的方法。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic-1"><a class="header" href="#panic-1"><code>panic!</code></a></h1>
<p><code>panic!</code> 宏可用於產生一個 panic （恐慌），並開始回退（unwind）它的棧。在回退棧
的同時，運行時將會釋放該線程所<strong>擁有</strong>的所有資源，這是通過調用線程中所有對象的
析構函數完成的。</p>
<p>因為我們正在處理的程序只有一個線程，<code>panic!</code> 將會引發程序報告 panic 消息並退出。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">// 整型除法（/）的重新實現
fn division(dividend: i32, divisor: i32) -&gt; i32 {
    if divisor == 0 {
        // 除以 0 會引發 panic
        panic!(&quot;division by zero&quot;);
    } else {
        dividend / divisor
    }
}

// `main` 任務
fn main() {
    // 堆分配的整數
    let _x = Box::new(0i32);

    // 此操作將會引發一個任務失敗
    division(3, 0);

    println!(&quot;This point won't be reached!&quot;);

    // `_x` 應當會在此處被銷燬
}
</code></pre></pre>
<p>可以看到，<code>panic!</code> 不會洩露內存：</p>
<pre><code class="language-bash">$ rustc panic.rs &amp;&amp; valgrind ./panic
==4401== Memcheck, a memory error detector
==4401== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==4401== Using Valgrind-3.10.0.SVN and LibVEX; rerun with -h for copyright info
==4401== Command: ./panic
==4401== 
thread '&lt;main&gt;' panicked at 'division by zero', panic.rs:5
==4401== 
==4401== HEAP SUMMARY:
==4401==     in use at exit: 0 bytes in 0 blocks
==4401==   total heap usage: 18 allocs, 18 frees, 1,648 bytes allocated
==4401== 
==4401== All heap blocks were freed -- no leaks are possible
==4401== 
==4401== For counts of detected and suppressed errors, rerun with: -v
==4401== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="散列表-hashmap"><a class="header" href="#散列表-hashmap">散列表 HashMap</a></h1>
<p>vector 通過整型下標來存儲值，而 <code>HashMap</code>（散列表）通過鍵（key）來存儲
值。<code>HashMap</code> 的鍵可以是布爾型、整型、字符串，或任意實現了 <code>Eq</code> 和 <code>Hash</code> trait
的其他類型。在下一節將進一步介紹。</p>
<p>和 vector 類似，<code>HashMap</code> 也是可增長的，但 HashMap 在佔據了多餘空間時還可以縮小
自己。可以使用 <code>HashMap::with_capacity(unit)</code> 創建具有一定初始容量的 HashMap，也
可以使用 <code>HashMap::new()</code> 來獲得一個帶有默認初始容量的 HashMap（這是推薦方式）。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::collections::HashMap;

fn call(number: &amp;str) -&gt; &amp;str {
    match number {
        &quot;798-1364&quot; =&gt; &quot;We're sorry, the call cannot be completed as dialed. 
            Please hang up and try again.&quot;,
        &quot;645-7689&quot; =&gt; &quot;Hello, this is Mr. Awesome's Pizza. My name is Fred.
            What can I get for you today?&quot;,
        _ =&gt; &quot;Hi! Who is this again?&quot;
    }
}

fn main() { 
    let mut contacts = HashMap::new();

    contacts.insert(&quot;Daniel&quot;, &quot;798-1364&quot;);
    contacts.insert(&quot;Ashley&quot;, &quot;645-7689&quot;);
    contacts.insert(&quot;Katie&quot;, &quot;435-8291&quot;);
    contacts.insert(&quot;Robert&quot;, &quot;956-1745&quot;);

    // 接受一個引用並返回 Option&lt;&amp;V&gt;
    match contacts.get(&amp;&quot;Daniel&quot;) {
        Some(&amp;number) =&gt; println!(&quot;Calling Daniel: {}&quot;, call(number)),
        _ =&gt; println!(&quot;Don't have Daniel's number.&quot;),
    }

    // 如果被插入的值為新內容，那麼 `HashMap::insert()` 返回 `None`，
    // 否則返回 `Some(value)`
    contacts.insert(&quot;Daniel&quot;, &quot;164-6743&quot;);

    match contacts.get(&amp;&quot;Ashley&quot;) {
        Some(&amp;number) =&gt; println!(&quot;Calling Ashley: {}&quot;, call(number)),
        _ =&gt; println!(&quot;Don't have Ashley's number.&quot;),
    }

    contacts.remove(&amp;(&quot;Ashley&quot;)); 

    // `HashMap::iter()` 返回一個迭代器，該迭代器以任意順序舉出
    // (&amp;'a key, &amp;'a value) 對。
    for (contact, &amp;number) in contacts.iter() {
        println!(&quot;Calling {}: {}&quot;, contact, call(number)); 
    }
}
</code></pre></pre>
<p>想要了解更多關於散列（hash）與散列表（hash map）（有時也稱作 hash table）的
工作原理，可以查看 Wikipedia 的<a href="https://en.wikipedia.org/wiki/Hash_table">散列表</a>詞條。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="更改或自定義關鍵字類型"><a class="header" href="#更改或自定義關鍵字類型">更改或自定義關鍵字類型</a></h1>
<p>任何實現了 <code>Eq</code> 和 <code>Hash</code> trait 的類型都可以充當 <code>HashMap</code> 的鍵。這包括：</p>
<ul>
<li><code>bool</code> （當然這個用處不大，因為只有兩個可能的鍵）</li>
<li><code>int</code>，<code>unit</code>，以及其他整數類型</li>
<li><code>String</code> 和 <code>&amp;str</code>（友情提示：如果使用 <code>String</code> 作為鍵來創建 <code>HashMap</code>，則可以
將 <code>&amp;str</code> 作為散列表的 <code>.get()</code> 方法的參數，以獲取值）</li>
</ul>
<p>注意到 <code>f32</code> 和 <code>f64</code> <strong>沒有</strong>實現 <code>Hash</code>，這很大程度上是由於若使用浮點數作為
散列表的鍵，<a href="https://en.wikipedia.org/wiki/Floating_point#Accuracy_problems">浮點精度誤差</a>會很容易導致錯誤。</p>
<p>對於所有的集合類（collection class），如果它們包含的類型都分別實現了 <code>Eq</code>
和 <code>Hash</code>，那麼這些集合類也就實現了 <code>Eq</code> 和 <code>Hash</code>。例如，若 <code>T</code> 實現了
<code>Hash</code>，則 <code>Vec&lt;T&gt;</code> 也實現了 <code>Hash</code>。</p>
<p>對自定義類型可以輕鬆地實現 <code>Eq</code> 和 <code>Hash</code>，只需加上一行代碼：<code>#[derive(PartialEq, Eq, Hash)]</code>。</p>
<p>編譯器將會完成餘下的工作。如果你想控制更多的細節，你可以手動
實現 <code>Eq</code> 和/或 <code>Hash</code>。本指南不包含實現 <code>Hash</code> 的細節內容。</p>
<p>為了試驗 <code>HashMap</code> 中的 <code>struct</code>，讓我們試著做一個非常簡易的用戶登錄系統：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::collections::HashMap;

// Eq 要求你對此類型推導 PartiaEq。
#[derive(PartialEq, Eq, Hash)]
struct Account&lt;'a&gt;{
    username: &amp;'a str,
    password: &amp;'a str,
}

struct AccountInfo&lt;'a&gt;{
    name: &amp;'a str,
    email: &amp;'a str,
}

type Accounts&lt;'a&gt; = HashMap&lt;Account&lt;'a&gt;, AccountInfo&lt;'a&gt;&gt;;

fn try_logon&lt;'a&gt;(accounts: &amp;Accounts&lt;'a&gt;,
        username: &amp;'a str, password: &amp;'a str){
    println!(&quot;Username: {}&quot;, username);
    println!(&quot;Password: {}&quot;, password);
    println!(&quot;Attempting logon...&quot;);

    let logon = Account {
        username: username,
        password: password,
    };

    match accounts.get(&amp;logon) {
        Some(account_info) =&gt; {
            println!(&quot;Successful logon!&quot;);
            println!(&quot;Name: {}&quot;, account_info.name);
            println!(&quot;Email: {}&quot;, account_info.email);
        },
        _ =&gt; println!(&quot;Login failed!&quot;),
    }
}

fn main(){
    let mut accounts: Accounts = HashMap::new();

    let account = Account {
        username: &quot;j.everyman&quot;,
        password: &quot;password123&quot;,
    };

    let account_info = AccountInfo {
        name: &quot;John Everyman&quot;,
        email: &quot;j.everyman@email.com&quot;,
    };

    accounts.insert(account, account_info);

    try_logon(&amp;accounts, &quot;j.everyman&quot;, &quot;psasword123&quot;);

    try_logon(&amp;accounts, &quot;j.everyman&quot;, &quot;password123&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="散列集-hashset"><a class="header" href="#散列集-hashset">散列集 HashSet</a></h1>
<p>請把 <code>HashSet</code> 當成這樣一個 <code>HashMap</code>：我們只關心其中的鍵而非值（<code>HashSet&lt;T&gt;</code>
實際上只是對 <code>HashMap&lt;T, ()&gt;</code> 的封裝）。</p>
<p>你可能會問：“這有什麼意義呢？我完全可以將鍵存儲到一個 <code>Vec</code> 中呀。”</p>
<p><code>HashSet</code> 的獨特之處在於，它保證了不會出現重複的元素。這是任何 set 集合類型（set
collection）遵循的規定。<code>HashSet</code> 只是它的一個實現。（參見：<a href="https://rustwiki.org/zh-CN/std/collections/struct.BTreeSet.html"><code>BTreeSet</code></a>）</p>
<p>如果插入的值已經存在於 <code>HashSet</code> 中（也就是，新值等於已存在的值，並且擁有相同
的散列值），那麼新值將會替換舊的值。</p>
<p>如果你不想要一樣東西出現多於一次，或者你要判斷一樣東西是不是已經存在，這種做法
就很有用了。</p>
<p>不過集合（set）可以做更多的事。</p>
<p>集合（set）擁有 4 種基本操作（下面的調用全部都返回一個迭代器）：</p>
<ul>
<li>
<p><code>union</code>（並集）：獲得兩個集合中的所有元素（不含重複值）。</p>
</li>
<li>
<p><code>difference</code>（差集）：獲取屬於第一個集合而不屬於第二集合的所有元素。</p>
</li>
<li>
<p><code>intersection</code>（交集）：獲取同時屬於兩個集合的所有元素。</p>
</li>
<li>
<p><code>symmetric_difference</code>（對稱差）：獲取所有隻屬於其中一個集合，而不同時屬於
兩個集合的所有元素。</p>
</li>
</ul>
<p>在下面的例子中嘗試使用這些操作。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">use std::collections::HashSet;

fn main() {
    let mut a: HashSet&lt;i32&gt; = vec!(1i32, 2, 3).into_iter().collect();
    let mut b: HashSet&lt;i32&gt; = vec!(2i32, 3, 4).into_iter().collect();

    assert!(a.insert(4));
    assert!(a.contains(&amp;4));

    // 如果值已經存在，那麼 `HashSet::insert()` 返回 false。
    assert!(b.insert(4), &quot;Value 4 is already in set B!&quot;);
    // 改正 ^ 將此行註釋掉。

    b.insert(5);

    // 若一個集合（collection）的元素類型實現了 `Debug`，那麼該集合也就實現了 `Debug`。
    // 這通常將元素打印成這樣的格式 `[elem1, elem2, ...]
    println!(&quot;A: {:?}&quot;, a);
    println!(&quot;B: {:?}&quot;, b);

    // 亂序打印 [1, 2, 3, 4, 5]。
    println!(&quot;Union: {:?}&quot;, a.union(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // 這將會打印出 [1]
    println!(&quot;Difference: {:?}&quot;, a.difference(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // 亂序打印 [2, 3, 4]。
    println!(&quot;Intersection: {:?}&quot;, a.intersection(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // 打印 [1, 5]
    println!(&quot;Symmetric Difference: {:?}&quot;,
             a.symmetric_difference(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());
}
</code></pre></pre>
<p>（例子改編自<a href="https://rustwiki.org/zh-CN/std/collections/struct.HashSet.html#method.difference">文檔</a>。）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="引用計數-rc"><a class="header" href="#引用計數-rc">引用計數 <code>Rc</code></a></h1>
<p>當需要多個所有權時，可以使用 <code>Rc</code>（引用計數，Reference Counting 縮寫）。<code>Rc</code> 跟蹤引用的數量，這相當於包裹在 <code>Rc</code> 值的所有者的數量.</p>
<p>每當克隆一個 <code>Rc</code> 時，<code>Rc</code> 的引用計數就會增加 1，而每當克隆得到的 <code>Rc</code> 退出作用域時，引用計數就會減少 1。當 <code>Rc</code> 的引用計數變為 0 時，這意味著已經沒有所有者，<code>Rc</code> 和值兩者都將被刪除。</p>
<p>克隆 <code>Rc</code> 從不執行深拷貝。克隆只創建另一個指向包裹值的指針，並增加計數。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::rc::Rc;

fn main() {
    let rc_examples = &quot;Rc examples&quot;.to_string();
    {
        println!(&quot;--- rc_a is created ---&quot;);
        
        let rc_a: Rc&lt;String&gt; = Rc::new(rc_examples);
        println!(&quot;Reference Count of rc_a: {}&quot;, Rc::strong_count(&amp;rc_a));
        
        {
            println!(&quot;--- rc_a is cloned to rc_b ---&quot;);
            
            let rc_b: Rc&lt;String&gt; = Rc::clone(&amp;rc_a);
            println!(&quot;Reference Count of rc_b: {}&quot;, Rc::strong_count(&amp;rc_b));
            println!(&quot;Reference Count of rc_a: {}&quot;, Rc::strong_count(&amp;rc_a));
            
            // 如果兩者內部的值相等的話，則兩個 `Rc` 相等。
            println!(&quot;rc_a and rc_b are equal: {}&quot;, rc_a.eq(&amp;rc_b));
                        
            // 我們可以直接使用值的方法
            println!(&quot;Length of the value inside rc_a: {}&quot;, rc_a.len());
            println!(&quot;Value of rc_b: {}&quot;, rc_b);
            
            println!(&quot;--- rc_b is dropped out of scope ---&quot;);
        }
        
        println!(&quot;Reference Count of rc_a: {}&quot;, Rc::strong_count(&amp;rc_a));
        
        println!(&quot;--- rc_a is dropped out of scope ---&quot;);
    }
    
    // 報錯！`rc_examples` 已經移入 `rc_a`。
    // 而且當 `rc_a` 被刪時，`rc_examples` 也被一起刪除。
    // println!(&quot;rc_examples: {}&quot;, rc_examples);
    // 試一試 ^ 註釋掉此行代碼
}
</code></pre></pre>
<h3 id="參見-64"><a class="header" href="#參見-64">參見：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/rc/index.html">std::rc</a> 和 <a href="https://rustwiki.org/zh-CN/std/sync/struct.Arc.html">std::sync::arc</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="共享引用計數-arc"><a class="header" href="#共享引用計數-arc">共享引用計數 Arc</a></h1>
<p>當線程之間所有權需要共享時，可以使用<code>Arc</code>（共享引用計數，Atomic Reference Counted 縮寫）可以使用。這個結構通過 <code>Clone</code> 實現可以為內存堆中的值的位置創建一個引用指針，同時增加引用計數器。由於它在線程之間共享所有權，因此當指向某個值的最後一個引用指針退出作用域時，該變量將被刪除。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::sync::Arc;
use std::thread;

fn main() {
    // 這個變量聲明用來指定其值的地方。
    let apple = Arc::new(&quot;the same apple&quot;);

    for _ in 0..10 {
        // 這裡沒有數值說明，因為它是一個指向內存堆中引用的指針。
        let apple = Arc::clone(&amp;apple);

        thread::spawn(move || {
            // 由於使用了Arc，線程可以使用分配在 `Arc` 變量指針位置的值來生成。
            println!(&quot;{:?}&quot;, apple);
        });
    }
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="標準庫更多介紹"><a class="header" href="#標準庫更多介紹">標準庫更多介紹</a></h1>
<p>標準庫也提供了很多其他類型來支持某些功能，例如：</p>
<ul>
<li>線程（Threads）</li>
<li>信道（Channels）</li>
<li>文件輸入輸出（File I/O）</li>
</ul>
<p>這些內容在<a href="primitives.html">原生類型</a>之外進行了有效擴充。</p>
<h3 id="參見-65"><a class="header" href="#參見-65">參見：</a></h3>
<p><a href="primitives.html">原生類型</a> 和 <a href="https://rustwiki.org/zh-CN/std/">標準庫類型</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="線程"><a class="header" href="#線程">線程</a></h1>
<p>Rust 通過 <code>spawn</code> 函數提供了創建本地操作系統（native OS）線程的機制，該函數的參數是一個通過值捕獲變量的閉包（moving closure）。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::thread;

static NTHREADS: i32 = 10;

// 這是主（`main`）線程
fn main() {
    // 提供一個 vector 來存放所創建的子線程（children）。
    let mut children = vec![];

    for i in 0..NTHREADS {
        // 啟動（spin up）另一個線程
        children.push(thread::spawn(move || {
            println!(&quot;this is thread number {}&quot;, i)
        }));
    }

    for child in children {
        // 等待線程結束。返回一個結果。
        let _ = child.join();
    }
}
</code></pre></pre>
<p>這些線程由操作系統調度（schedule）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="測試實例map-reduce"><a class="header" href="#測試實例map-reduce">測試實例：map-reduce</a></h1>
<p>Rust 使數據的並行化處理非常簡單，在 Rust 中你無需面對並行處理的很多傳統難題。</p>
<p>標準庫提供了開箱即用的線程類型，把它和 Rust 的所有權概念與別名規則結合
起來，可以自動地避免數據競爭（data race）。</p>
<p>當某狀態對某線程是可見的，別名規則（即一個可變引用 XOR 一些只讀引用。譯註：XOR
是異或的意思，即「二者僅居其一」）就自動地避免了別的線程對它的操作。（當需要同步
處理時，請使用 <code>Mutex</code> 或 <code>Channel</code> 這樣的同步類型。）</p>
<p>在本例中，我們將會計算一堆數字中每一位的和。我們將把它們分成幾塊，放入不同的
線程。每個線程會把自己那一塊數字的每一位加起來，之後我們再把每個線程提供的結果
再加起來。</p>
<p>注意到，雖然我們在線程之間傳遞了引用，但 Rust 理解我們是在傳遞只讀的引用，因此
不會發生數據競爭等不安全的事情。另外，因為我們把數據塊 <code>move</code> 到了線程中，Rust
會保證數據存活至線程退出，因此不會產生懸掛指針。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::thread;

// 這是 `main` 線程
fn main() {

    // 這是我們要處理的數據。
    // 我們會通過線程實現 map-reduce 算法，從而計算每一位的和
    // 每個用空白符隔開的塊都會分配給單獨的線程來處理
    //
    // 試一試：插入空格，看看輸出會怎樣變化！
    let data = &quot;86967897737416471853297327050364959
11861322575564723963297542624962850
70856234701860851907960690014725639
38397966707106094172783238747669219
52380795257888236525459303330302837
58495327135744041048897885734297812
69920216438980873548808413720956532
16278424637452589860345374828574668&quot;;

    // 創建一個向量，用於儲存將要創建的子線程
    let mut children = vec![];

    /*************************************************************************
     * &quot;Map&quot; 階段
     *
     * 把數據分段，並進行初始化處理
     ************************************************************************/

    // 把數據分段，每段將會單獨計算
    // 每段都是完整數據的一個引用（&amp;str）
    let chunked_data = data.split_whitespace();

    // 對分段的數據進行迭代。
    // .enumerate() 會把當前的迭代計數與被迭代的元素以元組 (index, element)
    // 的形式返回。接著立即使用 “解構賦值” 將該元組解構成兩個變量，
    // `i` 和 `data_segment`。
    for (i, data_segment) in chunked_data.enumerate() {
        println!(&quot;data segment {} is \&quot;{}\&quot;&quot;, i, data_segment);

        // 用單獨的線程處理每一段數據
        //
        // spawn() 返回新線程的句柄（handle），我們必須擁有句柄，
        // 才能獲取線程的返回值。
        //
        // 'move || -&gt; u32' 語法表示該閉包：
        // * 沒有參數（'||'）
        // * 會獲取所捕獲變量的所有權（'move'）
        // * 返回無符號 32 位整數（'-&gt; u32'）
        //
        // Rust 可以根據閉包的內容推斷出 '-&gt; u32'，所以我們可以不寫它。
        //
        // 試一試：刪除 'move'，看看會發生什麼
        children.push(thread::spawn(move || -&gt; u32 {
            // 計算該段的每一位的和：
            let result = data_segment
                        // 對該段中的字符進行迭代..
                        .chars()
                        // ..把字符轉成數字..
                        .map(|c| c.to_digit(10).expect(&quot;should be a digit&quot;))
                        // ..對返回的數字類型的迭代器求和
                        .sum();

            // println! 會鎖住標準輸出，這樣各線程打印的內容不會交錯在一起
            println!(&quot;processed segment {}, result={}&quot;, i, result);

            // 不需要 “return”，因為 Rust 是一種 “表達式語言”，每個代碼塊中
            // 最後求值的表達式就是代碼塊的值。
            result

        }));
    }


    /*************************************************************************
     * &quot;Reduce&quot; 階段
     *
     * 收集中間結果，得出最終結果
     ************************************************************************/

    // 把每個線程產生的中間結果收入一個新的向量中
    let mut intermediate_sums = vec![];
    for child in children {
        // 收集每個子線程的返回值
        let intermediate_sum = child.join().unwrap();
        intermediate_sums.push(intermediate_sum);
    }

    // 把所有中間結果加起來，得到最終結果
    //
    // 我們用 “渦輪魚” 寫法 ::&lt;&gt; 來為 sum() 提供類型提示。
    //
    // 試一試：不使用渦輪魚寫法，而是顯式地指定 intermediate_sums 的類型
    let final_result = intermediate_sums.iter().sum::&lt;u32&gt;();

    println!(&quot;Final sum result: {}&quot;, final_result);
}


</code></pre></pre>
<h3 id="作業"><a class="header" href="#作業">作業</a></h3>
<p>根據用戶輸入的數據來決定線程的數量是不明智的。如果用戶輸入的數據中有一大堆空格
怎麼辦？我們<strong>真的</strong>想要創建 2000 個線程嗎？</p>
<p>請修改程序，使得數據總是被分成有限數目的段，這個數目是由程序開頭的靜態常量決定的。</p>
<h3 id="參見-66"><a class="header" href="#參見-66">參見:</a></h3>
<ul>
<li><a href="std_misc/threads/../threads.html">線程</a></li>
<li><a href="std_misc/threads/../../std/vec.html">向量</a>和<a href="std_misc/threads/../../trait/iter.html">迭代器</a></li>
<li><a href="std_misc/threads/../../fn/closures.html">閉包</a>、<a href="std_misc/threads/../../scope/move.html">移動</a>語義和<a href="https://rustwiki.org/zh-CN/book/ch13-01-closures.html#closures-can-capture-their-environment"><code>move</code>閉包</a></li>
<li><a href="https://rustwiki.org/zh-CN/book/ch18-03-pattern-syntax.html#%E8%A7%A3%E6%A7%8B%E4%B8%A6%E5%88%86%E8%A7%A3%E5%80%BC">解構</a>賦值</li>
<li>使用<a href="https://rustwiki.org/zh-CN/std/iter/trait.Iterator.html#method.collect">渦輪魚寫法</a>幫助類型推斷</li>
<li><a href="std_misc/threads/../../error/option_unwrap.html">unwrap vs. expect</a></li>
<li><a href="https://rustwiki.org/zh-CN/book/ch03-05-control-flow.html#%E4%BD%BF%E7%94%A8-loop-%E9%87%8D%E8%A4%87%E5%9F%B7%E8%A1%8C%E4%BB%A3%E7%A2%BC">枚舉類型</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="通道"><a class="header" href="#通道">通道</a></h1>
<p>Rust 為線程之間的通信提供了異步的通道（<code>channel</code>）。通道允許兩個端點之間信息的
單向流動：<code>Sender</code>（發送端） 和 <code>Receiver</code>（接收端）。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::sync::mpsc::{Sender, Receiver};
use std::sync::mpsc;
use std::thread;

static NTHREADS: i32 = 3;

fn main() {
    // 通道有兩個端點：`Sender&lt;T&gt;` 和 `Receiver&lt;T&gt;`，其中 `T` 是要發送
    // 的消息的類型（類型標註是可選的）
    let (tx, rx): (Sender&lt;i32&gt;, Receiver&lt;i32&gt;) = mpsc::channel();

    for id in 0..NTHREADS {
        // sender 端可被複制
        let thread_tx = tx.clone();

        // 每個線程都將通過通道來發送它的 id
        thread::spawn(move || {
            // 被創建的線程取得 `thread_tx` 的所有權
            // 每個線程都把消息放在通道的消息隊列中
            thread_tx.send(id).unwrap();

            // 發送是一個非阻塞（non-blocking）操作，線程將在發送完消息後
            // 會立即繼續進行
            println!(&quot;thread {} finished&quot;, id);
        });
    }

    // 所有消息都在此處被收集
    let mut ids = Vec::with_capacity(NTHREADS as usize);
    for _ in 0..NTHREADS {
        // `recv` 方法從通道中拿到一個消息
        // 若無可用消息的話，`recv` 將阻止當前線程
        ids.push(rx.recv());
    }

    // 顯示消息被髮送的次序
    println!(&quot;{:?}&quot;, ids);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="路徑"><a class="header" href="#路徑">路徑</a></h1>
<p><code>Path</code> 結構體代表了底層文件系統的文件路徑。<code>Path</code> 分為兩種：<code>posix::Path</code>，針對
類 UNIX 系統；以及 <code>windows::Path</code>，針對 Windows。prelude 會選擇並輸出符合平臺類型
的 <code>Path</code> 種類。</p>
<blockquote>
<p>譯註：prelude 是 Rust 自動地在每個程序中導入的一些通用的東西，這樣我們就不必每寫
一個程序就手動導入一番。</p>
</blockquote>
<p><code>Path</code> 可從 <code>OsStr</code> 類型創建，並且它提供數種方法，用於獲取路徑指向的文件/目錄
的信息。</p>
<p>注意 <code>Path</code> 在內部並不是用 UTF-8 字符串表示的，而是存儲為若干字節（<code>Vec&lt;u8&gt;</code>）的
vector。因此，將 <code>Path</code> 轉化成 <code>&amp;str</code> 並非零開銷的（free），且可能失敗（因此它
返回一個 <code>Option</code>）。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::path::Path;

fn main() {
    // 從 `&amp;'static str` 創建一個 `Path`
    let path = Path::new(&quot;.&quot;);

    // `display` 方法返回一個可顯示（showable）的結構體
    let display = path.display();

    // `join` 使用操作系統特定的分隔符來合併路徑到一個字節容器，並返回新的路徑
    let new_path = path.join(&quot;a&quot;).join(&quot;b&quot;);

    // 將路徑轉換成一個字符串切片
    match new_path.to_str() {
        None =&gt; panic!(&quot;new path is not a valid UTF-8 sequence&quot;),
        Some(s) =&gt; println!(&quot;new path is {}&quot;, s),
    }
}
</code></pre></pre>
<p>記得看看其他的 <code>Path</code> 方法（<code>posix::Path</code> 或 <code>windows::Path</code> 的），還有
<code>Metadata</code> 結構體類型。</p>
<h3 id="參見-67"><a class="header" href="#參見-67">參見</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/ffi/struct.OsStr.html">OsStr</a> 和 <a href="https://rustwiki.org/zh-CN/std/fs/struct.Metadata.html">Metadata</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文件輸入輸出io"><a class="header" href="#文件輸入輸出io">文件輸入輸出（I/O）</a></h1>
<p><code>File</code> 結構體表示一個被打開的文件（它包裹了一個文件描述符），並賦予了對所表示的
文件的讀寫能力。</p>
<p>由於在進行文件 I/O（輸入/輸出）操作時可能出現各種錯誤，因此 <code>File</code> 的所有方法都
返回 <code>io::Result&lt;T&gt;</code> 類型，它是 <code>Result&lt;T, io::Error&gt;</code> 的別名。</p>
<p>這使得所有 I/O 操作的失敗都變成<strong>顯式的</strong>。藉助這點，程序員可以看到所有的失敗
路徑，並被鼓勵主動地處理這些情形。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="打開文件-open"><a class="header" href="#打開文件-open">打開文件 <code>open</code></a></h1>
<p><code>open</code> 靜態方法能夠以只讀模式（read-only mode）打開一個文件。</p>
<p><code>File</code> 擁有資源，即文件描述符（file descriptor），它會在自身被 <code>drop</code> 時關閉文件。</p>
<pre><code class="language-rust editable ignore">use std::error::Error;
use std::fs::File;
use std::io::prelude::*;
use std::path::Path;

fn main() {
    // 創建指向所需的文件的路徑
    let path = Path::new(&quot;hello.txt&quot;);
    let display = path.display();

    // 以只讀方式打開路徑，返回 `io::Result&lt;File&gt;`
    let mut file = match File::open(&amp;path) {
        // `io::Error` 的 `description` 方法返回一個描述錯誤的字符串。
        Err(why) =&gt; panic!(&quot;couldn't open {}: {}&quot;, display,
                                                   why.description()),
        Ok(file) =&gt; file,
    };

    // 讀取文件內容到一個字符串，返回 `io::Result&lt;usize&gt;`
    let mut s = String::new();
    match file.read_to_string(&amp;mut s) {
        Err(why) =&gt; panic!(&quot;couldn't read {}: {}&quot;, display,
                                                   why.description()),
        Ok(_) =&gt; print!(&quot;{} contains:\n{}&quot;, display, s),
    }

    // `file` 離開作用域，並且 `hello.txt` 文件將被關閉。
}
</code></pre>
<p>下面是所希望的成功的輸出：</p>
<pre><code class="language-bash">$ echo &quot;Hello World!&quot; &gt; hello.txt
$ rustc open.rs &amp;&amp; ./open
hello.txt contains:
Hello World!
</code></pre>
<p>（我們鼓勵您在不同的失敗條件下測試前面的例子：hello.txt 不存在，或 hello.txt 不可讀，等等。）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="創建文件-create"><a class="header" href="#創建文件-create">創建文件 <code>create</code></a></h1>
<p><code>create</code> 靜態方法以只寫模式（write-only mode）打開一個文件。若文件已經存在，則
舊內容將被銷燬。否則，將創建一個新文件。</p>
<pre><code class="language-rust ignore">static LOREM_IPSUM: &amp;'static str =
&quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
&quot;;

use std::error::Error;
use std::io::prelude::*;
use std::fs::File;
use std::path::Path;

fn main() {
    let path = Path::new(&quot;out/lorem_ipsum.txt&quot;);
    let display = path.display();

    // 以只寫模式打開文件，返回 `io::Result&lt;File&gt;`
    let mut file = match File::create(&amp;path) {
        Err(why) =&gt; panic!(&quot;couldn't create {}: {}&quot;,
                           display,
                           why.description()),
        Ok(file) =&gt; file,
    };

    // 將 `LOREM_IPSUM` 字符串寫進 `file`，返回 `io::Result&lt;()&gt;`
    match file.write_all(LOREM_IPSUM.as_bytes()) {
        Err(why) =&gt; {
            panic!(&quot;couldn't write to {}: {}&quot;, display,
                                               why.description())
        },
        Ok(_) =&gt; println!(&quot;successfully wrote to {}&quot;, display),
    }
}
</code></pre>
<p>下面是預期成功的輸出：</p>
<pre><code class="language-bash">$ mkdir out
$ rustc create.rs &amp;&amp; ./create
successfully wrote to out/lorem_ipsum.txt
$ cat out/lorem_ipsum.txt
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
</code></pre>
<p>（和前面例子一樣，我們鼓勵你在失敗條件下測試這個例子。）</p>
<p>還有一個更通用的 <code>open_mode</code> 方法，這能夠以其他方式來來打開
文件，如：read+write（讀+寫），追加（append），等等。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="讀取行"><a class="header" href="#讀取行">讀取行</a></h1>
<p>方法 <code>lines()</code> 在文件的行上返回一個迭代器。</p>
<p><code>File::open</code> 需要一個泛型 <code>AsRef&lt;Path&gt;</code>。這正是 <code>read_lines()</code> 期望的輸入。</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021">use std::fs::File;
use std::io::{self, BufRead};
use std::path::Path;

fn main() {
    // 在生成輸出之前，文件主機必須存在於當前路徑中
    if let Ok(lines) = read_lines(&quot;./hosts&quot;) {
        // 使用迭代器，返回一個（可選）字符串
        for line in lines {
            if let Ok(ip) = line {
                println!(&quot;{}&quot;, ip);
            }      
        }   
    }
}

// 輸出包裹在 Result 中以允許匹配錯誤，
// 將迭代器返回給文件行的讀取器（Reader）。
fn read_lines&lt;P&gt;(filename: P) -&gt; io::Result&lt;io::Lines&lt;io::BufReader&lt;File&gt;&gt;&gt;
where P: AsRef&lt;Path&gt;, {
    let file = File::open(filename)?;
    Ok(io::BufReader::new(file).lines())
}
</code></pre></pre>
<p>運行此程序將一行行將內容打印出來。</p>
<pre><code class="language-bash">$ echo -e &quot;127.0.0.1\n192.168.0.1\n&quot; &gt; hosts
$ rustc read_lines.rs &amp;&amp; ./read_lines
127.0.0.1
192.168.0.1
</code></pre>
<p>這個過程比在內存中創建 <code>String</code> 更有效，特別是處理更大的文件。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="子進程"><a class="header" href="#子進程">子進程</a></h1>
<p><code>process::Output</code> 結構體表示已結束的子進程（child process）的輸出，而
<code>process::Command</code> 結構體是一個進程創建者（process builder）。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::process::Command;

fn main() {
    let output = Command::new(&quot;rustc&quot;)
        .arg(&quot;--version&quot;)
        .output().unwrap_or_else(|e| {
            panic!(&quot;failed to execute process: {}&quot;, e)
    });

    if output.status.success() {
        let s = String::from_utf8_lossy(&amp;output.stdout);

        print!(&quot;rustc succeeded and stdout was:\n{}&quot;, s);
    } else {
        let s = String::from_utf8_lossy(&amp;output.stderr);

        print!(&quot;rustc failed and stderr was:\n{}&quot;, s);
    }
}
</code></pre></pre>
<p>（再試試上面的例子，給 <code>rustc</code> 命令傳入一個錯誤的 flag）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="管道"><a class="header" href="#管道">管道</a></h1>
<p><code>std::Child</code> 結構體代表了一個正在運行的子進程，它暴露了 <code>stdin</code>（標準
輸入），<code>stdout</code>（標準輸出） 和 <code>stderr</code>（標準錯誤） 句柄，從而可以通過管道與
所代表的進程交互。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::error::Error;
use std::io::prelude::*;
use std::process::{Command, Stdio};

static PANGRAM: &amp;'static str =
&quot;the quick brown fox jumped over the lazy dog\n&quot;;

fn main() {
    // 啟動 `wc` 命令
    let process = match Command::new(&quot;wc&quot;)
                                .stdin(Stdio::piped())
                                .stdout(Stdio::piped())
                                .spawn() {
        Err(why) =&gt; panic!(&quot;couldn't spawn wc: {}&quot;, why.description()),
        Ok(process) =&gt; process,
    };

    // 將字符串寫入 `wc` 的 `stdin`。
    //
    // `stdin` 擁有 `Option&lt;ChildStdin&gt;` 類型，不過我們已經知道這個實例不為空值，
    // 因而可以直接 `unwrap 它。
    match process.stdin.unwrap().write_all(PANGRAM.as_bytes()) {
        Err(why) =&gt; panic!(&quot;couldn't write to wc stdin: {}&quot;,
                           why.description()),
        Ok(_) =&gt; println!(&quot;sent pangram to wc&quot;),
    }

    // 因為 `stdin` 在上面調用後就不再存活，所以它被 `drop` 了，管道也被關閉。
    //
    // 這點非常重要，因為否則 `wc` 就不會開始處理我們剛剛發送的輸入。

    // `stdout` 字段也擁有 `Option&lt;ChildStdout&gt;` 類型，所以必需解包。
    let mut s = String::new();
    match process.stdout.unwrap().read_to_string(&amp;mut s) {
        Err(why) =&gt; panic!(&quot;couldn't read wc stdout: {}&quot;,
                           why.description()),
        Ok(_) =&gt; print!(&quot;wc responded with:\n{}&quot;, s),
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="等待"><a class="header" href="#等待">等待</a></h1>
<p>如果你想等待一個 <code>process::Child</code> 完成，就必須調用 <code>Child::wait</code>，這會返回
一個 <code>process::ExitStatus</code>。</p>
<pre><code class="language-rust ignore">use std::process::Command;

fn main() {
    let mut child = Command::new(&quot;sleep&quot;).arg(&quot;5&quot;).spawn().unwrap();
    let _result = child.wait().unwrap();

    println!(&quot;reached end of main&quot;);
}
</code></pre>
<pre><code class="language-bash">$ rustc wait.rs &amp;&amp; ./wait
reached end of main
# `wait` keeps running for 5 seconds
# `sleep 5` command ends, and then our `wait` program finishes
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文件系統操作"><a class="header" href="#文件系統操作">文件系統操作</a></h1>
<p><code>std::io::fs</code> 模塊包含幾個處理文件系統的函數。</p>
<pre><code class="language-rust ignore">use std::fs;
use std::fs::{File, OpenOptions};
use std::io;
use std::io::prelude::*;
use std::os::unix;
use std::path::Path;

// `% cat path` 的簡單實現
fn cat(path: &amp;Path) -&gt; io::Result&lt;String&gt; {
    let mut f = File::open(path)?;
    let mut s = String::new();
    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}

// `% echo s &gt; path` 的簡單實現
fn echo(s: &amp;str, path: &amp;Path) -&gt; io::Result&lt;()&gt; {
    let mut f = File::create(path)?;

    f.write_all(s.as_bytes())
}

// `% touch path` 的簡單實現（忽略已存在的文件）
fn touch(path: &amp;Path) -&gt; io::Result&lt;()&gt; {
    match OpenOptions::new().create(true).write(true).open(path) {
        Ok(_) =&gt; Ok(()),
        Err(e) =&gt; Err(e),
    }
}

fn main() {
    println!(&quot;`mkdir a`&quot;);
    // 創建一個目錄，返回 `io::Result&lt;()&gt;`
    match fs::create_dir(&quot;a&quot;) {
        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),
        Ok(_) =&gt; {},
    }

    println!(&quot;`echo hello &gt; a/b.txt`&quot;);
    // 前面的匹配可以用 `unwrap_or_else` 方法簡化
    echo(&quot;hello&quot;, &amp;Path::new(&quot;a/b.txt&quot;)).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`mkdir -p a/c/d`&quot;);
    // 遞歸地創建一個目錄，返回 `io::Result&lt;()&gt;`
    fs::create_dir_all(&quot;a/c/d&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`touch a/c/e.txt`&quot;);
    touch(&amp;Path::new(&quot;a/c/e.txt&quot;)).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`ln -s ../b.txt a/c/b.txt`&quot;);
    // 創建一個符號鏈接，返回 `io::Resutl&lt;()&gt;`
    if cfg!(target_family = &quot;unix&quot;) {
        unix::fs::symlink(&quot;../b.txt&quot;, &quot;a/c/b.txt&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
        });
    }

    println!(&quot;`cat a/c/b.txt`&quot;);
    match cat(&amp;Path::new(&quot;a/c/b.txt&quot;)) {
        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),
        Ok(s) =&gt; println!(&quot;&gt; {}&quot;, s),
    }

    println!(&quot;`ls a`&quot;);
    // 讀取目錄的內容，返回 `io::Result&lt;Vec&lt;Path&gt;&gt;`
    match fs::read_dir(&quot;a&quot;) {
        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),
        Ok(paths) =&gt; for path in paths {
            println!(&quot;&gt; {:?}&quot;, path.unwrap().path());
        },
    }

    println!(&quot;`rm a/c/e.txt`&quot;);
    // 刪除一個文件，返回 `io::Result&lt;()&gt;`
    fs::remove_file(&quot;a/c/e.txt&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`rmdir a/c/d`&quot;);
    // 移除一個空目錄，返回 `io::Result&lt;()&gt;`
    fs::remove_dir(&quot;a/c/d&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });
}
</code></pre>
<p>下面是所期望的成功的輸出：</p>
<pre><code class="language-bash">$ rustc fs.rs &amp;&amp; ./fs
`mkdir a`
`echo hello &gt; a/b.txt`
`mkdir -p a/c/d`
`touch a/c/e.txt`
`ln -s ../b.txt a/c/b.txt`
`cat a/c/b.txt`
&gt; hello
`ls a`
&gt; &quot;a/b.txt&quot;
&gt; &quot;a/c&quot;
`rm a/c/e.txt`
`rmdir a/c/d`
</code></pre>
<p>且 <code>a</code> 目錄的最終狀態為：</p>
<pre><code class="language-text">$ tree a
a
|-- b.txt
`-- c
    `-- b.txt -&gt; ../b.txt

1 directory, 2 files
</code></pre>
<p>另一種定義 <code>cat</code> 函數的方式是使用 <code>?</code> 標記：</p>
<pre><code class="language-rust ignore">fn cat(path: &amp;Path) -&gt; io::Result&lt;String&gt; {
    let mut f = File::open(path)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
</code></pre>
<h3 id="參見-68"><a class="header" href="#參見-68">參見：</a></h3>
<p><a href="std_misc/../attribute/cfg.html"><code>cfg!</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="程序參數"><a class="header" href="#程序參數">程序參數</a></h1>
<h2 id="標準庫"><a class="header" href="#標準庫">標準庫</a></h2>
<p>命令行參數可使用 <code>std::env::args</code> 進行接收，這將返回一個迭代器，該迭代器會對
每個參數舉出一個字符串。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    // 第一個參數是調用本程序的路徑
    println!(&quot;My path is {}.&quot;, args[0]);

    // 其餘的參數是被傳遞給程序的命令行參數。
    // 請這樣調用程序：
    //   $ ./args arg1 arg2
    println!(&quot;I got {:?} arguments: {:?}.&quot;, args.len() - 1, &amp;args[1..]);
}
</code></pre></pre>
<pre><code class="language-bash">$ ./args 1 2 3
My path is ./args.
I got 3 arguments: [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].
</code></pre>
<h2 id="crate-2"><a class="header" href="#crate-2">crate</a></h2>
<p>另外，也有很多 crate 提供了編寫命令行應用的額外功能。<a href="https://rust-lang-nursery.github.io/rust-cookbook/app.html#ex-clap-basic">Rust Cookbook</a> 展示了使用
最流行的命令行參數 crate，即 <code>clap</code> 的最佳實踐。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="參數解析"><a class="header" href="#參數解析">參數解析</a></h1>
<p>可以用模式匹配來解析簡單的參數：</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::env;

fn increase(number: i32) {
    println!(&quot;{}&quot;, number + 1);
}

fn decrease(number: i32) {
    println!(&quot;{}&quot;, number - 1);
}

fn help() {
    println!(&quot;usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {{increase|decrease}} &lt;integer&gt;
    Increase or decrease given integer by one.&quot;);
}

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    match args.len() {
        // 沒有傳入參數
        1 =&gt; {
            println!(&quot;My name is 'match_args'. Try passing some arguments!&quot;);
        },
        // 一個傳入參數
        2 =&gt; {
            match args[1].parse() {
                Ok(42) =&gt; println!(&quot;This is the answer!&quot;),
                _ =&gt; println!(&quot;This is not the answer.&quot;),
            }
        },
        // 傳入一條命令和一個參數
        3 =&gt; {
            let cmd = &amp;args[1];
            let num = &amp;args[2];
            // 解析數字
            let number: i32 = match num.parse() {
                Ok(n) =&gt; {
                    n
                },
                Err(_) =&gt; {
                    println!(&quot;error: second argument not an integer&quot;);
                    help();
                    return;
                },
            };
            // 解析命令
            match &amp;cmd[..] {
                &quot;increase&quot; =&gt; increase(number),
                &quot;decrease&quot; =&gt; decrease(number),
                _ =&gt; {
                    println!(&quot;error: invalid command&quot;);
                    help();
                },
            }
        },
        // 所有其他情況
        _ =&gt; {
            // 顯示幫助信息
            help();
        }
    }
}
</code></pre></pre>
<pre><code class="language-bash">$ ./match_args Rust
This is not the answer.
$ ./match_args 42
This is the answer!
$ ./match_args do something
error: second argument not an integer
usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {increase|decrease} &lt;integer&gt;
    Increase or decrease given integer by one.
$ ./match_args do 42
error: invalid command
usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {increase|decrease} &lt;integer&gt;
    Increase or decrease given integer by one.
$ ./match_args increase 42
43
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="外部語言函數接口"><a class="header" href="#外部語言函數接口">外部語言函數接口</a></h1>
<p>Rust 提供了到 C 語言庫的外部語言函數接口（Foreign Function Interface，FFI）。外
部語言函數必須在一個 <code>extern</code> 代碼塊中聲明，且該代碼塊要帶有一個包含庫名稱
的 <code>#[link]</code> 屬性。</p>
<pre><code class="language-rust ignore">use std::fmt;

// 這個 extern 代碼塊鏈接到 libm 庫
#[link(name = &quot;m&quot;)]
extern {
    // 這個外部函數用於計算單精度複數的平方根
    fn csqrtf(z: Complex) -&gt; Complex;

    // 這個用來計算單精度複數的復變餘弦
    fn ccosf(z: Complex) -&gt; Complex;
}

// 由於調用其他語言的函數被認為是不安全的，我們通常會給它們寫一層安全的封裝
fn cos(z: Complex) -&gt; Complex {
    unsafe { ccosf(z) }
}

fn main() {
    // z = -1 + 0i
    let z = Complex { re: -1., im: 0. };

    // 調用外部語言函數是不安全操作
    let z_sqrt = unsafe { csqrtf(z) };

    println!(&quot;the square root of {:?} is {:?}&quot;, z, z_sqrt);

    // 調用不安全操作的安全的 API 封裝
    println!(&quot;cos({:?}) = {:?}&quot;, z, cos(z));
}

// 單精度複數的最簡實現
#[repr(C)]
#[derive(Clone, Copy)]
struct Complex {
    re: f32,
    im: f32,
}

impl fmt::Debug for Complex {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        if self.im &lt; 0. {
            write!(f, &quot;{}-{}i&quot;, self.re, -self.im)
        } else {
            write!(f, &quot;{}+{}i&quot;, self.re, self.im)
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="測試-1"><a class="header" href="#測試-1">測試</a></h1>
<p>Rust 是一門非常重視正確性的語言，這門語言本身就提供了對編寫軟件測試的支持。</p>
<p>測試有三種風格：</p>
<ul>
<li><a href="testing/unit_testing.html">單元</a>測試。</li>
<li><a href="testing/doc_testing.html">文檔</a>測試。</li>
<li><a href="testing/integration_testing.html">集成</a>測試。</li>
</ul>
<p>Rust 也支持在測試中指定額外的依賴：</p>
<ul>
<li><a href="testing/dev_dependencies.html">開發依賴</a></li>
</ul>
<h2 id="參見-69"><a class="header" href="#參見-69">參見</a></h2>
<ul>
<li><a href="https://rustwiki.org/zh-CN/book/second-edition/ch11-00-testing.html">TRPL</a> 中關於測試的章節</li>
<li><a href="https://rust-lang-nursery.github.io/api-guidelines/documentation.html">API 指導原則</a>中關於文檔測試的部分</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="單元測試"><a class="header" href="#單元測試">單元測試</a></h1>
<p>測試（test）是這樣一種 Rust 函數：它保證其他部分的代碼按照所希望的行為正常
運行。測試函數的函數體通常會進行一些配置，運行我們想要測試的代碼，然後
斷言（assert）結果是不是我們所期望的。</p>
<p>大多數單元測試都會被放到一個叫 <code>tests</code> 的、帶有 <code>#[cfg(test)]</code> 屬性
的<a href="testing/../mod.html">模塊</a>中，測試函數要加上 <code>#[test]</code> 屬性。</p>
<p>當測試函數中有什麼東西 <a href="testing/../std/panic.html">panic</a> 了，測試就失敗。有一些這方面的
輔助<a href="testing/../macros.html">宏</a>：</p>
<ul>
<li><code>assert!(expression)</code> - 如果表達式的值是 <code>false</code> 則 panic。</li>
<li><code>assert_eq!(left, right)</code> 和 <code>assert_ne!(left, right)</code> - 檢驗左右兩邊是否
相等/不等。</li>
</ul>
<pre><code class="language-rust ignore">pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

// 這個加法函數寫得很差，本例中我們會使它失敗。
#[allow(dead_code)]
fn bad_add(a: i32, b: i32) -&gt; i32 {
    a - b
}

#[cfg(test)]
mod tests {
    // 注意這個慣用法：在 tests 模塊中，從外部作用域導入所有名字。
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(1, 2), 3);
    }

    #[test]
    fn test_bad_add() {
        // 這個斷言會導致測試失敗。注意私有的函數也可以被測試！
        assert_eq!(bad_add(1, 2), 3);
    }
}
</code></pre>
<p>可以使用 <code>cargo test</code> 來運行測試。</p>
<pre><code class="language-bash">$ cargo test

running 2 tests
test tests::test_bad_add ... FAILED
test tests::test_add ... ok

failures:

---- tests::test_bad_add stdout ----
        thread 'tests::test_bad_add' panicked at 'assertion failed: `(left == right)`
  left: `-1`,
 right: `3`', src/lib.rs:21:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.


failures:
    tests::test_bad_add

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2 id="測試-panic"><a class="header" href="#測試-panic">測試 panic</a></h2>
<p>一些函數應當在特定條件下 panic。為測試這種行為，請使用 <code>#[should_panic]</code> 屬性。這
個屬性接受可選參數 <code>expected = </code> 以指定 panic 時的消息。如果你的函數能以多種方式
panic，這個屬性就保證了你在測試的確實是所指定的 panic。</p>
<pre><code class="language-rust ignore">pub fn divide_non_zero_result(a: u32, b: u32) -&gt; u32 {
    if b == 0 {
        panic!(&quot;Divide-by-zero error&quot;);
    } else if a &lt; b {
        panic!(&quot;Divide result is zero&quot;);
    }
    a / b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_divide() {
        assert_eq!(divide_non_zero_result(10, 2), 5);
    }

    #[test]
    #[should_panic]
    fn test_any_panic() {
        divide_non_zero_result(1, 0);
    }

    #[test]
    #[should_panic(expected = &quot;Divide result is zero&quot;)]
    fn test_specific_panic() {
        divide_non_zero_result(1, 10);
    }
}
</code></pre>
<p>運行這些測試會輸出：</p>
<pre><code class="language-bash">$ cargo test

running 3 tests
test tests::test_any_panic ... ok
test tests::test_divide ... ok
test tests::test_specific_panic ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests tmp-test-should-panic

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2 id="運行特定的測試"><a class="header" href="#運行特定的測試">運行特定的測試</a></h2>
<p>要運行特定的測試，只要把測試名稱傳給 <code>cargo test</code> 命令就可以了。</p>
<pre><code class="language-bash">$ cargo test test_any_panic
running 1 test
test tests::test_any_panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out

   Doc-tests tmp-test-should-panic

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>要運行多個測試，可以僅指定測試名稱中的一部分，用它來匹配所有要運行的測試。</p>
<pre><code class="language-bash">$ cargo test panic
running 2 tests
test tests::test_any_panic ... ok
test tests::test_specific_panic ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out

   Doc-tests tmp-test-should-panic

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2 id="忽略測試"><a class="header" href="#忽略測試">忽略測試</a></h2>
<p>可以把屬性 <code>#[ignore]</code> 賦予測試以排除某些測試，或者使用 <code>cargo test -- --ignored</code>
命令來運行它們。</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 2), 4);
    }

    #[test]
    fn test_add_hundred() {
        assert_eq!(add(100, 2), 102);
        assert_eq!(add(2, 100), 102);
    }

    #[test]
    #[ignore]
    fn ignored_test() {
        assert_eq!(add(0, 0), 0);
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-bash">$ cargo test
running 1 test
test tests::ignored_test ... ignored

test result: ok. 0 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out

   Doc-tests tmp-ignore

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

$ cargo test -- --ignored
running 1 test
test tests::ignored_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests tmp-ignore

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文檔測試"><a class="header" href="#文檔測試">文檔測試</a></h1>
<p>為 Rust 工程編寫文檔的主要方式是在源代碼中寫註釋。文檔註釋使用 <a href="https://daringfireball.net/projects/markdown/">markdown</a> 語法
書寫，支持代碼塊。Rust 很注重正確性，這些註釋中的代碼塊也會被編譯並且用作測試。</p>
<pre><code class="language-rust ignore">/// 第一行是對函數的簡短描述。
///
/// 接下來數行是詳細文檔。代碼塊用三個反引號開啟，Rust 會隱式地在其中添加
/// `fn main()` 和 `extern crate &lt;cratename&gt;`。比如測試 `doccomments` crate：
///
/// ```
/// let result = doccomments::add(2, 3);
/// assert_eq!(result, 5);
/// ```
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

/// 文檔註釋通常可能帶有 &quot;Examples&quot;、&quot;Panics&quot; 和 &quot;Failures&quot; 這些部分。
///
/// 下面的函數將兩數相除。
///
/// # Examples
///
/// ```
/// let result = doccomments::div(10, 2);
/// assert_eq!(result, 5);
/// ```
///
/// # Panics
///
/// 如果第二個參數是 0，函數將會 panic。
///
/// ```rust,should_panic
/// // panics on division by zero
/// doccomments::div(10, 0);
/// ```
pub fn div(a: i32, b: i32) -&gt; i32 {
    if b == 0 {
        panic!(&quot;Divide-by-zero error&quot;);
    }

    a / b
}
</code></pre>
<p>這些測試仍然可以通過 <code>cargo test</code> 執行：</p>
<pre><code class="language-bash">$ cargo test
running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests doccomments

running 3 tests
test src/lib.rs - add (line 7) ... ok
test src/lib.rs - div (line 21) ... ok
test src/lib.rs - div (line 31) ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2 id="文檔測試的目的"><a class="header" href="#文檔測試的目的">文檔測試的目的</a></h2>
<p>文檔測試的主要目的是作為使用函數功能的例子，這是最重要的<a href="https://rust-lang-nursery.github.io/api-guidelines/documentation.html#examples-use--not-try-not-unwrap-c-question-mark">指導
原則</a>之一。文檔測試應當可以作為完整的代碼段被直接
使用（很多用戶會複製文檔中的代碼來用，所以例子要寫得完善）。但使用 <code>?</code> 符號會
導致編譯失敗，因為 <code>main</code> 函數會返回 <code>unit</code> 類型。幸運的是，我們可以在文檔中
隱藏幾行源代碼：你可以寫 <code>fn try_main() -&gt; Result&lt;(), ErrorType&gt;</code> 這樣的
函數，把它隱藏起來，然後在隱藏的 <code>main</code> 中展開它。聽起來很複雜？請看例子：</p>
<pre><code class="language-rust ignore">/// 在文檔測試中使用隱藏的 `try_main`。
///
/// ```
/// # // 被隱藏的行以 `#` 開始，但它們仍然會被編譯！
/// # fn try_main() -&gt; Result&lt;(), String&gt; { // 隱藏行包圍了文檔中顯示的函數體
/// let res = try::try_div(10, 2)?;
/// # Ok(()) // 從 try_main 返回
/// # }
/// # fn main() { // 開始主函數，其中將展開 `try_main` 函數
/// #    try_main().unwrap(); // 調用並展開 try_main，這樣出錯時測試會 panic
/// # }
pub fn try_div(a: i32, b: i32) -&gt; Result&lt;i32, String&gt; {
    if b == 0 {
        Err(String::from(&quot;Divide-by-zero&quot;))
    } else {
        Ok(a / b)
    }
}
</code></pre>
<h2 id="參見-70"><a class="header" href="#參見-70">參見</a></h2>
<ul>
<li>關於文檔風格的 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md">RFC505</a></li>
<li><a href="https://rust-lang-nursery.github.io/api-guidelines/documentation.html">API 指導原則</a>中關於文檔的原則</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="集成測試"><a class="header" href="#集成測試">集成測試</a></h1>
<p><a href="testing/unit_testing.html">單元測試</a>一次僅能單獨測試一個模塊，這種測試是小規模的，並且能測試私有
代碼；集成測試是 crate 外部的測試，並且僅使用 crate 的公共接口，就像其他使用
該 crate 的程序那樣。集成測試的目的是檢驗你的庫的各部分是否能夠正確地協同工作。</p>
<p>cargo 在與 <code>src</code> 同級別的 <code>tests</code> 目錄尋找集成測試。</p>
<p>文件 <code>src/lib.rs</code>：</p>
<pre><code class="language-rust ignore">// 在一個叫做 'adder' 的 crate 中定義此函數。
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
</code></pre>
<p>包含測試的文件：<code>tests/integration_test.rs</code>：</p>
<pre><code class="language-rust ignore">
#[test]
fn test_add() {
    assert_eq!(adder::add(3, 2), 5);
}
</code></pre>
<p>使用 <code>cargo test</code> 命令：</p>
<pre><code class="language-bash">$ cargo test
running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-bcd60824f5fbfe19

running 1 test
test test_add ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p><code>tests</code> 目錄中的每一個 Rust 源文件都被編譯成一個單獨的 crate。在集成測試中要想
共享代碼，一種方式是創建具有公用函數的模塊，然後在測試中導入並使用它。</p>
<p>文件 <code>tests/common.rs</code>:</p>
<pre><code class="language-rust ignore">pub fn setup() {
    // 一些配置代碼，比如創建文件/目錄，開啟服務器等等。
}
</code></pre>
<p>包含測試的文件：<code>tests/integration_test.rs</code></p>
<pre><code class="language-rust ignore">// 導入共用模塊。
mod common;

#[test]
fn test_add() {
    // 使用共用模塊。
    common::setup();
    assert_eq!(adder::add(3, 2), 5);
}
</code></pre>
<p>帶有共用代碼的模塊遵循和普通的<a href="testing/../mod.html">模塊</a>一樣的規則，所以完全可以把公共模塊
寫在 <code>tests/common/mod.rs</code> 文件中。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="開發依賴"><a class="header" href="#開發依賴">開發依賴</a></h1>
<p>有時僅在測試中才需要一些依賴（比如基準測試相關的）。這種依賴要寫在 <code>Cargo.toml</code>
的 <code>[dev-dependencies]</code> 部分。這些依賴不會傳播給其他依賴於這個包的包。</p>
<p>比如說使用 <code>pretty_assertions</code>，這是擴展了標準的 <code>assert!</code> 宏的一個 crate。</p>
<p>文件 <code>Cargo.toml</code>:</p>
<pre><code class="language-ignore"># 這裡省略了標準的 crate 數據
[dev-dependencies]
pretty_assertions = &quot;1&quot;
</code></pre>
<p>文件 <code>src/lib.rs</code>:</p>
<pre><code class="language-rust ignore">pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;
    use pretty_assertions::assert_eq; // 僅用於測試, 不能在非測試代碼中使用

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
    }
}
</code></pre>
<h2 id="參見-71"><a class="header" href="#參見-71">參見</a></h2>
<p><a href="https://doc.crates.io/specifying-dependencies.html">Cargo</a> 文檔中關於指定依賴的部分。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="不安全操作"><a class="header" href="#不安全操作">不安全操作</a></h1>
<p>在本章一開始，我們借用<a href="unsafe">官方文檔</a>的一句話，“在整個代碼庫（code base，指
構建一個軟件系統所使用的全部代碼）中，要儘可能減少不安全代碼的量”。記住這句
話，接著我們進入學習！在 Rust 中，不安全代碼塊用於避開編譯器的保護策略；具體
地說，不安全代碼塊主要用於四件事情：</p>
<ul>
<li>解引用裸指針</li>
<li>通過 FFI 調用函數（這已經在<a href="std_misc/ffi.html">之前的章節</a>介紹過了）</li>
<li>調用不安全的函數</li>
<li>內聯彙編（inline assembly）</li>
</ul>
<h3 id="原始指針"><a class="header" href="#原始指針">原始指針</a></h3>
<p>原始指針（raw pointer，裸指針）<code>*</code> 和引用 <code>&amp;T</code> 有類似的功能，但引用總是安全
的，因為借用檢查器保證了它指向一個有效的數據。解引用一個裸指針只能通過不安全
代碼塊執行。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let raw_p: *const u32 = &amp;10;

    unsafe {
        assert!(*raw_p == 10);
    }
}
</code></pre></pre>
<h3 id="調用不安全函數"><a class="header" href="#調用不安全函數">調用不安全函數</a></h3>
<p>一些函數可以聲明為不安全的（<code>unsafe</code>），這意味著在使用它時保證正確性不再是編譯器
的責任，而是程序員的。一個例子就是 <a href="https://rustwiki.org/zh-CN/std/slice/fn.from_raw_parts.html"><code>std::slice::from_raw_parts</code></a>，向它傳入指向
第一個元素的指針和長度參數，它會創建一個切片。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::slice;

fn main() {
    let some_vector = vec![1, 2, 3, 4];

    let pointer = some_vector.as_ptr();
    let length = some_vector.len();

    unsafe {
        let my_slice: &amp;[u32] = slice::from_raw_parts(pointer, length);
        
        assert_eq!(some_vector.as_slice(), my_slice);
    }
}
</code></pre></pre>
<p><code>slice::from_raw_parts</code> 假設傳入的指針指向有效的內存，且被指向的內存具有正確的
數據類型，我們<strong>必須</strong>滿足這一假設，否則程序的行為是未定義的（undefined），於是
我們就不能預測會發生些什麼了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="兼容性"><a class="header" href="#兼容性">兼容性</a></h1>
<p>Rust 語言正在快速發展，因此儘管努力確保儘可能向前兼容，但仍可能出現某些兼容性問題。</p>
<ul>
<li><a href="compatibility/raw_identifiers.html">原始標識符</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="原始標誌符"><a class="header" href="#原始標誌符">原始標誌符</a></h1>
<p>與許多編程語言一樣，Rust 擁有“關鍵字”的概念。 這些標識符對語言有特定意義，所以不能在變量名、函數名和其他位置使用它們。 原始標識符允許你使用通常不允許的關鍵字。 當 Rust 引入新關鍵字時，使用舊版 Rust 的庫擁有與新版本中引入的關鍵字同名的變量或函數，這一點就特別有用。</p>
<p>舉個例子，使用 2015 版 Rust 編譯的 crate <code>foo</code>，它導出一個名為 <code>try</code> 的函數。 此關鍵字（<em>try</em>）在 2018 版本的新功能中保留下來，因此如果沒有原始標識符，我們將無法命名該功能。</p>
<pre><code class="language-rust ignore">extern crate foo;

fn main() {
    foo::try();
}
</code></pre>
<p>將得到如下錯誤：</p>
<pre><code class="language-text">error: expected identifier, found keyword `try`
 --&gt; src/main.rs:4:4
  |
4 | foo::try();
  |      ^^^ expected identifier, found keyword
</code></pre>
<p>使用原始標誌符重寫上述代碼：</p>
<pre><code class="language-rust ignore">extern crate foo;

fn main() {
    foo::r#try();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="補充"><a class="header" href="#補充">補充</a></h1>
<p>在軟件工程中，有些主題和寫程序並沒有直接的關聯，但它們為你提供了工具和基礎設施
支持，使得軟件對每個人都變得更易用。這些主題包括：</p>
<ul>
<li>文檔：通過附帶的 <code>rustdoc</code> 生成庫文檔給用戶。</li>
<li>測試：為庫創建測試套件，確保庫準確地實現了你想要的功能。</li>
<li>基準測試（benchmark）：對功能進行基準測試，保證其運行速度足夠快。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文檔"><a class="header" href="#文檔">文檔</a></h1>
<p>用 <code>cargo doc</code> 構建文檔到 <code>target/doc</code>。</p>
<p>用 <code>cargo test</code> 運行所有測試（包括文檔測試），用 <code>cargo test --doc</code> 僅運行文檔測試。</p>
<p>這些命令會恰當地按需調用 <code>rustdoc</code>（以及 <code>rustc</code>）。</p>
<h2 id="文檔註釋"><a class="header" href="#文檔註釋">文檔註釋</a></h2>
<p>文檔註釋對於需要文檔的大型項目來說非常重要。當運行 <code>rustdoc</code>，文檔註釋就會
編譯成文檔。它們使用 <code>///</code> 標記，並支持 <a href="https://en.wikipedia.org/wiki/Markdown">Markdown</a>。</p>
<pre><code class="language-rust editable ignore">#![crate_name = &quot;doc&quot;]

/// 這裡給出一個“人”的表示
pub struct Person {
    /// 一個人必須有名字（不管 Juliet 多討厭她自己的名字）。
    name: String,
}

impl Person {
    /// 返回具有指定名字的一個人
    ///
    /// # 參數
    ///
    /// * `name` - 字符串切片，代表人的名字
    ///
    /// # 示例
    ///
    /// ```
    /// // 在文檔註釋中，你可以書寫代碼塊
    /// // 如果向 `rustdoc` 傳遞 --test 參數，它還會幫你測試註釋文檔中的代碼！
    /// use doc::Person;
    /// let person = Person::new(&quot;name&quot;);
    /// ```
    pub fn new(name: &amp;str) -&gt; Person {
        Person {
            name: name.to_string(),
        }
    }

    /// 給一個友好的問候！
    /// 對被叫到的 `Person` 說 &quot;Hello, [name]&quot; 。
    pub fn hello(&amp; self) {
        println!(&quot;Hello, {}!&quot;, self.name);
    }
}

fn main() {
    let john = Person::new(&quot;John&quot;);

    john.hello();
}
</code></pre>
<p>要運行測試，首先將代碼構建為庫，然後告訴 <code>rustdoc</code> 在哪裡找到庫，這樣它就可以
使每個文檔中的程序鏈接到庫：</p>
<pre><code class="language-shell">$ rustc doc.rs --crate-type lib
$ rustdoc --test --extern doc=&quot;libdoc.rlib&quot; doc.rs
</code></pre>
<h2 id="文檔屬性"><a class="header" href="#文檔屬性">文檔屬性</a></h2>
<p>下面是一些使用 <code>rustdoc</code> 時最常使用的 <code>#[doc]</code> 屬性的例子。</p>
<h3 id="inline"><a class="header" href="#inline"><code>inline</code></a></h3>
<p>用於內聯文檔，而不是鏈接到單獨的頁面。</p>
<pre><code class="language-rust ignore">#[doc(inline)]
pub use bar::Bar;

/// bar 的文檔
mod bar {
    /// Bar 的文檔
    pub struct Bar;
}
</code></pre>
<h3 id="no_inline"><a class="header" href="#no_inline"><code>no_inline</code></a></h3>
<p>用於防止鏈接到單獨的頁面或其他位置。</p>
<pre><code class="language-rust ignore">// 來自 libcore/prelude 的例子
#[doc(no_inline)]
pub use crate::mem::drop;
</code></pre>
<h3 id="hidden"><a class="header" href="#hidden"><code>hidden</code></a></h3>
<p>使用此屬性來告訴 <code>rustdoc</code> 不要包含此項到文檔中：</p>
<pre><code class="language-rust editable ignore">// 來自 futures-rs 庫的例子
#[doc(hidden)]
pub use self::async_await::*;
</code></pre>
<p>對文檔來說， <code>rustdoc</code> 被社區廣泛採用。<a href="https://doc.rust-lang.org/std/">標準庫文檔</a>也是用它生成的。</p>
<h3 id="參見-72"><a class="header" href="#參見-72">參見:</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#making-useful-documentation-comments">The Rust Book: Making Useful Documentation Comments</a></li>
<li><a href="https://doc.rust-lang.org/rustdoc/index.html">The rustdoc Book</a></li>
<li><a href="https://doc.rust-lang.org/stable/reference/comments.html#doc-comments">The Reference: Doc comments</a></li>
<li><a href="https://rust-lang.github.io/rfcs/1574-more-api-documentation-conventions.html#appendix-a-full-conventions-text">RFC 1574: API Documentation Conventions</a></li>
<li><a href="https://rust-lang.github.io/rfcs/1946-intra-rustdoc-links.html">RFC 1946: Relative links to other items from doc comments (intra-rustdoc links)</a></li>
<li><a href="https://www.reddit.com/r/rust/comments/ahb50s/is_there_any_documentation_style_guide_for/">Is there any documentation style guide for comments? (reddit)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="playpen"><a class="header" href="#playpen">Playpen</a></h1>
<p><a href="https://github.com/rust-lang/rust-playpen">Rust Playpen</a> 是一個在線運行 Rust 代碼的網絡接口。現在該項目通常稱為 <a href="https://play.rust-lang.org/">Rust Playground</a>。</p>
<h2 id="在-mdbook-使用"><a class="header" href="#在-mdbook-使用">在 <code>mdbook</code> 使用</a></h2>
<p>在 <a href="https://github.com/rust-lang/mdBook"><code>mdbook</code></a> 中，你可以讓示例代碼運行和編輯。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    println!(&quot;Hello World!&quot;);
}
</code></pre></pre>
<p>這使讀者既可以運行你的代碼示例，也可以對其進行修改和調整。此處的關鍵是將單詞添加 <code>editable</code> 到代碼塊中，並用逗號分隔。</p>
<pre><code class="language-markdown">```rust,editable
//...將你的代碼寫在這裡
```
</code></pre>
<p>此外，如果想要 <code>mdbook</code> 在構建和測試時跳過該代碼，則可以添加 <code>ignore</code>。</p>
<pre><code class="language-markdown">```rust,editable,ignore
//...將你的代碼寫在這裡
```
</code></pre>
<h2 id="在文檔中使用"><a class="header" href="#在文檔中使用">在文檔中使用</a></h2>
<p>可能你已經在某些 <a href="https://rustwiki.org/zh-CN/core/">Rust 官方文檔</a>中注意到了一個名為 “Run” 的按鈕，該按鈕在 Rust Playground 的新選項卡中打開了代碼示例。如果使用名為的 <a href="https://doc.rust-lang.org/rustdoc/the-doc-attribute.html#html_playground_url"><code>html_playground_url</code></a> 的 #[doc] 屬性，則啟用此功能。</p>
<h3 id="參見-73"><a class="header" href="#參見-73">參見：</a></h3>
<ul>
<li><a href="https://play.rust-lang.org/">The Rust Playground</a></li>
<li><a href="https://github.com/integer32llc/rust-playground/">下一代 playpen</a></li>
<li><a href="https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html">官方文檔</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="language.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
